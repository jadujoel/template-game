{
  "version": 3,
  "sources": ["../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-version-display/src/version.ts", "../node_modules/@netent-tech/ecas-version-display/src/ECASVersionDisplay.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/Observable.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/StateMachine.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/event-config/translations.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-engine-api/IInserts.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/loadr-config/index.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/BusConfig.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Group.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EnvelopeData.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EnvelopePreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Patterns.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/PoolItem.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Pool.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EncoderSettings.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EncoderPreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/FormatPreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Settings.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/SoundEncoding.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Sound.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/SoundConfig.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-inserts/src/utils/index.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/AlgorithmicReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/BiquadFilterInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/ConvolverReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DynamicsCompressorInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/PingPongDelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/createInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/InsertHandler.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/types.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/constants.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/PingPongDelayConfig.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/ReverbConfig.ts", "../node_modules/@netent-tech/ecas-common/src/utils/string-formatters.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-common/src/utils/type-check.ts", "../node_modules/@netent-tech/ecas-common/src/utils/errors.ts", "../node_modules/@netent-tech/ecas-common/src/index.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/beats.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/Eutils.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/sort.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/translations.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/EventHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/EcasEvents.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/buffers.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/errors.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/SoundHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/AssetHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/formats.ts", "../node_modules/@netent-tech/ecas-engine/src/constants.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/envelope-context.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/EnvelopeHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/index.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/envelopes.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/timeouts.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/Timer.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buffer.ts", "../node_modules/@netent-tech/ecas-engine/src/id-generator.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-inserts/src/utils/index.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/AlgorithmicReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/BiquadFilterInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/ConvolverReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DynamicsCompressorInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/PingPongDelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/createInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/InsertHandler.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/types.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/node-creators.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/silence.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buses/Bus.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buses/BusHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/create-audio-params.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/get-default-value-from-sound-config.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/onended.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/Mixer.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/LoadrConfig.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/index.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/PlaySoundArgs.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/StopSoundArgs.ts", "../node_modules/@netent-tech/ecas-engine/src/other/AnalyserConfig.ts", "../node_modules/@netent-tech/ecas-engine/src/other/VolumeMeter.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/audio-param-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/stereo-panner-node-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/webkit-audio-context-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/install.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/index.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/AudioScheduler.ts", "../node_modules/@netent-tech/ecas-engine/src/sequencer/tempo.ts", "../node_modules/@netent-tech/ecas-engine/src/sequencer/Sequencer.ts", "../node_modules/@netent-tech/ecas-engine/src/ECAS.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-version-display/src/version.ts", "../node_modules/@netent-tech/ecas-version-display/src/ECASVersionDisplay.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/Observable.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/StateMachine.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/event-config/translations.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-engine-api/IInserts.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/loadr-config/index.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/BusConfig.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Group.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EnvelopeData.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EnvelopePreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Patterns.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/PoolItem.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Pool.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EncoderSettings.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/EncoderPreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/FormatPreset.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Settings.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/SoundEncoding.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/Sound.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/SoundConfig.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-inserts/src/utils/index.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/AlgorithmicReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/BiquadFilterInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/ConvolverReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DynamicsCompressorInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/PingPongDelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/createInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/InsertHandler.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/types.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/constants.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/PingPongDelayConfig.ts", "../node_modules/@netent-tech/ecas-common/src/ecas-config/sound-config/ReverbConfig.ts", "../node_modules/@netent-tech/ecas-common/src/utils/string-formatters.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-common/src/utils/type-check.ts", "../node_modules/@netent-tech/ecas-common/src/utils/errors.ts", "../node_modules/@netent-tech/ecas-common/src/index.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/beats.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/Eutils.ts", "../node_modules/@netent-tech/ecas-engine/src/utils/sort.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/translations.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/EventHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/event-handler/EcasEvents.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/buffers.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/errors.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/SoundHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/AssetHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/asset-handler/formats.ts", "../node_modules/@netent-tech/ecas-engine/src/constants.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/envelope-context.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/EnvelopeHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/index.ts", "../node_modules/@netent-tech/ecas-engine/src/envelopes/envelopes.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/timeouts.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/Timer.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buffer.ts", "../node_modules/@netent-tech/ecas-engine/src/id-generator.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-inserts/src/utils/index.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-logger/src/logger.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-utils/src/object/object.ts", "../node_modules/@netent-tech/ecas-utils/src/browser-detection/browser-detection.ts", "../node_modules/@netent-tech/ecas-utils/src/clamp/clamp.ts", "../node_modules/@netent-tech/ecas-utils/src/type-check/type-check.ts", "../node_modules/@netent-tech/ecas-utils/src/clone/clone.ts", "../node_modules/@netent-tech/ecas-utils/src/enum/enum.ts", "../node_modules/@netent-tech/ecas-utils/src/ignore-unused/ignore-unused.ts", "../node_modules/@netent-tech/ecas-utils/src/join-url/join-url.ts", "../node_modules/@netent-tech/ecas-utils/src/math/math.ts", "../node_modules/@netent-tech/ecas-utils/src/noop/noop.ts", "../node_modules/@netent-tech/ecas-utils/src/strict-map/strict-map.ts", "../node_modules/@netent-tech/ecas-utils/src/try-catch/try-catch.ts", "../node_modules/@netent-tech/ecas-utils/src/types/types.ts", "../node_modules/@netent-tech/ecas-automator/src/automator.ts", "../node_modules/@netent-tech/ecas-utils/src/array/array.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/implementation.ts", "../node_modules/@netent-tech/ecas-automator/src/curves/creator.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/AlgorithmicReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/BiquadFilterInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/ConvolverReverbInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/DynamicsCompressorInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/PingPongDelayInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/createInsert.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/InsertHandler.ts", "../node_modules/@netent-tech/ecas-inserts/src/inserts/types.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/node-creators.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/silence.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buses/Bus.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/buses/BusHandler.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/create-audio-params.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/get-default-value-from-sound-config.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/onended.ts", "../node_modules/@netent-tech/ecas-engine/src/mixer/Mixer.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/LoadrConfig.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/index.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/PlaySoundArgs.ts", "../node_modules/@netent-tech/ecas-engine/src/options-creator/StopSoundArgs.ts", "../node_modules/@netent-tech/ecas-engine/src/other/AnalyserConfig.ts", "../node_modules/@netent-tech/ecas-engine/src/other/VolumeMeter.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/audio-param-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/stereo-panner-node-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/webkit-audio-context-polyfill.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/install.ts", "../node_modules/@netent-tech/ecas-engine/src/polyfills/index.ts", "../node_modules/@netent-tech/ecas-engine/src/scheduling/AudioScheduler.ts", "../node_modules/@netent-tech/ecas-engine/src/sequencer/tempo.ts", "../node_modules/@netent-tech/ecas-engine/src/sequencer/Sequencer.ts", "../node_modules/@netent-tech/ecas-engine/src/ECAS.ts", "../node_modules/@netent-tech/ecas-provider/src/event-queue.ts", "../node_modules/@netent-tech/ecas-provider/src/ecas-provider.ts", "../src/audio.ts", "../src/game.ts", "../src/index.ts"],
  "sourcesContent": ["/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "export const version = '2.1.2'\n", "import { version } from './version'\n\nconst navigatorExists = (): boolean => {\n  return typeof navigator !== 'undefined'\n}\n\nconst hasFancyConsole = (hasNavigator?: boolean): boolean => {\n  return (hasNavigator ?? navigatorExists()) && /chrome|firefox/i.test(navigator?.userAgent.toLowerCase())\n}\n\nconst createMessage = (version: string, fancy: boolean): string[] => {\n  const text = `\uD83C\uDFB5 ECAS: v${version} \uD83C\uDFB5`\n  if (fancy) {\n    const message = `\\n%c${text}%c\\n\\n`\n    const style = 'color: #FFFFFF; background: #ff7373; padding:10px'\n    const padding = 'padding:0'\n    return [message, style, padding]\n  } else {\n    const dottedLone = text.split('').map(() => '.').join('')\n    const message = `${dottedLone}\\n${text}\\n${dottedLone}`\n    return [message]\n  }\n}\n\n/**\n * @example\n * Pass in the ecas-logger to be able to turn on or off version display with the logger option\n * ```ts\n * logEcasVersion(logger().log)\n * ```\n */\nexport const logEcasVersion = (logger: Console['log']): void => {\n  logger(...createMessage(version, hasFancyConsole()))\n}\n\nexport const Test = {\n  navigatorExists,\n  hasFancyConsole,\n  createMessage\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { StrictMap } from \"@netent-tech/ecas-utils\"\r\n\r\ntype CallbackType = (...args: any[]) => any\r\n\r\nexport class Observable {\r\n    #record = new StrictMap<string, Array<CallbackType>>()\r\n\r\n    /**\r\n     * Adds the event listener.\r\n     *\r\n     * @param {string} event - The event to listen to.\r\n     * @param {CallbackType} listener - The listener that is called when the event is emitted.\r\n     * @throws {Error} If the parameters are not provided correctly.\r\n     * @returns {void}\r\n     */\r\n    on(event: string, listener: CallbackType): void {\r\n        if (this.#record.has(event)) {\r\n            this.#record.get(event).push(listener)\r\n        }\r\n        else {\r\n            this.#record.set(event, [listener])\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the event listener.\r\n     *\r\n     * @param {string} event - The event to remove.\r\n     * @param {Function} listener - The listener that is called when the event is emitted.\r\n     * @throws {Error} If the parameters are not provided correctly.\r\n     * @returns {boolean} Wether or not the event listener was removed.\r\n     */\r\n    off(event: string, listener: CallbackType): boolean {\r\n        if (!this.#record.has(event)) {\r\n            logger().error(`[ecas] cannot remove event: ${event} since it does not exist`)\r\n            return false\r\n        }\r\n\r\n        const callbacks = this.#record.get(event)\r\n        const callbacksFiltered = callbacks.filter((callback: CallbackType) => callback !== listener)\r\n\r\n        if (callbacksFiltered.length !== callbacks.length) {\r\n            this.#record.set(event, callbacksFiltered)\r\n            return true\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    /**\r\n     * Emits the event along with the provided arguments.\r\n     *\r\n     * @param {string} event - The event to emit.\r\n     * @param {Array<any>} eventArguments - The event arguments\r\n     * @returns {void}\r\n     */\r\n    emit(event: string, ...args: Array<any>): void {\r\n        if (this.#record.has(event)) {\r\n            for (const callback of this.#record.get(event)) {\r\n                callback(...args)\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { Assert, AssertExists, AssertObjectNotEmpty, Disposable, Exists, isObject } from '@netent-tech/ecas-utils'\r\nimport { IAudioState, ILoadrConfig, StateConfig } from \"@netent-tech/ecas-common\"\r\n\r\ninterface IAudioStateWithParent extends IAudioState {\r\n    parent: string\r\n}\r\n\r\nconst GENESIS = 'genesis' as const\r\n\r\ntype StateName = string\r\n\r\nexport class StateMachine implements Disposable {\r\n    private _activeStateName: StateName\r\n    private _activeState: IAudioStateWithParent\r\n    private _states = new Map<string, IAudioStateWithParent> ()\r\n\r\n    dispose() {\r\n        this.states.clear()\r\n    }\r\n\r\n    constructor(audioStates: StateConfig, loaderConfig: Readonly<ILoadrConfig>) {\r\n        this._activeStateName = this.getInitialStateName(loaderConfig)\r\n\r\n        // Create State Map\r\n        let full: string = GENESIS\r\n        const iter = (state: IAudioState, name = '', parent = '', sep = '::') => {\r\n            const children = state.children\r\n            full = name ? `${full}${sep}${name}` : full\r\n            this.addState(full, state, parent)\r\n\r\n            for (const child_name in children) {\r\n                const childState = Exists(\r\n                    children[child_name], \r\n                    `StateHandler.constructor.iter(); child state with name ${child_name} does not exist in children.`\r\n                )\r\n                iter(childState, child_name, full)\r\n            }\r\n            full = full.slice(0, full.length - name.length - sep.length)\r\n        }\r\n\r\n        const genesisState = Exists(audioStates[GENESIS], \r\n            `StateHandler.constructor(); state_config[${GENESIS}] does not exist in audio-states.`\r\n        )\r\n\r\n        iter(genesisState)\r\n\r\n        this._activeState = Exists(this._states.get(this._activeStateName), \r\n            `activeStateName: ${this._activeStateName} does not exist in strarr([...this._states.keys()])}`\r\n        )\r\n\r\n        this.saveStateToLocalStorage(this._activeStateName)\r\n        logger().table('[ecas] states:'); logger().table([...this._states.keys()])\r\n    }\r\n\r\n    get states() {\r\n        return this._states\r\n    }\r\n\r\n    getInitialStateName (loaderConfig: ILoadrConfig): string {\r\n        const name = this.readStateNameFromLocalStorage()\r\n        if (name !== null && this._states.has(name)) {\r\n            return name\r\n        }\r\n        if(loaderConfig.initState) {\r\n            return loaderConfig.initState\r\n        }\r\n        return GENESIS\r\n    }\r\n\r\n    readStateNameFromLocalStorage (): string | null {\r\n        const localStorageState = localStorage.getItem(\"ECAS_AUDIO_STATE\")\r\n        logger().debug(`[ecas] read state ${localStorageState} from localStorage`)\r\n\r\n        return localStorageState\r\n    }\r\n\r\n    saveStateToLocalStorage (name: string): void {\r\n        logger().debug(\"[ecas] save state to localstorate\", name)\r\n        const localStorageName = 'ECAS_AUDIO_STATE'\r\n        localStorage.setItem(localStorageName, name)\r\n    }\r\n\r\n    addState(name: string, state: IAudioState, parent = '') {\r\n        const stateWithParent: IAudioStateWithParent = {\r\n            ...state,\r\n            parent: parent\r\n        }\r\n\r\n        Assert(!this._states.has(name), \r\n            \"[ecas] cannot add the state since it already exist on the same level.. E.g Another state with the same name and iheritance was already added.\")\r\n\r\n        if (parent) {\r\n            const parent_state = Exists(this._states.get(parent), \r\n                `[ecas] state.parent = ${parent} does not exist on name: ${name}. Existing states are: ${[...this._states.keys()]}}`)\r\n\r\n            AssertExists(parent_state.children, \r\n                `[ecas] parent_state.children does not exist in: ${parent_state}`)\r\n\r\n            AssertObjectNotEmpty(parent_state.children, \r\n                `[ecas] parent_state.children is empty in ${parent_state}`)\r\n\r\n            // Add all the parent events to the child\r\n            stateWithParent.events = {\r\n                ...this.getState(parent).events,\r\n                ...stateWithParent.events\r\n            }\r\n\r\n        }\r\n\r\n        this._states.set(name, stateWithParent)\r\n    }\r\n\r\n    /**\r\n     * Triggers a state change if the event is mapped to a connected state.\r\n     */\r\n    triggerStateChange(gameEvent: string, ...args: readonly unknown []): void {\r\n        logger().debug('[ecas] trigger state change', gameEvent, ...args)\r\n\r\n        const shouldMoveToParentState = this._shouldChangeState(this._activeState.deactivatesOn, gameEvent, args)\r\n        // need to loop through here and see if any parent state activates / deactivates on\r\n\r\n        if (shouldMoveToParentState) {\r\n            this.changeState(this._activeState.parent)\r\n        }\r\n\r\n        for (const child_name in this._activeState.children) {\r\n            const child = Exists(this._activeState.children[child_name], \r\n                `[ecas] child: ${child_name} does not exist in states.`\r\n            )\r\n            const shouldMoveToChildState = this._shouldChangeState(child.activatesOn, gameEvent, args)\r\n\r\n            if (shouldMoveToChildState) {\r\n                this.changeState(`${this._activeStateName}::${child_name}`)\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    changeState (stateName: string): void | never {\r\n        logger().info(`[ecas] moving from state: ${this._activeStateName} to ${stateName}`)\r\n        this._activeState = Exists(this._states.get(stateName), \r\n            `[ecas] could not find state: ${stateName}`)\r\n        this._activeStateName = stateName\r\n\r\n        this.saveStateToLocalStorage(this._activeStateName)\r\n    }\r\n\r\n    get activeStateName (): string {\r\n        return this._activeStateName\r\n    }\r\n\r\n    /**\r\n     * Checks if the state is changed by the game event and the arguments.\r\n     */\r\n    private _shouldChangeState(activation: StateConfig[keyof StateConfig]['activatesOn' | 'deactivatesOn'], eventName: string, eventArguments: readonly unknown [] = []): boolean {\r\n        const matches = activation.filter((act) => {\r\n            if (isObject(act)) {\r\n                const eventNamesCorrespond = act.event === eventName\r\n                const everyEntry = act.values.every((entry) => {\r\n                    return eventArguments.includes(entry)\r\n                })\r\n                return eventNamesCorrespond && everyEntry\r\n            }\r\n            return act === eventName\r\n        })\r\n        const anyMatches = matches.length > 0\r\n        return anyMatches\r\n    }\r\n\r\n    get activeState () {\r\n        return Exists(this._states.get(this._activeStateName),\r\n            `[ecas] supposedly active state: ${this._activeStateName} not found in states.`)\r\n    }\r\n\r\n    getState (name: string) {\r\n        return Exists(this._states.get(name), \r\n            `[ecas] state ${name} does not exist`)\r\n    }\r\n\r\n    get state () {\r\n        return this._activeStateName\r\n    }\r\n}\r\n", "import { type ValueOrRandom } from '../../ecas-engine-api/RandomNotation'\n\nexport const TranslationProps = {\n  min: 'min',\n  max: 'max',\n  in: 'in',\n  out: 'out',\n  param: 'param'\n} as const\ninterface IParam {\n  [TranslationProps.param]: number\n}\n\nexport interface IBasicTranslation {\n  [TranslationProps.in]: number\n  [TranslationProps.out]: ValueOrRandom\n}\nexport interface IMinMaxTranslation extends IParam {\n  [TranslationProps.min]: IBasicTranslation\n  [TranslationProps.max]: IBasicTranslation\n}\n\nexport type Translation = IBasicTranslation & IParam | IMinMaxTranslation\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "import { type Identifiable, type ITypeNamed } from '@netent-tech/ecas-utils'\nimport { type Automator, type AutomatableParameters } from '@netent-tech/ecas-automator'\nimport { type AlgorithmicReverbInsert, type BiquadFilterInsert, type DynamicsCompressorInsert, type ConvolverReverbInsert, type DelayInsert, type PingPongDelayInsert } from '@netent-tech/ecas-inserts'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type Sound } from '..'\n\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nexport interface ConvolverReverbInsertOptions extends Identifiable {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: Sound['id']\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { type LoggerName } from '@netent-tech/ecas-logger'\nimport type { IForcePolyfill, Sound } from '../..'\n\nexport enum AudioFileExtension {\n  CAF = '.caf',\n  WEBM = '.webm',\n  MP4 = '.mp4',\n  OGG = '.ogg',\n  MP3 = '.mp3',\n  WAV = '.wav'\n}\n\nexport interface ILoadrConfig {\n  /** Force ecas to use a package with the same id for example to force load mobile package on desktop. */\n  packageToUse?: string\n  forcePolyfills?: IForcePolyfill\n  /** For testing purposes - force Ecas to load a specified file extension such as \".mp3\", \".webm\"  */\n  fileExtToUse?: AudioFileExtension\n  /** Force Ecas StateHandler to load a specified state on initialization, otherwise will load genesis state. */\n  initState?: string\n  /** true will load all sounds, array of strings will load those specified sounds */\n  preload?: boolean | Array<Sound['id']>\n  /** The data generated by ecas-encoder which contains the sound id and its duration */\n  soundData?: Map<string, number> | Array<[string, number]>\n  /** Should audio context automatically be paused when invisible and unpaused when visible */\n  pauseOnInvisible?: boolean\n  /** Should audio context automatically be resumed when visible and unpaused when visible */\n  resumeOnVisible?: boolean\n  /** Should audio output be muted when window is invisible */\n  muteOnInvisible?: boolean\n  /** Should audio output be unmuted when window is visible */\n  unmuteOnVisible?: boolean\n  /** Use logger for debugging. Defaults to 'none'\n     * @param logger \"none\" | \"console\" | \"timestamp\"\n     */\n  logger?: LoggerName\n  /**\n     * if these game events where triggered before AudioContext was unlocked, the will fire once it is unlocked.\n     * So if game sends a \"start-main-music\" event before AudioContext could be started (due to no user interaction)\n     * then that event will be queued and fired on the first user interaction.\n     * use true to queue all events\n     * use an array of gameEvent names to queue only those events\n     */\n  queue?: true | string[]\n}\n", "import { type ITypeNamed, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { MASTER_BUS_ID } from '../..'\nimport { type MinusOneToOneNumber } from './MinusOneToOne'\nimport { type ZeroToOneNumber } from './ZeroToOne'\n\nconst typename = 'BusConfig' as const\n\n/** Settings for Summing-Buses. */\nexport class BusConfig implements ITypeNamed<typeof typename> {\n  static typename: typeof typename = typename\n  typename: typeof typename = BusConfig.typename\n\n  /** Bus id */\n  id = 'mainBus'\n\n  /** Starting bus volume. */\n  volume: ZeroToOneNumber = 1\n\n  /** Starting bus pan. */\n  pan: MinusOneToOneNumber = 0\n\n  /** Id of bus to send post-fader output to. Optional, defaults to 'master' */\n  destination: string = MASTER_BUS_ID\n\n  constructor (busProps: PartialProperties<BusConfig> = {}) {\n    Object.assign(this, busProps)\n  }\n\n  // Effects?\n}\nexport default BusConfig\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\nexport class Group {\n  /** Group id. */\n  id = 'mainGroup'\n\n  /** Encoding format preset to use for the group. */\n  format = 'mainFormat'\n\n  /** Target bus. Defaults to 'master' */\n  bus = 'master'\n\n  /** Limit number of sounds that can play simultaneously on the bus.\n     * If limit is exceeded last triggered sound will take over from oldest triggered.\n     * Todo: Should be renamed to maxNumberOfSimultaneusSounds?\n     **/\n  limit = Number.MAX_SAFE_INTEGER\n\n  /**\n     * Crossfade time in milliseconds when group limit is active and a sound takes over from another.\n     **/\n  crossfade = 10\n\n  /**\n     * Duration in milliseconds in which triggering of sounds in the group should be blocked after previous trigger.\n     * Todo: should be renamed stealTime\n     **/\n  triggerLimit = 0\n\n  constructor (props: PartialProperties<Group> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default Group\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\n/** List of envelope points. */\nexport class EnvelopeData {\n  /**\n     * Envelope point position, in 'bar.beat.tick' or millisecond format.\n     * The size of a tick is 32 per beat.\n     * So with a time signature where each beat is a quarter (4/4 or 3/4), 8 ticks would be a 16th note and 16 ticks an 8th.\n     **/\n  pos = 0 // Position = \"0.0.0\"\n\n  /**\n     * Value to set property to.\n     * Available range will very depending on what you are modulating, for example volume is between 0-1 and pan between -1 to 1.\n     * Use 'current' to indicate value should be original value before envelope started.\n     * Maybe this can also hold randomized values? I don't know if it should be able to but I will make it so for now.\n     **/\n  // val: \"current\" | number | DefaultParameterType<number> = \"current\"\n  val: 'current' | 'default' | number = 'current'\n\n  constructor (props: PartialProperties<EnvelopeData> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default EnvelopeData\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EnvelopeData } from './EnvelopeData'\nimport { type EnvelopePresetParams } from './Types'\n\nexport class EnvelopePreset {\n  /** Envelope ID. */\n  id = ''\n\n  /** Parameter to modulate, for example 'volume' or 'pan'. */\n  param: EnvelopePresetParams = 'volume'\n  data: EnvelopeData[] = []\n\n  /** Todo: added when mergin soundconfigs */\n  busId?: string\n\n  constructor (props: DeepPartialProperties<EnvelopePreset | Readonly<EnvelopePreset>> = {}) {\n    Object.assign(this, props)\n    if (props.data != null) {\n      this.data = props.data.map((d) => new EnvelopeData(d))\n    }\n  }\n}\n\nexport default EnvelopePreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EnvelopePreset } from './EnvelopePreset'\nimport { type DelayType, type PanType, type PitchType, type TimeSignature, type VolumeType } from './Types'\n\n/**\n * A pattern allows playing back multiple sounds at the same time, but can also put an individual sound in a context which allows for modifying volume and pan.\n **/\nexport class Pattern {\n  /**\n     * If pattern item should be a sound, specify sound id here. Optional.\n     **/\n  sound?: string\n\n  /** Todo: added when merging soundConfig Types */\n  sequence?: string\n\n  /** Todo: added when merging soundConfig Types */\n  parentId?: string\n\n  /**\n     * If true, item will keep looping until pattern is stopped.\n     * Only applicable if 'sound' is specified for the pattern item.\n     **/\n  loop = false\n\n  /**\n     * Volume to play sound at. Only applicable if 'sound' is specified for the pattern item.\n     **/\n  volume: VolumeType = 1\n\n  /**\n     * Used to send arguments to synthesized sounds.\n     * Although I don't think this is actually implemented?\n     **/\n  args: object[] = []\n\n  /**\n     * Pan to play sound with. Only applicable if 'sound' is specified for the pattern item.\n     * */\n  // Validate sound is specified if this is specified\n  pan: PanType = 0\n\n  /** Pitch offset for sounds in cents. */\n  pitch: PitchType = 0\n\n  /**\n     * Start position value in milliseconds.\n     * Only applicable if 'sound' is specified for the pattern item.\n     **/\n  startPos: DelayType = 0\n\n  /** Delay value in milliseconds */\n  delay: DelayType = 0\n\n  /** Duration value in milliseconds.  Only applicable if 'sound' is specified for the pattern item. */\n  duration?: DelayType\n\n  /**\n     * If pattern item should be a envelope, specify envelope preset id or envelope data here. Optional.\n     **/\n  envelope?: EnvelopePreset\n\n  /**\n     * bus to apply envelope to. Only applicable if 'envelope' is specified for the pattern item.\n     * You can provide either soundId or bussId.\n     * If you do not provide either, envelope will apply to all sounds in pattern.\n     **/\n  // Validate envelope is specified and soundId is not\n  bussId?: string\n\n  /**\n     * Sound to apply envelope to. Only applicable if 'envelope' is specified for the pattern item.\n     * You can provide either soundId OR bussId.If you do not provide either, envelope will apply to all sounds in pattern.\n     **/\n  soundId?: string\n\n  /**\n     * If pattern item should be another pattern, specify pattern id here. Optional.\n     **/\n  pattern?: string\n\n  /**\n     * If pattern item should be a pool, specify pool id here. Optional.\n     **/\n  // Validate pool id exists\n  pool?: string\n\n  constructor (props: DeepPartialProperties<Pattern> = {}) {\n    Object.assign(this, props)\n    function isEnvelopePreset (thing: typeof props.envelope): thing is EnvelopePreset {\n      return thing !== undefined && typeof thing !== 'string'\n    }\n    if (isEnvelopePreset(props.envelope)) {\n      this.envelope = new EnvelopePreset(props.envelope)\n    }\n  }\n}\n\n/**\n * Patterns allows playing back multiple sounds at the same time, but can also put an individual sound in a context which allows for modifying volume and pan.\n **/\nexport class PatternWrapper {\n  /** Pattern id. */\n  id = ''\n\n  sync?: boolean\n\n  /** Pattern definition */\n  pattern: Pattern[] = []\n\n  /** Pattern tempo. Will override global tempo when pattern is played. */\n  tempo?: number\n\n  /**\n     * Resolution used for quantized events.\n     * Can either be whole number for bars, or fraction for quarter note, eight or 16th.\n     * Will override global trigger quantize when specified.\n     * */\n  triggerQuantize?: number = 1 // 4/4\n\n  /** Time signature. For example \"4/4\" or \"3/4\". Will override global time signature when specified. */\n  timeSignature?: TimeSignature\n\n  constructor (props: DeepPartialProperties<PatternWrapper> = {}) {\n    Object.assign(this, props)\n    if (props.pattern !== undefined && props.pattern !== null) {\n      this.pattern = props.pattern.map((pattern) => new Pattern(pattern))\n    }\n  }\n}\n\nexport default PatternWrapper\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { type DelayType, type PanType, type PitchType, type PoolItemTypes, type VolumeType } from './Types'\n\n/**\n * Pool item. Use target to set target sound, pattern or pool and set type accordingly. type defaults to 'sound',\n **/\nexport class PoolItem {\n  /**\n     * Use target to set target sound id, pattern id or pool id.\n     **/\n  target = ''\n\n  /**\n     * Defaults to sound, but should be set according to target id: 'sound' | 'pattern' | 'pool'\n     * */\n  type: PoolItemTypes = 'sound'\n\n  /** If pool item should loop */\n  loop = false\n  volume: VolumeType = 1\n  pan: PanType = 0\n  pitch: PitchType = 0\n  delay: DelayType = 0\n  startPos: DelayType = 0\n  duration?: DelayType\n\n  constructor (props: DeepPartialProperties<PoolItem> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default PoolItem\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { PoolItem } from './PoolItem'\nimport { type PoolTypes } from './Types'\n\n/**\n * A sound pool will play a different sound on each trigger.\n **/\nexport class Pool {\n  /**\n     * Pool Id\n     */\n  id = ''\n\n  /**\n     * Array of pool items.\n     */\n  items: PoolItem[] = []\n\n  /**\n     * Type of pool, Can be either 'random' or 'sequential'.\n     * A random pool with play back according a random shuffle, and sequential will play back in the order sounds are listed.\n     **/\n  type: PoolTypes = 'sequential'\n\n  /**\n     * Weighting determining how often each sound will play.\n     * An array, where index of each number should be the same as the list of sounds for the pool.\n     * For random pools a higher number means higher chance of a sound being selected,\n     * and if sequential: sound will be duplicated in the sequence corresponding number of times.\n     * Optional and defaults to even weight for each sound.\n     **/\n  priority?: number[]\n\n  /**\n     * Max number of simultaneus sounds this pool can play. Set 1 for monophonic.\n     */\n  limit?: number = 100\n\n  constructor (props: DeepPartialProperties<Pool> = {}) {\n    Object.assign(this, props)\n    if (props.items != null) {\n      this.items = props.items.map((item) => new PoolItem(item))\n    }\n  }\n}\n\nexport default Pool\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type AcceptedExtensions, type Channels } from './Types'\n\n/** List of encoder formats and their settings. */\nexport class EncoderSettings {\n  /**\n     * Specifies encoded sounds extensions \"wav\" | \"mp3\" | \"ogg\" | \"mp4\" |  \"webm\" | \"opus\"\n     * */\n  format: AcceptedExtensions = 'webm'\n\n  /**\n     * Bitrate to use for specified format in kbps.\n     */\n  bitrate = 128\n\n  /**\n     * Channels to use in encoded file. 1 = mono, 2 = stereo. Will be upmixed/downmixed if source channels does not match.\n     */\n  channels: Channels = 2\n\n  constructor (props: PartialProperties<EncoderSettings> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default EncoderSettings\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EncoderSettings } from './EncoderSettings'\n\n/** Presets for encoder representing how to encode the sound files. */\nexport class EncoderPreset {\n  /** Presets formats ID */\n  id = ''\n\n  /**\n     * List of encoder formats and their settings\n     * */\n  formats: EncoderSettings[] = []\n\n  constructor (props: DeepPartialProperties<EncoderPreset> = {}) {\n    Object.assign(this, props)\n    if (props.formats != null) {\n      this.formats = props.formats.map((format) => new EncoderSettings(format))\n    }\n  }\n}\n\nexport default EncoderPreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EncoderPreset } from './EncoderPreset'\n\n/** Stores encoder formats and their settings. */\nexport class FormatPreset {\n  /** Package Identifier */\n  package = 'default'\n\n  /** Encoder presets */\n  presets: EncoderPreset[] = []\n\n  constructor (props: DeepPartialProperties<FormatPreset> = {}) {\n    Object.assign(this, props)\n    if (props.presets != null) {\n      this.presets = props.presets.map((preset) => new EncoderPreset(preset))\n    }\n  }\n}\n\nexport default FormatPreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { FormatPreset } from './FormatPreset'\nimport { type QuantizeType, type TimeSignature } from './Types'\n\nexport class Settings {\n  /**\n     * Path to directories where to find the source audio files for encoding.\n     * */\n  sourcePaths: string[] = []\n\n  /**\n     * Path to directory in which to write encoded files.\n     * */\n  targetPath = 'sounds'\n\n  /**\n     * Path to directory from which to load encoded files from during runtime.\n     */\n  loadPath = 'sounds'\n\n  /**\n     * Presets for Encoder.\n     */\n  formatPresets: FormatPreset[]\n\n  /**\n     * Global tempo used for tempo sync. Will be overridden if specified in pattern.\n     */\n  tempo = 120\n\n  /** Global resolution used for quantized events.\n     * Can either be whole number for bars, or fraction for quarter note, eigth or 16th.\n     * Default if not specified is 1 bar.\n     * Will be overridden if specified in pattern.\n     * */\n  triggerQuantize: QuantizeType = 1\n\n  /** Is not actually implemented in ECAS so does absolutely nothing. */\n  patternQuantize: QuantizeType = 1\n\n  /** Global time signature.\n     * For example \"4/4\" or \"3/4\".\n     * Default if not specified is \"4/4\".\n     * Will be overridden if specified in pattern.\n     */\n  timeSignature: TimeSignature = '4/4'\n\n  constructor (props: DeepPartialProperties<Settings> = {}) {\n    Object.assign(this, props)\n    if (props.formatPresets != null) {\n      this.formatPresets = props.formatPresets.map((preset) => new FormatPreset(preset))\n    } else {\n      this.formatPresets = createDefaultFormatPresets()\n    }\n  }\n}\n\nfunction createDefaultFormatPresets (): FormatPreset[] {\n  return [\n    new FormatPreset({\n      package: 'desktop',\n      presets: [{\n        id: 'mainFormat',\n        formats: [\n          { format: 'webm', bitrate: 112, channels: 2 },\n          { format: 'mp4', bitrate: 112, channels: 2 }\n        ]\n      }, {\n        id: 'effectsFormat',\n        formats: [\n          { format: 'webm', bitrate: 112, channels: 2 },\n          { format: 'mp4', bitrate: 112, channels: 2 }\n        ]\n      }\n      ]\n    }),\n    new FormatPreset({\n      package: 'mobile',\n      presets: [\n        {\n          id: 'mainFormat',\n          formats: [\n            { format: 'webm', bitrate: 64, channels: 1 },\n            { format: 'mp4', bitrate: 64, channels: 1 }\n          ]\n        },\n        {\n          id: 'effectsFormat',\n          formats: [\n            { format: 'webm', bitrate: 64, channels: 1 },\n            { format: 'mp4', bitrate: 64, channels: 1 }\n          ]\n        }\n      ]\n    })\n  ]\n}\n\nexport default Settings\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\n/**\n * Sound Specific Encoding settings.\n * Probably mostly usefull if you want to automatically speed up sound in encoding.\n **/\nexport class SoundEncoding {\n  /**\n     * Ratio at which to speed up / down the sound, 1 will be no change, 0.5 half, 2 double etc...\n     **/\n  speed = 1\n\n  /**\n     * If you want to pitch the sound during encoding\n     **/\n  pitch = 1\n\n  /**\n     * You can specify target sample rate, otherwise will use same as sound input sample rate\n     **/\n  //     sampleRate = 48000\n\n  constructor (props: PartialProperties<SoundEncoding> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default SoundEncoding\n", "import { type DeepPartialProperties, type ITypeNamed } from '@netent-tech/ecas-utils'\nimport SoundEncoding from './SoundEncoding'\nimport { type BufferOrElementOrSynthesizedType, type PanType, type PitchType, type VolumeType } from './Types'\n\nconst TYPENAME = 'sound' as const\n/** Configured sound for encoding and playback. */\nexport class Sound implements ITypeNamed<typeof TYPENAME> {\n  static typename = TYPENAME\n  typename = TYPENAME\n\n  /** Sound ID.\n     * Should correspond to filename of source file, minus extension.\n     **/\n  id = ''\n\n  /**\n     * ID of the group that this sound should be associated with.\n     * Will determine encoding settings and what bus sound is routed through.\n     **/\n  group = 'mainGroup'\n\n  /**\n     * Type can be either 'buffer' or 'element' and defaults to buffer.\n     * A buffer sound will loop without a gap and trigger with minimal latency, but will be decoded to 32bit PCM in advanced resulting in high memory consumption.\n     * Use 'element' where applicable to preserve memory.\n     **/\n  type: BufferOrElementOrSynthesizedType = 'buffer'\n\n  /**\n     * Duration in milliseconds in which triggering of sound should be blocked after previous trigger.\n     **/\n  triggerLimit = 0\n\n  /**\n     * Requested\n     * limit:\n     * crossfade:\n     */\n\n  /**\n     * Pitch offset for sounds in cents.\n     * Affects the AudioBufferSource Detune Parameter which is a k-rate AudioParam representing detuning of playback in cents.\n     * This value is compounded with playbackRate to determine the speed at which the sound is played.\n     * Its default value is 0 (meaning no detuning), and its nominal range is -\u221E to \u221E.\n     **/\n  pitch: PitchType = 0\n\n  /**\n     * Panning with a range of -1 to 1.\n     * The pan property of the StereoPannerNode interface is an a-rate AudioParam representing the amount of panning to apply.\n     * The value can range between -1 (full left pan) and 1 (full right pan).\n     **/\n  pan: PanType = 0\n\n  /**\n     * Sound Playback Volume from 0 to 1. Todo: make it possible to set in dBFS.\n     **/\n  volume: VolumeType = 1\n\n  /**\n     * Sound Specific Encoding settings.\n     * Probably mostly usefull if you want to automatically speed sound in encoding.\n     **/\n  encoding: SoundEncoding = new SoundEncoding()\n\n  constructor (props: DeepPartialProperties<Sound> = {}) {\n    Object.assign(this, props)\n    if (props.encoding != null) {\n      this.encoding = new SoundEncoding(props.encoding)\n    }\n  }\n}\n\nexport default Sound\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport BusConfig from './BusConfig'\nimport Group from './Group'\nimport PatternWrapper from './Patterns'\nimport Pool from './Pool'\nimport Settings from './Settings'\nimport Sound from './Sound'\n\nexport class SoundConfig {\n  /** Global Settings */\n  settings: Settings = new Settings()\n  buses: BusConfig[] = []\n\n  /** List of configured groups. */\n  groups: Group[] = []\n  sounds: Sound[] = []\n  patterns: PatternWrapper[] = []\n\n  /**\n    * List of configured pools. A sound pool will play different sound on each trigger.\n    **/\n  pools: Pool[] = []\n\n  constructor (props: DeepPartialProperties<SoundConfig> = {}) {\n    this.settings = new Settings(props.settings)\n    this.buses = props.buses?.map((bus) => new BusConfig(bus)) ?? []\n    this.groups = props.groups?.map((group) => new Group(group)) ?? []\n    this.sounds = props.sounds?.map((sound) => new Sound(sound)) ?? []\n    this.patterns = props.patterns?.map((pattern) => new PatternWrapper(pattern)) ?? []\n    this.pools = props.pools?.map((pool) => new Pool(pool)) ?? []\n  }\n}\nexport default SoundConfig\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isNumeric } from '@netent-tech/ecas-utils'\n\nexport interface ITypeNamed<T extends string> {\n  typename: T\n}\n\nexport function getWetMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix >= 0.5) {\n    return 1\n  }\n  return 1 - ((0.5 - mix) * 2)\n}\n\nexport function getDryMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix <= 0.5) {\n    return 1\n  }\n  return 1 - ((mix - 0.5) * 2)\n}\n\nexport function lastElement<T> (arr: T[]): T | undefined {\n  return arr.at(-1)\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\n\nexport interface SoundHandler {\n  dispose: () => void\n  details: Map<string, any>\n  getSound: (id: string) => any\n  getDurationSeconds: (id: string) => number\n  getAudioBuffer: (id: string) => Promise<AudioBuffer>\n  getAudioBufferSync: (id: string) => AudioBuffer\n  getAudioBufferReversed: (id: string) => Promise<AudioBuffer>\n  // eslint-disable-next-line\n    load: (ids: string[]) => Promise<void[]>\n  loadAll: () => Promise<void>\n  getAllSoundIds: () => string[]\n  isLoaded: (id: string) => boolean\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable { // implements ConvolverNode {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'AlgorithmicReverbInsert' as const\n/**\n * AlgorithmicReverb class is responsible to generate reverb nodes based on configuration given\n */\nexport class AlgorithmicReverbInsert implements InsertApi<AlgorithmicReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): AlgorithmicReverbInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options for algorithmic reverb\n     */\n  private readonly options: Required<AlgorithmicReverbInsertOptions>\n  /**\n     * Input node for algorithmic reverb\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node for algorithmic reverb\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node for algorithmic reverb\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node for algorithmic reverb\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Convolver node for algorithmic reverb\n     */\n  private reverbNode: ConvolverNode\n  /**\n     * Audio context for algorithmic reverb\n     */\n  private readonly audioContext: AudioContext\n\n  /**\n   * Creates an instance of algorithmic reverb.\n   * @param audioContext\n   * @param options\n   */\n  constructor (audioContext: AudioContext, options: AlgorithmicReverbInsertOptions = { id: TYPENAME }) {\n    this.options = {\n      id: options.id,\n      mix: 1,\n      time: 0.2,\n      decay: 0.2,\n      reverse: false\n    }\n\n    this.audioContext = audioContext\n\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.reverbNode = audioContext.createConvolver()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.dryGainNode)\n    this.dryGainNode.connect(this.outputGainNode)\n    this.inputGainNode.connect(this.reverbNode)\n    this.reverbNode.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.modify({ ...this.options, ...options }).catch(logger().error)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain, options.mix)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  async modify (options: PartialProperties<AlgorithmicReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let smoothingTimeSeconds = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      smoothingTimeSeconds = true\n    }\n\n    if (options.time !== undefined && this.options.time !== options.time) {\n      const MAX_TIME = 10 as const\n      // large impulses are costly\n      this.options.time = clamp(options.time, MIN, MAX_TIME)\n      smoothingTimeSeconds = true\n    }\n    // no need to rebuild if no change since previous update\n    if (options.decay !== undefined && this.options.decay !== options.decay) {\n      smoothingTimeSeconds = true\n      this.options.decay = Math.min(\n        Math.max(options.decay, MIN),\n        this.options.time\n      )\n    }\n\n    if (smoothingTimeSeconds) {\n      this.buildImpulse()\n    }\n  }\n\n  buildImpulse (): void {\n    const length = this.audioContext.sampleRate * this.options.time\n    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate)\n    const impulseL = impulse.getChannelData(0)\n    const impulseR = impulse.getChannelData(1)\n\n    let n: number\n    let i: number\n\n    for (i = 0; i < length; i++) {\n      n = this.options.reverse ? length - i : i\n      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n    }\n\n    if (this.reverbNode.buffer != null) {\n      this.inputGainNode.disconnect(this.reverbNode)\n      this.reverbNode.disconnect(this.wetGainNode)\n\n      this.reverbNode = this.audioContext.createConvolver()\n      this.inputGainNode.connect(this.reverbNode)\n      this.reverbNode.connect(this.wetGainNode)\n    }\n\n    this.reverbNode.buffer = impulse\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { FILTER_TYPES } from '../utils'\nimport { type InsertApi } from './types'\n\n/**\n * Uses BiquadFilterNode\n * see https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n **/\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport default BiquadFilterInsertOptions\n\n/** Converted to not extend BiquadFilterNode cause doesn't work on old browsers */\nconst TYPENAME = 'BiquadFilterInsert' as const\nexport class BiquadFilterInsert implements InsertApi<BiquadFilterInsert> {\n  static typename = TYPENAME\n  typename = BiquadFilterInsert.typename\n  id: string = TYPENAME\n  automator = new Automator(['frequency', 'detune', 'Q', 'gain'] as const)\n\n  private readonly options: BiquadFilterInsertOptions\n\n  node: BiquadFilterNode\n\n  constructor (context: BaseAudioContext, options: BiquadFilterInsertOptions) {\n    // will set the parameters to any options provided so no need to run modify in constructor\n    this.node = context.createBiquadFilter()\n    this.id = options.id\n    // any options provided overrides default\n    this.options = Object.assign({\n      id: options.id,\n      detune: 0,\n      frequency: context.sampleRate / 2,\n      gain: 0,\n      Q: 1,\n      type: 'lowpass'\n    }, options)\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.Q.value = this.options.Q!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.detune.value = this.options.detune!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.frequency.value = this.options.frequency!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.gain.value = this.options.gain!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.type = this.options.type!\n\n    this.automator.add('Q', this.node.Q)\n    this.automator.add('detune', this.node.detune)\n    this.automator.add('frequency', this.node.frequency)\n    this.automator.add('gain', this.node.gain)\n  }\n\n  get input (): BiquadFilterNode {\n    return this.node\n  }\n\n  get output (): BiquadFilterNode {\n    return this.node\n  }\n\n  get getOptions (): BiquadFilterInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the filter options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     */\n  async modify (\n    options: BiquadFilterInsertOptions,\n    endTimeSeconds: number,\n    sampleRate: number\n  ): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/Q\n         *\n         * The Q property of the BiquadFilterNode interface is an a-rate AudioParam, a double representing a Q factor, or quality factor.\n         * It is a dimensionless value with a default value of 1 and a nominal range of 0.0001 to 1000.\n         */\n    if (typeof options.Q === 'number') {\n      const MIN_Q = 0.0001 as const\n      const MAX_Q = 1000 as const\n      this.options.Q = clamp(options.Q, MIN_Q, MAX_Q)\n      this.node.Q.cancelScheduledValues(0)\n      this.node.Q.linearRampToValueAtTime(this.options.Q, endTimeSeconds)\n    }\n\n    /**\n         * Detune is basically the same as using frequency\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/detune\n         * https://webaudio.github.io/web-audio-api/dom-audiobuffersourcenode-detune\n         *\n         * The detune property of the BiquadFilterNode interface is an a-rate AudioParam representing detuning of the frequency in cents.\n         * For many AudioParams the minValue and maxValue is intended to be set to the maximum possible range.\n         * In this case, maxValue should be set to the most-positive-single-float value, which is 3.4028235e38.\n         * (However, in JavaScript which only supports IEEE-754 double precision float values,\n         * this must be written as 3.4028234663852886e38.)\n         * Similarly, minValue should be set to the most-negative-single-float value,\n         * which is the negative of the most-positive-single-float: -3.4028235e38.\n         * (Similarly, this must be written in JavaScript as -3.4028234663852886e38.)\n         */\n    if (typeof options.detune === 'number') {\n      const MOST_POSITIVE_SINGLE_FLOAT_VALUE = 3.4028234663852886e38 as const\n      const MOST_NEGATIVE_SINGLE_FLOAT_VALUE = -3.4028234663852886e38 as const\n      this.options.detune = clamp(\n        options.detune,\n        MOST_NEGATIVE_SINGLE_FLOAT_VALUE,\n        MOST_POSITIVE_SINGLE_FLOAT_VALUE\n      )\n      this.node.detune.cancelScheduledValues(0)\n      this.node.detune.linearRampToValueAtTime(\n        this.options.detune,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The frequency property of the BiquadFilterNode interface is an a-rate AudioParam\n         *  \u2014 a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n         * Its default value is 350, with a nominal range of 10 to the Nyquist frequency \u2014 that is, half of the sample rate.\n         */\n    if (typeof options.frequency === 'number') {\n      const minFrequency = 10 as const\n      const maxFrequency = sampleRate / 2\n      this.options.frequency = clamp(options.frequency, minFrequency, maxFrequency)\n      this.node.frequency.cancelScheduledValues(0)\n      this.node.frequency.exponentialRampToValueAtTime(\n        this.options.frequency,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The gain property of the BiquadFilterNode interface is an a-rate AudioParam\n         *    \u2014 a double representing the gain used in the current filtering algorithm.\n         * When its value is positive, it represents a real gain; when negative, it represents an attenuation.\n         *  It is expressed in dB, has a default value of 0, and can take a value in a nominal range of -40 to 40.\n         */\n    if (typeof options.gain === 'number') {\n      const maxGainDecibel = 40 as const\n      const minGainDecibel = -40 as const\n      this.options.gain = clamp(\n        options.gain,\n        minGainDecibel,\n        maxGainDecibel\n      )\n      this.node.gain.cancelScheduledValues(0)\n      this.node.gain.linearRampToValueAtTime(\n        this.options.gain,\n        endTimeSeconds\n      )\n    }\n\n    if (options.type !== undefined && options.type !== null && FILTER_TYPES.includes(options.type)) {\n      this.node.type = this.options.type = options.type\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.node.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, Exists, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type SoundHandler } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface ConvolverReverbInsertOptions extends Identifiable { //, Omit<ConvolverOptions, keyof AudioNode> {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: string\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'ReverbConvolverInsert' as const\n/**\n * ReverbConvolver class is responsible to generate a reverb node based on configuration given\n */\nexport class ConvolverReverbInsert implements InsertApi<ConvolverReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): ConvolverReverbInsertOptions {\n    return this.options\n  }\n\n  get audioParams (): { dryGain: AudioParam, wetGain: AudioParam } {\n    return { dryGain: this.dryGainNode.gain, wetGain: this.wetGainNode.gain }\n  }\n\n  private readonly soundHandler: SoundHandler // to fetch buffers for the impulses\n\n  /**\n     * Options of ConvolverNode\n     */\n  private readonly options: Required<ConvolverReverbInsertOptions> = {\n    id: TYPENAME,\n    normalize: false,\n    reverse: false,\n    impulseResponse: 'none', // updated in .modify\n    mix: 1\n  } as const\n\n  /**\n     * Input node of ConvolverNode\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ConvolverNode\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ConvolverNode\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ConvolverNode\n     */\n  private readonly wetGainNode: GainNode\n\n  /**\n     * convolver node of ConvolverNode\n     */\n  private readonly convolverNode: ConvolverNode\n\n  /**\n     * Creates an instance of Reverb Convolver node.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: ConvolverReverbInsertOptions, soundHandler: SoundHandler) {\n    this.soundHandler = soundHandler\n    this.inputGainNode = audioContext.createGain()\n    this.convolverNode = audioContext.createConvolver()\n    this.outputGainNode = audioContext.createGain()\n\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.convolverNode)\n\n    this.convolverNode.connect(this.wetGainNode)\n    this.inputGainNode.connect(this.dryGainNode)\n\n    this.dryGainNode.connect(this.outputGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n\n    this.id = options.id\n    if (options.impulseResponse === undefined) {\n      logger().warn('[ecas] convolver reverb impulse file should be specified.')\n      return\n    }\n    this.modify(options).catch(logger().error)\n  }\n\n  async modify (options: PartialProperties<ConvolverReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let shouldUpdateBuffer = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n\n    if (options.normalize !== undefined && this.options.normalize !== options.normalize) {\n      this.options.normalize = options.normalize\n      this.convolverNode.normalize = this.options.normalize\n      shouldUpdateBuffer = true\n    }\n\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      shouldUpdateBuffer = true\n    }\n\n    // no need to rebuild if no change since previous update\n    if (options.impulseResponse !== undefined && this.options.impulseResponse !== options.impulseResponse) {\n      shouldUpdateBuffer = true\n      this.options.impulseResponse = options.impulseResponse\n    }\n\n    if (shouldUpdateBuffer) {\n      await this.updateBuffer()\n    }\n  }\n\n  async updateBuffer (): Promise<void> {\n    const bufferPromise = this.options.reverse\n      ? this.soundHandler.getAudioBufferReversed(this.options.impulseResponse)\n      : this.soundHandler.getAudioBuffer(this.options.impulseResponse)\n\n    this.convolverNode.buffer = Exists(await bufferPromise)\n  }\n}\n", "\nimport { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, max, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nconst TYPENAME = 'DelayInsert' as const\n/**\n * Delay class is responsible to generate a delay node based on configuration given\n */\nexport class DelayInsert implements InsertApi<DelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  automator = new Automator(['delayTime', 'feedback', 'dry-gain', 'wet-gain', 'cutoff'] as const)\n\n  get id (): string {\n    return this.options.id\n  }\n\n  set id (newId: string) {\n    this.options.id = newId\n  }\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): DelayInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of delay\n     */\n  private readonly options: Required<DelayInsertOptions>\n  /**\n     * Input node of delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of delay\n     */\n  private readonly delayNode: DelayNode\n\n  private readonly filterNode: BiquadFilterNode\n\n  /**\n     * Creates an instance of delay.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: DelayInsertOptions = { id: 'delay' }) {\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n    this.feedbackGainNode = audioContext.createGain()\n    this.filterNode = audioContext.createBiquadFilter()\n    this.filterNode.type = 'lowpass'\n    this.delayNode = audioContext.createDelay(options.maxDelayTime !== undefined ? options.maxDelayTime : 1)\n\n    // final graph\n    // input->dry->output\n    // input->delay->feedback\n    //        feedback->delay\n    //        delay->wet->output\n    this.inputGainNode\n      .connect(this.dryGainNode)\n      .connect(this.outputGainNode)\n\n    this.inputGainNode\n      .connect(this.delayNode)\n      .connect(this.wetGainNode)\n      .connect(this.outputGainNode)\n\n    this.delayNode\n      .connect(this.feedbackGainNode)\n      .connect(this.filterNode)\n      .connect(this.delayNode)\n\n    this.options = {\n      id: options.id,\n      feedback: 0.1,\n      mix: 1,\n      delayTime: 0.3,\n      maxDelayTime: 1,\n      cutoff: 20000\n    }\n\n    this.modify(Object.assign(this.options, options)).catch(logger().error)\n\n    this.automator.add('cutoff', this.filterNode.frequency)\n    this.automator.add('delayTime', this.delayNode.delayTime)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  public async modify (options: PartialProperties<DelayInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const GAIN_MIN = 0.0001 as const\n\n    if (options.delayTime !== undefined) {\n      this.options.delayTime = clamp(options.delayTime, 0, this.options.maxDelayTime)\n\n      this.delayNode.delayTime.cancelScheduledValues(0)\n      this.delayNode.delayTime.linearRampToValueAtTime(this.options.delayTime, endTimeSeconds)\n    }\n    if (options.feedback !== undefined) {\n      this.options.feedback = clamp(options.feedback, GAIN_MIN, 1)\n\n      this.feedbackGainNode.gain.cancelScheduledValues(0)\n      this.feedbackGainNode.gain.exponentialRampToValueAtTime(this.options.feedback, endTimeSeconds)\n    }\n    if ((options.maxDelayTime !== undefined)) {\n      this.options.maxDelayTime = clamp(options.maxDelayTime, 0, 10)\n    }\n    if ((options.mix !== undefined)) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, GAIN_MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(clamp(1 - this.options.mix, GAIN_MIN, MIX_MAX), endTimeSeconds)\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(this.options.mix, endTimeSeconds)\n    }\n    if ((options.id !== undefined)) {\n      this.options.id = options.id\n    }\n\n    if ((options.cutoff !== undefined)) {\n      this.options.cutoff = clamp(options.cutoff, 10, 20000)\n      this.filterNode.frequency.exponentialRampToValueAtTime(this.options.cutoff, endTimeSeconds)\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.outputGainNode.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nconst TYPENAME = 'DynamicsCompressorInsert' as const\nexport class DynamicsCompressorInsert implements InsertApi<DynamicsCompressorInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  private readonly options: DynamicsCompressorInsertOptions\n  automator = new Automator(['threshold', 'ratio', 'attack', 'release', 'knee'] as const)\n  node: DynamicsCompressorNode\n  context: BaseAudioContext\n\n  constructor (context: BaseAudioContext, options: DynamicsCompressorInsertOptions) {\n    this.context = context\n    this.id = options.id\n    this.options = { ...options }\n    this.node = context.createDynamicsCompressor()\n    this.automator.add('threshold', this.threshold)\n    this.automator.add('ratio', this.ratio)\n    this.automator.add('attack', this.attack)\n    this.automator.add('release', this.release)\n    this.automator.add('knee', this.knee)\n    void this.modify(options, 0)\n  }\n\n  get attack (): AudioParam {\n    return this.node.attack\n  }\n\n  get knee (): AudioParam {\n    return this.node.knee\n  }\n\n  get ratio (): AudioParam {\n    return this.node.ratio\n  }\n\n  get release (): AudioParam {\n    return this.node.release\n  }\n\n  get threshold (): AudioParam {\n    return this.node.threshold\n  }\n\n  get input (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get output (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get getOptions (): DynamicsCompressorInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the compressor options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     * @param node\n     * @param options -\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * @param endTime\n     * @param sampleRate\n     */\n  async modify (options: DynamicsCompressorInsertOptions, endTime: number): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode/attack\n         * The attack property's default value is 0.003 and it can be set between 0 and 1\n         */\n    if (typeof options.attack === 'number') {\n      const MIN_ATTACK = 0 as const\n      const MAX_ATTACK = 1 as const\n      this.attack.cancelScheduledValues(0)\n      this.attack.linearRampToValueAtTime(\n        clamp(\n          options.attack,\n          MIN_ATTACK,\n          MAX_ATTACK\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The knee property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam containing a decibel value\n         * representing the range above the threshold where\n         * the curve smoothly transitions to the compressed portion\n         * The knee property's default value is 30 and it can be set between 0 and 40\n         */\n    if (typeof options.knee === 'number') {\n      const MIN_KNEE = 0 as const\n      const MAX_KNEE = 40 as const\n      this.knee.cancelScheduledValues(0)\n      this.knee.linearRampToValueAtTime(\n        clamp(\n          options.knee,\n          MIN_KNEE,\n          MAX_KNEE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The ratio property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n         * The ratio property's default value is 12 and it can be set between 1 and 20.\n         */\n    if (typeof options.ratio === 'number') {\n      const MIN_RATIO = 1 as const\n      const MAX_RATIO = 20 as const\n      this.ratio.cancelScheduledValues(0)\n      this.ratio.linearRampToValueAtTime(\n        clamp(\n          options.ratio,\n          MIN_RATIO,\n          MAX_RATIO\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The release property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of time, in seconds,\n         * required to increase the gain by 10 dB.\n         * It defines how quick the signal is adapted when its volume is reduced.\n         * The release property's default value is 0.25 and it can be set between 0 and 1.\n         */\n    if (typeof options.release === 'number') {\n      const MAX_RELEASE = 1 as const\n      const MIN_RELEASE = 0 as const\n      this.release.cancelScheduledValues(0)\n      this.release.exponentialRampToValueAtTime(\n        clamp(\n          options.release,\n          MIN_RELEASE,\n          MAX_RELEASE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The threshold property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n         * The threshold property's default value is -24 and it can be set between -100 and 0.\n         */\n    if (typeof options.threshold === 'number') {\n      const MIN_THRESHOLD = -100 as const\n      const MAX_THRESHOLD = 0 as const\n      this.threshold.cancelScheduledValues(0)\n      this.threshold.linearRampToValueAtTime(\n        clamp(\n          options.threshold,\n          MIN_THRESHOLD,\n          MAX_THRESHOLD\n        ),\n        endTime\n      )\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTime - this.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { type Identifiable } from '@netent-tech/ecas-utils'\nimport { getDryMixValue, getWetMixValue } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport default PingPongInsertOptions\n\nconst TYPENAME = 'PingPongDelayInsert' as const\n/**\n * PingPongDelay class is responsible to generate a ping pong delay nodes based on configuration given\n */\nexport class PingPongDelayInsert implements InsertApi<PingPongDelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain', 'delay-time-left', 'delay-time-right', 'feedback'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  /** Todo: implement */\n  async modify (): Promise<void> {\n    await Promise.resolve<undefined>(undefined)\n  }\n\n  get getOptions (): PingPongInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of ping pong delay\n     */\n  private readonly options: Required<PingPongInsertOptions>\n  /**\n     * Input node of ping pong  delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ping pong  delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ping pong delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ping pong delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of ping pong delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of ping pong delay\n     */\n  private readonly delayNodeLeft: DelayNode\n  /**\n     * Delay node right of ping pong delay\n     */\n  private readonly delayNodeRight: DelayNode\n  /**\n     * Channel merger of ping pong delay\n     */\n  private readonly channelMerger: ChannelMergerNode\n\n  /**\n     * Creates an instance of ping pong delay.\n     * @param ecasContext\n     * @param options\n     */\n  constructor (ecasContext: AudioContext, options: PingPongInsertOptions = { id: TYPENAME }) {\n    this.options = Object.assign({\n      feedback: 0.5,\n      mix: 0.5,\n      delayTime: 0.3,\n      maxDelayTime: 1\n    }, options)\n\n    this.maxDelayTime = options.maxDelayTime !== undefined ? options.maxDelayTime : 1\n\n    this.inputGainNode = ecasContext.createGain()\n    this.outputGainNode = ecasContext.createGain()\n    this.dryGainNode = ecasContext.createGain()\n    this.wetGainNode = ecasContext.createGain()\n    this.feedbackGainNode = ecasContext.createGain()\n    this.delayNodeLeft = ecasContext.createDelay(this.maxDelayTime)\n    this.delayNodeRight = ecasContext.createDelay(this.maxDelayTime)\n    this.channelMerger = ecasContext.createChannelMerger(2)\n\n    // dry mix\n    this.inputGainNode.connect(this.dryGainNode)\n    // dry out\n    this.dryGainNode.connect(this.outputGainNode)\n\n    // feedback loop\n    this.delayNodeLeft.connect(this.channelMerger, 0, 0)\n    this.delayNodeRight.connect(this.channelMerger, 0, 1)\n    this.delayNodeLeft.connect(this.delayNodeRight)\n    this.feedbackGainNode.connect(this.delayNodeLeft)\n    this.delayNodeRight.connect(this.feedbackGainNode)\n\n    // wet mix\n    this.inputGainNode.connect(this.feedbackGainNode)\n    // wet out\n    this.channelMerger.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.id = options.id\n\n    this.automator.add('delay-time-left', this.delayNodeLeft.delayTime)\n    this.automator.add('delay-time-right', this.delayNodeRight.delayTime)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n  }\n\n  public get mix (): number {\n    return this.options.mix\n  }\n\n  public set mix (mix: number) {\n    this.options.mix = mix\n    this.dryGainNode.gain.value = getDryMixValue(this.mix)\n    this.wetGainNode.gain.value = getWetMixValue(this.mix)\n  }\n\n  public get feedback (): number {\n    return this.options.feedback\n  }\n\n  public set feedback (feedback: number) {\n    if (feedback < 0 || feedback > 1) {\n      return\n    }\n    this.options.feedback = feedback\n    this.feedbackGainNode.gain.value = this.feedback\n  }\n\n  public get delayTime (): number {\n    return this.options.delayTime\n  }\n\n  public set delayTime (time: number) {\n    if (time < 0 || time > this.maxDelayTime) {\n      return\n    }\n    this.options.delayTime = time\n    this.delayNodeLeft.delayTime.value = this.delayTime\n    this.delayNodeRight.delayTime.value = this.delayTime\n  }\n\n  public get maxDelayTime (): number {\n    return this.options.maxDelayTime\n  }\n\n  public set maxDelayTime (maxDelay) {\n    this.options.maxDelayTime = maxDelay\n  }\n\n  public getPingPongDelayNodes (param: string): GainNode | DelayNode[] {\n    if (param === 'feedback') {\n      return this.feedbackGainNode\n    }\n    return [\n      this.delayNodeLeft,\n      this.delayNodeRight\n    ]\n  }\n\n  public getGeneratedGraph (): { leftNode: GainNode, rightNode: GainNode } {\n    return {\n      leftNode: this.inputGainNode,\n      rightNode: this.outputGainNode\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { InsertHandlerError, type SoundHandler } from '../utils'\nimport { AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { BiquadFilterInsert } from './BiquadFilterInsert'\nimport { ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { DelayInsert } from './DelayInsert'\nimport { DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { PingPongDelayInsert } from './PingPongDelayInsert'\nimport { type InsertClass, type InsertOptions, type InsertTypenames } from './types'\n\nexport function createInsert<T extends InsertTypenames> (\n  audioContext: AudioContext,\n  soundHandler: SoundHandler,\n  typename: T,\n  options: InsertOptions<T>\n): InsertClass<T> {\n  logger().debug('createInsert;', typename)\n  switch (typename) {\n    case BiquadFilterInsert.typename: {\n      return new BiquadFilterInsert(audioContext, options as BiquadFilterInsert['options']) as InsertClass<T>\n    }\n    case DynamicsCompressorInsert.typename: {\n      return new DynamicsCompressorInsert(audioContext, options as DynamicsCompressorInsert['options']) as InsertClass<T>\n    }\n    case DelayInsert.typename: {\n      return new DelayInsert(audioContext, options as DelayInsert['options']) as InsertClass<T>\n    }\n    case AlgorithmicReverbInsert.typename: {\n      return new AlgorithmicReverbInsert(audioContext, options as AlgorithmicReverbInsert['options']) as InsertClass<T>\n    }\n    case ConvolverReverbInsert.typename: {\n      return new ConvolverReverbInsert(audioContext, options as ConvolverReverbInsert['options'], soundHandler) as InsertClass<T>\n    }\n    case PingPongDelayInsert.typename: {\n      return new PingPongDelayInsert(audioContext, options as PingPongDelayInsert['options']) as InsertClass<T>\n    }\n    default: {\n      throw new InsertHandlerError(`create insert failed to create any insert for, ${typename as string}`)\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { createInsert, type InsertAny, type InsertClass, type InsertOptions, type InsertTypenames } from '.'\nimport { InsertHandlerError, lastElement, type SoundHandler } from '../utils'\n\nexport class InsertHandler implements Disposable {\n  private readonly insertMap = new Map<InsertAny['id'], Readonly<InsertAny>>()\n  private inserts: Array<Readonly<InsertAny>>\n  private readonly audioContext: AudioContext\n  private readonly soundHandler: SoundHandler\n  private readonly source: AudioNode\n  private readonly destination: AudioNode\n\n  constructor (audioContext: AudioContext, soundHandler: SoundHandler, source: AudioNode, destination: AudioNode) {\n    this.audioContext = audioContext\n    this.soundHandler = soundHandler\n    this.source = source\n    this.destination = destination\n    this.inserts = []\n  }\n\n  create<T extends InsertTypenames>(typename: T, options: InsertOptions<T>): void {\n    logger().debug('[ecas] insert.create', typename)\n    const insert = createInsert(\n      this.audioContext,\n      this.soundHandler,\n      typename,\n      options\n    )\n    this.add(insert)\n  }\n\n  add<T extends InsertTypenames>(insert: Readonly<InsertClass<T>>): void {\n    logger().debug('[ecas] insert.add')\n    const last = lastElement(this.inserts)\n\n    if (last != null) {\n      last.output.disconnect(this.destination)\n      last.output.connect(insert.input)\n    } else {\n      this.source.disconnect(this.destination)\n      this.source.connect(insert.input)\n    }\n\n    insert.output.connect(this.destination)\n\n    this.inserts.push(insert)\n    this.insertMap.set(insert.id, insert)\n  }\n\n  remove (id: string): void {\n    logger().debug('[ecas] insert.remove', id)\n    const newInserts: Array<Readonly<InsertAny>> = []\n    for (const [index, insert] of this.inserts.entries()) {\n      if (insert.id === id) {\n        const next = this.inserts[index + 1]?.input ?? this.destination\n        const prev = this.inserts[index - 1]?.output ?? this.source\n        prev.disconnect()\n        insert.output.disconnect()\n        prev.connect(next)\n      } else {\n        newInserts.push(insert)\n      }\n    }\n    this.inserts = newInserts\n    this.insertMap.delete(id)\n  }\n\n  get<T extends InsertTypenames>(id: string): InsertClass<T> {\n    if (!this.insertMap.has(id)) {\n      throw new InsertHandlerError(`[ecas] cannot get insert: ${id} since it does not exist`)\n    }\n    return this.insertMap.get(id) as InsertClass<T>\n  }\n\n  logInserts (): void {\n    logger().log(this.inserts)\n  }\n\n  has (id?: string): boolean {\n    return typeof id === 'string'\n      ? this.insertMap.has(id)\n      : isArrayEmpty(this.inserts)\n  }\n\n  dispose (): void {\n    for (const id of this.insertMap.keys()) {\n      this.insertMap.delete(id)\n    }\n\n    while (this.inserts.length > 0) {\n      const insert = this.inserts.pop()\n      insert?.input.disconnect()\n      insert?.output.disconnect()\n    }\n  }\n}\n", "import { type AutomatableParameters, type Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type ITypeNamed } from '../utils'\nimport { type AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { type BiquadFilterInsert } from './BiquadFilterInsert'\nimport { type ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { type DelayInsert } from './DelayInsert'\nimport { type DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { type PingPongDelayInsert } from './PingPongDelayInsert'\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { BiquadFilterInsert, DynamicsCompressorInsert, AlgorithmicReverbInsert, DelayInsert, PingPongDelayInsert, ConvolverReverbInsert } from '@netent-tech/ecas-inserts'\nimport { type Values } from '@netent-tech/ecas-utils'\n\n/** What codecs to choose when setting file extension. */\nexport const codecs = {\n  wav: 'pcm_s16le', /** 16 bit litle endian */\n  mp3: 'libmp3lame',\n  mp4: 'aac',\n  ogg: 'libopus', /** Changed from libvorbis october 2021. */\n  webm: 'libopus', /** Changed from libvorbis october 2021. Ffmpeg default audio encoder for WebM is libopus */\n  opus: 'libopus',\n  caf: 'libopus' /** Opus for safari, for some files this doesn't work unfortunately dont know why yet  */\n} as const\n\nexport const CHANNELS = [1, 2] as const\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\nexport const POOL_ITEM_TYPES = ['sound', 'pattern', 'pool'] as const\nexport const POOL_TYPES = ['random', 'sequential'] as const\nexport const ENVELOPE_PRESET_PARAM = ['volume', 'pan', 'pitch'] as const\nexport const BUFFER_ELEMENT_SYNTHESIZED = ['buffer', 'element', 'synthesized'] as const\nexport const TARGET_SAMPLE_RATE = 48000 as const\n\nexport const EFFECT_TYPES: ReadonlyArray<Values<typeof EffectTypes>> = ['reverbAlgorithmic', 'reverbConvolver', 'compressor', 'delay', 'pingPongDelay', 'filter'] as const\nexport const BUSS_SOUND = ['bus', 'sound'] as const\nexport const TARGET_TYPES = ['sound', 'bus'] as const\nexport const ENVELOPE_CURVES = ['linear', 'exponential', 'logarithmic', 's-curve'] as const\nexport const ENVELOPE_PARAMETER_TYPES = ['volume', 'pan', 'pitch', 'gain'] as const\n\nexport const EffectTypes = {\n  [AlgorithmicReverbInsert.typename]: 'reverbAlgorithmic',\n  [ConvolverReverbInsert.typename]: 'reverbConvolver',\n  [DynamicsCompressorInsert.typename]: 'compressor',\n  [DelayInsert.typename]: 'delay',\n  [PingPongDelayInsert.typename]: 'pingPongDelay',\n  [BiquadFilterInsert.typename]: 'filter'\n} as const\n\nexport type EffectIdentifiers = typeof EFFECT_TYPES[number]\nexport type EffectIdentifier<T extends EffectIdentifiers> = T // Omit<string, T>\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\nexport class PingPongDelayConfig {\n  /** The maximum amount of time, in seconds, that the audio signal can be delayed by. Must be less than 180 seconds, and defaults to 1 second if not specified. */\n  maxDelayTime = 1\n\n  /** Is an a-rate AudioParam representing the amount of delay to apply. The default delayTime is 0 seconds. */\n  delayTime = 0\n\n  /** The intensity with which the input will echo back. A larger value will result in more echo repetitions. (min: 0, max: 1, defaults to 0.5) */\n  feedback = 0.5\n\n  /** Volume balance between the original audio and the effected output (the delayed sound). (min: 0, max: 1, defaults to 0.5) */\n  mix = 0.5\n\n  constructor (props: PartialProperties<PingPongDelayConfig> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default PingPongDelayConfig\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type ZeroToOneNumber } from './ZeroToOne'\n\nexport class ConvolverReverbConfig {\n  /** Impulse sound id to generate reverb effect */\n  impulseResponse = 'default'\n\n  /** Volume balance between the original audio and the effected output. (min: 0, max: 1, defaults to 0.5) */\n  mix: ZeroToOneNumber = 0.5\n\n  /**\n     * ConvolverNode interface is a boolean that controls whether the impulse response from the buffer will be scaled\n     * by an equal-power normalization when the buffer attribute is set, or not. Default is true\n     **/\n  normalize = true\n\n  constructor (props: PartialProperties<ConvolverReverbConfig> = {}) {\n    Object.assign(this, props)\n  }\n}\n", "export function strarr (arr: unknown[], sep = ', '): string {\n  const str = arr.map(item => String(item)).join(sep)\n  return `[ ${str} ]`\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isString } from '@netent-tech/ecas-utils'\nimport { type MusicalPosition, type TimeSignature } from '../ecas-config/sound-config'\n/**\n * Check if a value is valid bar.beat.tick syntax.\n *\n * @param {ValueOrRandomOrBarBeatTick} thing Value to check.\n * @return {boolean} If value conforms to bar.beat.tick true and val is a string, else false.\n */\nexport function isMusicalPosition (thing: unknown): thing is MusicalPosition {\n  if (!isString(thing)) {\n    return false\n  }\n  const regExp = /^\\d{1,2}\\.\\d{1,2}\\.\\d{1,3}$/\n  const match = isString(thing) ? thing.match(regExp) : null\n  return match !== null\n}\n\nexport function isTimeSignature (thing: string): thing is TimeSignature {\n  const timeSignatureRegex = /\\d\\/\\d/\n  return timeSignatureRegex.test(thing)\n}\n", "\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\nexport class BusHandlerError extends Error {\n  override name = 'BusHandlerError'\n}\n\nexport class EnvelopeHandlerError extends Error {\n  override name = 'EnvelopeHandlerError'\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n", "export * from './ecas-engine-api'\nexport * from './EcasOptions'\nexport * from './ecas-config'\nexport * from './utils'\n\nexport const MASTER_BUS_ID = 'master' as const\nexport const OUTPUT_BUS_ID = 'OUTPUT' as const\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isTimeSignature, ITempoConfig, ITimeSignature, MusicalPosition, TimeSignature } from \"@netent-tech/ecas-common\"\nconst TICKS_PER_BEAT = 32 as const\n\n/**\n * Convert bar.beat.tick notation to seconds.\n *\n * @param {MusicalPosition} val Position in bar.beat.tick format to convert.\n * @param {ITempoConfig} tempoConfig Tempo settings to use in conversion.\n * @param {number} now Current time in seconds to use in conversion.\n * @private\n */\nexport function barBeatTickToSeconds(val: MusicalPosition, tempoConfig: ITempoConfig, now: number): number {\n    if (!tempoConfig || !tempoConfig.tempo) {\n        logger().warn(\"[ecas] unable to convert bar.beat.tick to time, since no tempo is configured.\")\n        return 0\n    }\n    tempoConfig.timeSignature = tempoConfig.timeSignature || {meter: 4, unit: 4}\n    tempoConfig.triggerQuantize = tempoConfig.triggerQuantize || 1\n    const parts = val.split(\".\")\n    const bars = parseInt(parts[0], 10)\n    const beats = parseInt(parts[1], 10)\n    const ticks = parseInt(parts[2], 10)\n    const signatureDenom = (1 / tempoConfig.timeSignature.unit) * 4\n    let secPerUnit\n    const secPerBeat = 60 / (tempoConfig.tempo / signatureDenom)\n    const secPerBar = secPerBeat * tempoConfig.timeSignature.meter\n    const secPerTick = secPerBeat / TICKS_PER_BEAT\n    if (tempoConfig.triggerQuantize >= 1) {\n        secPerUnit = secPerBeat * (tempoConfig.timeSignature.meter * tempoConfig.triggerQuantize)\n    }\n    else {\n        const secPerWhole = secPerBeat / (1 / tempoConfig.timeSignature.unit)\n        secPerUnit = secPerWhole * tempoConfig.triggerQuantize\n    }\n    const remainUntilQuantize = secPerUnit - ((now % secPerUnit) || secPerUnit)\n    const barsTotalSeconds = bars * secPerBar\n    const beatsTotalSeconds = beats * secPerBeat\n    const ticksTotalSeconds = ticks * secPerTick\n    return barsTotalSeconds + beatsTotalSeconds + ticksTotalSeconds + remainUntilQuantize\n}\n\n\n/**\n * Converts a string to time signature object.\n * @param {string} str Time signature expressed as a string. E.g. \\\"4/4\\\".\n * @return {ITimeSignature} Object with meter and unit properties.\n */\nexport function createTimeSignatureFromString(str: TimeSignature = \"4/4\"): ITimeSignature { //Maybe TimeSignature default should be blank?\n    if (!isTimeSignature(str)) {\n        throw new Error(`[ecas] createTimeSignatureFromString; Invalid time signature '${str}'. Please enter a string such as '4/4', '3/4' or '6/8'.`)\n    }\n    const parts = str.split(\"/\")\n    const meter = parseInt(parts[0], 10)\n    const unit = parseInt(parts[1], 10)\n    return {\n        meter,\n        unit\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { hasOwnProperty, isArray, isNumber, isNumeric, isString, isStringNumber } from \"@netent-tech/ecas-utils\"\nimport { isMusicalPosition, ITempoConfig, ValueOrRandom, ValueOrRandomOrBarBeatTick } from \"@netent-tech/ecas-common\"\nimport { barBeatTickToSeconds } from \"./beats\"\nexport class Utils {\n\n    /**\n     * Convert a pitch value in cents to playback rate\n     * @param {number} detuneInCents Pitch value in cents. Valid values between -4800 and 4800.\n     * @returns {number} Playback rate clamped between 0.0625 (1/16) and 16\n     */\n    static pitchToPlaybackRate(detuneInCents: number): number {\n        const min = -4800\n        const max = 4800\n        if (detuneInCents < min || detuneInCents > max) {\n            logger().info(`[ecas] pitch outside allowed range (${min} to ${max}), was: ${detuneInCents}, clamping.`)\n            detuneInCents = Math.min(max, Math.max(min, detuneInCents))\n        }\n        return Math.pow(2, detuneInCents / 1200)\n    }\n\n    /**\n     * Converts a string fraction to a number. For example '1/4' to 0.25\n     * @param {string} val Fraction expressed as a string.\n     * @return {number} Fraction as number.\n     */\n    static stringFractionToNumber(val: string | number): number {\n        if (isNumeric(val) || !val) {\n            return this.defaultNumber(val, 0)\n        }\n        if (isString(val)) {\n            const parts = val.split(\"/\").map((v) => parseInt(v, 10))\n            if (!parts || parts.length !== 2) {\n                throw new Error(\"[ecas] can only convert fraction in format 'n/n'. Got:\" + val)\n            }\n            return parts[0] / parts[1]\n        }\n        return 0\n    }\n\n    /**\n     * Checks if a value is numeric and if not returns default value. Also ensures\n     * it is returned as a proper number, and that bar.beat.tick notation or random values are converted.\n     *\n     * @param {ValueOrRandomOrBarBeatTick} val Suspected number, or random range array.\n     * @param {number} defaultValue Default value to use if not numeric.\n     * @param {ITempoConfig} tempoConfig Tempo information to use when converting bar.beat.tick notation.\n     * @param {number} now Current time of playback, used when converting bar.beat.tick notation.\n     * @returns {number} The checked and parsed number\n     */\n    static defaultNumber(val: ValueOrRandomOrBarBeatTick, defaultValue = 0, tempoConfig?: ITempoConfig, now = 0): number {\n        if (isNumber(val)) {\n            return val\n        }\n        if (isArray(val)) {\n            const newVal = this.randomizeValues(val)\n            if (typeof newVal === 'number') {\n                return newVal\n            }\n            logger().warn(`[ecas] provided value is an array: ${val}, but ECAS is unable to get a randomised value from it, returning ${defaultValue} instead.`)\n            return defaultValue\n        }\n        if (isMusicalPosition(val)) {\n            if (!tempoConfig) {\n                logger().warn(\"[ecas] you need to provide tempo information for conversion of bar.beat.tick notation to time.\")\n                return defaultValue\n            }\n            return barBeatTickToSeconds(val, tempoConfig, now)\n        }\n        if (isStringNumber(val)) {\n            return parseFloat(val.toString())\n        }\n        logger().log(\"[ecas] unable to set default number value, returning 0. val was:\", val)\n        return defaultValue\n    }\n\n    /**\n     * Checks if a value is undefined, null or empty string, and in that case sets it to a default value.\n     * @param {T} val any value\n     * @param {T} defaultValue default value to use if not numeric\n     * @returns {number} The checked and parsed number\n     */\n    static defaultValue<T>(val: T, defaultValue: T): T {\n        if (val === undefined || val === null || (isString(val) && val === \"\")) {\n            val = defaultValue\n        }\n        return val\n    }\n\n    /**\n     * Randomizing Value\n     * @param {RandomSet} values Passes as a range. example [[0.1, 0.3], 0.5, 0.5]\n     * would result in 66.6% chance of returning 0.5 and 33.3% chance of returning\n     * a value in between 0.1-0.3\n     * @returns {number} Random value if input was a random range, otherwise same as input\n     */\n    static randomizeValues(values: ValueOrRandom): number {\n        if (isNumber(values)) {\n            return values\n        }\n\n        let isValid = true\n        const rangeReg = /^-?\\d*\\.?\\d+,-?\\d*\\.?\\d+$/ // eslint-disable-line\n        const valueReg = /^-?\\d*\\.?\\d+$/\n        let randomVal\n        let filterArr\n\n        if (!isNumber(values) && Array.isArray(values)) {\n            if (values.length > 0) {\n                filterArr = (values as string[]).map((n) => {\n                    if (valueReg.test(n)) {\n                        return n\n                    }\n\n                    else if (isArray(n)) {\n                        return this._getRandomValue(parseFloat(n[0]), parseFloat(n[1]))\n                    }\n\n                    else if (rangeReg.test(n)) {\n                        const range = n.split(\",\")\n                        return this._getRandomValue(parseFloat(range[0]), parseFloat(range[1]))\n                    }\n\n                    else {\n                        isValid = false\n                        logger().warn(\"[ecas] invalid random value format: \" + values)\n                    }\n                    return null\n                })\n\n                if (isValid) {\n                    randomVal  = this.randomShuffle(filterArr)[0]\n                    return parseFloat(randomVal)\n                }\n            }\n            else {\n                logger().warn(\"[ecas] invalid random value: empty array\")\n            }\n        }\n        else {\n            randomVal = values\n            return randomVal\n        }\n        throw new Error(\"[ecas] randomize values should not reach this line\")\n    }\n\n    /**\n     * Shuffle the sequential array when pool type is random and ends the Q\n     * @param {T[]} array Array to shuffle\n     * @returns {T[]} Shuffled array\n     */\n    static randomShuffle<T>(array: T[]): T[] {\n        const arrayWithRandomNumbers: Array<[number, T]> = array.map((n: T) => [Math.random(), n])\n        arrayWithRandomNumbers.sort()\n        return arrayWithRandomNumbers.map((n) => n[1])\n    }\n\n    /**\n     * Sum two volume values and return a number.\n     * NOTE: When summing levels the actual operation used is multiplication.\n     * @param {ValueOrRandom} volumeA Volume value A\n     * @param {ValueOrRandom} volumeB Volume value B\n     * @returns {number} Sum of volume values\n     */\n    static sumVolume(volumeA: ValueOrRandom = 1, volumeB: ValueOrRandom = 1): number {\n        const a = this.defaultNumber(volumeA, 1)\n        const b = this.defaultNumber(volumeB, 1)\n        return a * b\n    }\n\n    /**\n     * Sum two pan values and return a number.\n     * Should mimic playing a sound with panning through a bus with panning in Web Audio API using StereoPannerNode.\n     * PanB acts as the bus, so for example if panA = 1 and panB = -1 the expected value is -1\n     *\n     * @param {ValueOrRandom} panA Pan value to use as source\n     * @param {ValueOrRandom} panB Pan value to use as bus\n     * @returns {number} Sum of pan values\n     */\n    static sumPan(panA: ValueOrRandom, panB: ValueOrRandom): number {\n        const a = Math.max(-1, Math.min(this.defaultNumber(panA), 1))\n        const b = Math.max(-1, Math.min(this.defaultNumber(panB), 1))\n        return b + ((1 - Math.abs(b)) * a)\n    }\n\n    /**\n     * Sum two pitch values and return a number.\n     * @param {ValueOrRandom} pitchA Pitch value A\n     * @param {ValueOrRandom} pitchB Pitch value B\n     * @returns {number} Sum of pitch values\n     */\n    static sumPitch(pitchA: ValueOrRandom, pitchB: ValueOrRandom): number {\n        const a = this.defaultNumber(pitchA)\n        const b = this.defaultNumber(pitchB)\n        return a + b\n    }\n\n    /**\n     * Sum two position values and return a number.\n     * @param {ValueOrRandom} posA Position value A\n     * @param {ValueOrRandom} posB Position value B\n     * @returns {number} Sum\n     */\n    static sumPos(posA: ValueOrRandom, posB: ValueOrRandom): number {\n        const a = this.defaultNumber(posA)\n        const b = this.defaultNumber(posB)\n        return a + b\n    }\n    /**\n     * Take and array with objects, and return an array where specified props are unique.\n     *\n     * @param array Array to filter.\n     * @param props Props to filter on.\n     * @return {Array} Array with only unique items.\n     */\n    static filterUnique<T>(array: T[], props: string[]): T[] | null {\n        if (array === null || array === undefined) {\n            return null\n        }\n        const unique: T[] = []\n        const matches: string[] = []\n        array.forEach((item) => {\n            let key = \"\"\n            props.forEach((prop) => {\n                if (hasOwnProperty(item, prop)) {\n                    key += item[prop]\n                }\n            })\n            if (matches.indexOf(key) === -1) {\n                unique.push(item)\n            }\n            matches.push(key)\n        })\n        return unique\n    }\n\n    static getWetMixValue(mix: number) {\n        if (!isNumeric(mix) || mix > 1 || mix < 0) {\n            return 0\n        }\n        if (mix >= 0.5) {\n            return 1\n        }\n        return 1 - ((0.5 - mix) * 2)\n    }\n\n    static getDryMixValue(mix: number) {\n        if (!isNumeric(mix) || mix > 1 || mix < 0) {\n            return 0\n        }\n        if (mix <= 0.5) {\n            return 1\n        }\n        return 1 - ((mix - 0.5) * 2)\n    }\n\n\n    /**\n     * Generate a unique identifier with or without a prefix.\n     *\n     * @param {string} prefix String to append before identifier. Automatically followed by underscore.\n     * @return {string} Universally unique identifier generated.\n     */\n    public static generateUniqueId(prefix?: string): string {\n        const time = new Date().getTime()\n        const uuidv4Format = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\"\n\n        const uniqueId = uuidv4Format.replace(\n            /[xy]/g,\n            (match) => {\n                /* tslint:disable:no-bitwise */\n                const randomDigit = time + (crypto.getRandomValues(new Uint32Array(1))[0] / 10)\n                const randomCharacter = (randomDigit + Math.random() * 16) % 16 | 0\n\n                return (match === \"x\" ? randomCharacter : (randomCharacter & 0x3 | 0x8)).toString(16)\n            }\n        )\n\n        if (prefix && prefix !== \"\" && typeof prefix === \"string\") {\n            return prefix + \"_\" + uniqueId\n        }\n        else {\n            return uniqueId\n        }\n    }\n\n    /**\n     * Get random value from two values\n     * @param {number} min lower limit\n     * @param {number} max upper limit\n     * @returns {number} random value from range\n     */\n    private static _getRandomValue(min: number, max: number) {\n        const rand = Math.random() * (max - min) + min\n        return rand.toFixed(3)\n    }\n}\n", "/**\n * Sort topologically.\n * Based on https://github.com/samuelneff/topsort/blob/master/lib/topsort.ts\n * Useful in ECAS to sort the bus graph.\n *\n * For example say you have a bus graph with \"bussA\" going into \"bussB\" going into \"master\".\n * When creating the busses, you need to have the destination bus created first to connect to it.\n * Use the following as the edges param to describe the graph:\n * [[\"bussA\", \"bussB\"], [\"master\"], [\"bussB\", \"master\"]]\n * You would then get the following return value from the topoSort:\n * [\"master\", \"bussB\", \"bussA\"]\n *\n * This function will accept input and output arrays to use any type that can be converted with toString for indexing.\n * So you can also use a numerical graph, such as [[1,2], [0], [2,0]], which would return [0,2,1] as number[]\n *\n * @param {T[][]} edges Array containing arrays with id and destination pairs, with destination being optional.\n * @return {T[]} Array with sorted ids, from bottom up.\n */\nexport function topoSort<T extends { toString: () => string }>(edges: T[][]): T[] {\n    class EdgeNode {\n        public afters:T[] = []\n        constructor(public id: T) {}\n    }\n    const nodes: {[key: string]: EdgeNode}   = {}\n    const sorted: T[]  = []\n\n    // hash: id of already visited node => true\n    const visited: {[key: string]: boolean } = {}\n\n    // 1. build data structures\n    edges.forEach((edge: T[]) => {\n\n        const fromEdge: T = edge[0]\n        const fromStr: string = fromEdge.toString()\n        let fromNode: EdgeNode = nodes[fromStr]\n        if (!fromNode) {\n            fromNode = nodes[fromStr] = new EdgeNode(fromEdge)\n        }\n        edge.forEach((toEdge: T) => {\n\n            // since from and to are in same array, we'll always see from again, so make sure we skip it..\n            if (!toEdge || toEdge === fromEdge) {\n                return\n            }\n            const toEdgeStr: string = toEdge.toString()\n\n            if (!nodes[toEdgeStr]) {\n                nodes[toEdgeStr] = new EdgeNode(toEdge)\n            }\n            fromNode.afters.push(toEdge)\n        })\n    })\n\n    // 2. topological sort\n    const keys: string[] = Object.keys(nodes)\n\n    const visit = (idstr: string, ancestorsIn: unknown) => {\n        const node: EdgeNode = nodes[idstr]\n        const id: T = node.id\n\n        // if already exists, do nothing\n        if (visited[idstr]) {\n            return\n        }\n\n        const ancestors: T[] = Array.isArray(ancestorsIn) ? ancestorsIn : []\n\n        ancestors.push(id)\n        visited[idstr] = true\n\n        for (const afterID of node.afters) {\n            // if already in ancestors, a closed chain exists.\n            if (ancestors.indexOf(afterID) >= 0) {\n                throw new Error(\"Circular chain found: \" + id + \" must be before \" + afterID +\n                    \" due to a direct order specification, but \" + afterID + \" must be before \" + id + \n                    \" based on other specifications.\")\n            }\n\n            // recursive call\n            visit(afterID.toString(), ancestors.map((v) => v))\n        }\n        sorted.unshift(id)\n    }\n    keys.forEach(visit)\n\n    return sorted.reverse()\n}\n", "import { Assert, AssertIsNumber, asWriteable, clone, exists, hasOwnProperty, isNumber, isObject } from '@netent-tech/ecas-utils'\nimport { AudioAction, IBasicTranslation, IMinMaxTranslation, Translation, TranslationProps } from \"@netent-tech/ecas-common\"\nimport { Utils } from '../utils'\n\nfunction isBasicTranslation (obj: object): obj is IBasicTranslation {\n    if (hasOwnProperty(obj, TranslationProps.in) && hasOwnProperty(obj, TranslationProps.out)) {\n        return isNumber(obj[TranslationProps.in]) && isNumber(obj[TranslationProps.out])\n    }\n    return false\n}\n\nfunction isMinMaxTranslation (obj: object): obj is IMinMaxTranslation {\n    if (hasOwnProperty(obj, TranslationProps.min) && hasOwnProperty(obj, TranslationProps.max)) {\n        if (isObject(obj.min) && isObject(obj.max)) {\n            return isBasicTranslation(obj.min) && isBasicTranslation(obj.max)\n        }\n    }\n    return false\n}\n\nfunction isTranslation (thing: unknown): thing is Translation {\n    if (isObject(thing) && hasOwnProperty(thing, TranslationProps.param)) {\n        return hasOwnProperty(thing, TranslationProps.param)\n            && isBasicTranslation(thing)\n            || isMinMaxTranslation(thing)\n    }\n    return false\n}\n\nfunction translateMinMax(translation: Readonly<IMinMaxTranslation>, arg: Readonly<number>) {\n    const inMin = Utils.randomizeValues(translation.min.in)\n    const outMin = Utils.randomizeValues(translation.min.out)\n    const inRange = Utils.randomizeValues(translation.max.in) - inMin\n    const outRange = Utils.randomizeValues(translation.max.out) - outMin\n    const factor = (arg - inMin) / inRange\n    return outRange * factor + outMin\n}\n\nfunction translateBasic (translation: Readonly<IBasicTranslation>, arg: Readonly<number>) {\n    if (arg === translation.in) {\n        // will only randomize if translation.out is an array, otherwise same as in\n        return Utils.randomizeValues(translation.out)\n    }\n    throw new Error(\"translateBasic failed\")\n}\n\nfunction translateObject (translation: Readonly<Translation>, arg: Readonly<number>) {\n    if (isBasicTranslation(translation)) {\n        return translateBasic(translation, arg)\n    }\n    else if (isMinMaxTranslation(translation)) {\n        return translateMinMax(translation, arg)\n    }\n    throw new Error ('ECAS Translator.translateObject should never reach this line.')\n}\n\n// only exported for testing\nfunction translateTranslation (translation: Translation, gameArgs: readonly unknown[]) {\n    Assert(gameArgs.length > translation.param, 'translateAction param is out of range. Aborting.')\n    const arg = gameArgs[translation.param]\n    AssertIsNumber(arg, `translate only works for numbers but arg is ${typeof arg}, args.length: ${gameArgs.length}, eventParam: ${translation.param}, args: ${gameArgs}`)\n    return translateObject(translation, arg)\n}\n\nexport function translateActionArgs (actionArgs: Readonly<AudioAction['args']>, gameArgs: readonly unknown[]): Readonly<AudioAction['args']> {\n    const result = asWriteable(clone(actionArgs)) \n    const gameArgsCopy = [...gameArgs]\n\n    for (let i = 0; i < result.length; i++) {\n        const actionArg = result[i]\n        if (isTranslation(actionArg)) {\n            result[i] = translateTranslation(actionArg, gameArgsCopy)\n        }\n        else if (isObject(actionArg)) {\n            for (const [key, value] of Object.entries(actionArg)) {\n                if (isTranslation(value)) {\n                    const ri = result[i]\n                    if (exists(ri)) {\n                        (ri as [])[key] = translateTranslation(value, gameArgsCopy)\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\n// recommended for making it clear it is only exported for testing reasons and not needed to be exported otherwise.\nexport const Testing = {\n    translateTranslation\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { type Disposable, exists, isArray, isDefined, isNumber, isObject, isString, keys, tryAsync, unique } from '@netent-tech/ecas-utils'\r\nimport { ECAS } from \"../ECAS\"\r\nimport type { AudioAction, EventConfig, EventConnections, IAudioState, ILoadrConfig, StateConfig } from \"@netent-tech/ecas-common\"\r\nimport { Observable } from \"./Observable\"\r\nimport { StateMachine } from \"./StateMachine\"\r\nimport { translateActionArgs } from \"./translations\"\r\n\r\n/**\r\n * Adds support for mapping game events to sound events\r\n * Sets up state handler that manages audio states.\r\n */\r\nexport class EventHandler extends Observable implements Disposable {\r\n    public stateMachine: StateMachine\r\n    private _gameEvents: Array<string>\r\n    private _audioEvents: Set<string>\r\n    private _eventMap: Map<EventConfig[number]['id'], EventConfig[number]['actions']>\r\n    private _ecas: Readonly<ECAS>\r\n\r\n    dispose() {\r\n        this._gameEvents = []\r\n        this._audioEvents = new Set()\r\n        this._eventMap.clear()\r\n        this.stateMachine.dispose()\r\n    }\r\n\r\n    constructor(events: Readonly<EventConfig>, states: Readonly<StateConfig>, loaderConfig: Readonly<ILoadrConfig>,  ecas: Readonly<ECAS>) {\r\n        super()\r\n        this._eventMap = new Map<EventConfig[number]['id'], EventConfig[number]['actions']>()\r\n        for (const event of events) {\r\n            this._eventMap.set(event.id, event.actions)\r\n        }\r\n        this._gameEvents = this._createListOfGameEvents(Object.values(states))\r\n        this._audioEvents = this._createSetOfAudioEvents(events)\r\n        this.stateMachine = new StateMachine(states, loaderConfig)\r\n        this._ecas = ecas\r\n        logger().info(\"[ecas] gameEvents:\", this._gameEvents)\r\n        logger().info(\"[ecas] audioEvents:\", this._audioEvents)\r\n        logger().info(\"[ecas] actions:\", this._eventMap)\r\n    }\r\n\r\n    /**\r\n     * Proxies the game event through the state handler into ecas.\r\n     */\r\n    public async triggerGameEvent(gameEvent: string, ...args: readonly unknown []) {\r\n        logger().info('[ecas] game-event', gameEvent, ...args)\r\n        const isEventRelevant = this._gameEvents.includes(gameEvent)\r\n        if (!isEventRelevant) {\r\n            return\r\n        }\r\n\r\n        // Maybe gameEvent triggers a state change\r\n        this.stateMachine.triggerStateChange(gameEvent, ...args)\r\n        const audioEvent = this.getAudioEventName(gameEvent, ...args)\r\n        if (!audioEvent) {\r\n            return\r\n        }\r\n        // be careful so that triggering actions doesn't halt the rest of\r\n        // game if an issue occurs\r\n        const [error] = await tryAsync(this.triggerAudioEvent.bind(this))(audioEvent, ...args)\r\n        if (error) {\r\n            logger().log(\"[ecas] error when running event:\", audioEvent, error)\r\n        }\r\n    }\r\n\r\n    /* Use this if you want to trigger an audio event directly */\r\n    public async triggerAudioEvent(audioEvent: string, ...args: readonly unknown []) {\r\n        logger().info('[ecas] audio-event', audioEvent, ...args)\r\n        const promises: Promise<unknown>[] = []\r\n        this.emit(audioEvent, ...args)\r\n        if (audioEvent) {\r\n            if (!this._audioEvents.has(audioEvent)) {\r\n                return Promise.resolve()\r\n            }\r\n            const actions = this._eventMap.get(audioEvent)\r\n            if (isDefined(actions)) {\r\n                for (const action of actions) {\r\n                    promises.push(this.runAction(action, ...args))\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises)\r\n    }\r\n\r\n    public triggerOnEndedEvent(eventName: string, ...args: readonly undefined []) {\r\n        // requested to make playlist functionality in tacofury possible\r\n        this.triggerGameEvent(eventName, ...args)\r\n        // previously only triggered audio event\r\n        this.triggerAudioEvent(eventName, ...args)\r\n    }\r\n\r\n    private async runAction(action: AudioAction, ...args: readonly unknown []) {\r\n        const translatedArgs = translateActionArgs(action.args, args)\r\n        const method = this._ecas[action.type]\r\n        const unsafe = method as any\r\n        // be careful so that triggering actions doesn't halt the rest of\r\n        // game if an issue occurs, but throw it on debug build so tests fail\r\n        const [error] = await tryAsync(() => unsafe.apply(this._ecas, translatedArgs))()\r\n        if (error) {\r\n            logger().log(\"[ecas] error when running action:\", action, error)\r\n        }\r\n    }\r\n\r\n    private getAudioEventName(event: string, ...args: readonly unknown []): string {\r\n        const ret = this._getAudioEventConnectionOrName(event)\r\n\r\n        if (!exists(ret)) {\r\n            logger().debug('[ecas] no audio-event to trigger on game-event:', event, 'in state:', this.stateMachine.activeState)\r\n            return ''\r\n        }\r\n\r\n        if (isObject(ret)) {\r\n            return walkThroughObject(ret)\r\n        }\r\n        // audio-event is a string\r\n        return ret\r\n\r\n        /**\r\n         * if game for example sends: GameAudioEvents.ReelBounce 0\r\n         * and eventmapping is\r\n         *  [GameAudioEvents.ReelBounce]: {\r\n         *       0: AudioEvents.Bounce1,\r\n         *       1: AudioEvents.Bounce2\r\n         * },\r\n         * then should return AudioEvents.Bounce1\r\n        */\r\n        function walkThroughObject(obj: object) {\r\n            // Look through the members to see if args correspond\r\n            if (isArray(args)) {\r\n                const key = args[0]\r\n                if (isString(key) || isNumber(key)) {\r\n                    const mappedEvent = obj[key]\r\n                    if (isString(mappedEvent)) {\r\n                        return mappedEvent\r\n                    }\r\n                }\r\n            }\r\n            return ''\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<string>} A copy of all game events that existed in the audio-states file.\r\n     */\r\n    get gameEvents(): readonly string[] {\r\n        return this._gameEvents\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns {Array<string>} A copy of all audio event names that existed in the audio-states file.\r\n     */\r\n    get audioEvents(): readonly string[] {\r\n        return [...this._audioEvents.keys()]\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the audio event linked to the game event for the current state (or it's parent states if it is not used) | or null if no event should be triggered\r\n     */\r\n    private _getAudioEventConnectionOrName(gameEvent: string, state = this.stateMachine.activeState): string | EventConnections | null {\r\n        const audioEvent = state.events[gameEvent]\r\n\r\n        if (audioEvent) {\r\n            return audioEvent\r\n        }\r\n        else if (state.parent) {\r\n            const parent = this.stateMachine.getState(state.parent)\r\n            return this._getAudioEventConnectionOrName(gameEvent, parent)\r\n        }\r\n        return null\r\n    }\r\n\r\n    private _createListOfGameEvents(states: ReadonlyArray<IAudioState>): Array<string> {\r\n        const arr = states.map (\r\n            (state) =>\r\n                [\r\n                    ...keys(state.events),\r\n                    ...state.activatesOn.map((activation) => isString(activation) ? activation : activation.event),\r\n                    ...state.deactivatesOn.map((activation) => isString(activation) ? activation : activation.event),\r\n                    ...this._createListOfGameEvents(Object.values(state.children))\r\n                ]\r\n        )\r\n        const flat = arr.flat()\r\n        return unique(flat)\r\n    }\r\n\r\n    private _createSetOfAudioEvents(events: Readonly<EventConfig>) {\r\n        const audioEvents = new Array<string>()\r\n        for (const event of events) {\r\n            audioEvents.push(event.id)\r\n        }\r\n        return new Set(audioEvents)\r\n    }\r\n}\r\n", "export const EcasEvents = {\n    Ready: 'ecas-ready', // ecas has been initialized, you can add effects to busses etc\n    Mute: 'ecas-mute',\n    Unmute: 'ecas-unmute',\n    Pause: 'ecas-pause',\n    Resume: 'ecas-resume',\n    Timer: {\n        Pause: 'ecas-timer-pause',\n        Resume: 'ecas-timer-resume',\n    },\n    Context: {\n        Pause: 'ecas-context-pause',\n        Resume: 'ecas-context-resume',\n        Suspended: 'ecas-context-suspended',\n        Running: 'ecas-context-running',\n        Closed: 'ecas-context-closed',\n        Interrupted: 'ecas-context-interrupted',\n    },\n    Preload: {\n        Start:   \"ecas-preload-start\",\n        Done:    \"ecas-preload-done\",\n        Progress: \"ecas-preload-progress\",\n    },\n    Sound: {\n        LoadStart:     'ecas-sound-load-start',\n        Loading:       'ecas-sound-load-loading',\n        LoadDone:      'ecas-sound-load-done',\n        LoadError:     'ecas-sound-load-error',\n        Abort:         'ecas-sound-abort',\n        CanPlay:       'ecas-sound-canplay',\n        Play:          'ecas-sound-play',\n        Stop:          'ecas-sound-stop',\n        Ended:         'ecas-sound-ended',\n        Pause:         'ecas-sound-pause',\n        FadeOutStart:  'ecas-sound-fade-out-start',\n        FadeOutEnd:    'ecas-sound-fade-out-end',\n        PlaybackStart: 'ecas-sound-playback-start',\n        PlaybackEnd:   'ecas-sound-playback-end',\n        PlaybackError: 'ecas-sound-playback-error',\n    },\n    Events: {\n        LoadStart:     'ecas-events-load-start',\n        LoadDone:      'ecas-events-load-done',\n    },\n    Envelope: {\n        Play:          'ecas-envelope-play',\n        Start:         'ecas-envelope-start',\n        Ended:         'ecas-envelope-ended',\n    },\n} as const\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { exists, tryAsync, trySync } from \"@netent-tech/ecas-utils\"\nimport { Sound } from \"@netent-tech/ecas-common\"\nimport EventHandler, { EcasEvents } from \"../event-handler\"\nimport { ILoadSoundDetails } from \"./SoundHandler\"\n\nexport interface ICreateAudioBufferOptions {\n    id: Sound['id'] // only needed for triggering event\n    eventHandler: EventHandler\n    audioContext: AudioContext\n    url: string\n    duration?: number\n}\n\ninterface ICreateBufferOptions extends ICreateAudioBufferOptions {\n    arrayBuffer: ArrayBuffer\n}\n\ninterface ICreateEditedBufferOptions {\n    buffer: AudioBuffer\n    duration: number\n    audioContext: AudioContext\n}\n\ninterface ICreateAndStoreAudioBufferParams {\n    id: Sound['id'],\n    detail: ILoadSoundDetails,\n    mutBuffers: Map<Sound['id'], AudioBuffer>,\n    audioContext: AudioContext\n    eventHandler: EventHandler\n}\n\ninterface ICreateBufferPromisesParams {\n    ids: Sound['id'][],\n    mutDetails: Map<Sound['id'], ILoadSoundDetails>,\n    mutBuffers: Map<Sound['id'], AudioBuffer>,\n    audioContext: AudioContext,\n    eventHandler: EventHandler\n}\n\nexport function createBufferPromises (params: ICreateBufferPromisesParams) {\n    const { ids, mutDetails, eventHandler } = params\n    const promises: Promise<void>[] = []\n    for (const id of ids) {\n\n        if (!mutDetails.has(id)) {\n            logger().error(\"[ecas] create buffer'\", id, \"' not found in\", mutDetails)\n            continue\n        }\n\n        const detail = mutDetails.get(id)\n        if (detail.isLoaded) {\n            logger().debug(\"[ecas] sound\", id, \"has already been loaded\")\n            continue\n        }\n\n        if (detail.isLoading) {\n            logger().debug(\"[ecas] sound\", id, \"is already in the process of being loaded\")\n            continue\n        }\n\n        detail.isLoading = true\n        eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadStart, id)\n        // doing it this way to be able to fetch them all at the same time without having to wait for one to load before we can load next\n        promises.push(createAndStoreAudioBuffer({id: id, detail: detail, ...params }))\n    }\n    return promises\n}\n\nexport async function createAndStoreAudioBuffer (params: ICreateAndStoreAudioBufferParams) {\n    const { id, detail: detail, mutBuffers, eventHandler } = params\n    const [error, buffer] = await tryAsync(() => createAudioBuffer({ ...params, duration: detail.duration, url: detail.url }))()\n    if (error) {\n        logger().error(error)\n        detail.isLoaded = false\n        detail.isLoading = false\n        eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadError, id)\n        return\n    }\n    mutBuffers.set(id, buffer)\n    detail.isLoaded = true\n    detail.isLoading = false\n    eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadDone, id)\n}\n\nexport async function createAudioBuffer(options: ICreateAudioBufferOptions): Promise<AudioBuffer> {\n    return new Promise<AudioBuffer>((resolve, reject) => {\n        const req = createRequest(options.url)\n        req.addEventListener(\"abort\", () => {\n            reject(`[ecas]rRequest for ${options.url} aborted`)\n        })\n        req.addEventListener(\"timeout\", () => {\n            reject(`[ecas]rRequest for ${options.url} timed out`)\n        })\n        req.addEventListener(\"load\", () => {\n            options.eventHandler.triggerAudioEvent(EcasEvents.Sound.Loading, options.id)\n            const arrayBuffer = req.response as ArrayBuffer\n            if (arrayBuffer.byteLength === 0) {\n                reject(\"[ecas] response returned arraybuffer with byteLength 0\")\n            }\n            createBuffer({ ...options, arrayBuffer })\n                .then(\n                    buffer => resolve(buffer),\n                    reason => reject(reason)\n                )\n                .catch(reason => reject(reason))\n        })\n        req.addEventListener(\"error\", (ev: ProgressEvent<XMLHttpRequestEventTarget>) => {\n            reject(`[ecas] error when requesting: '${options.url}', ${ev}`)\n        })\n        req.send()\n    })\n}\n\nfunction createRequest(url: string) {\n    const request = new XMLHttpRequest()\n    request.open(\"GET\", url, true)\n    request.responseType = \"arraybuffer\"\n    return request\n}\n\nasync function createBuffer(options: ICreateBufferOptions) {\n    return new Promise<AudioBuffer>((resolve, reject) => {\n        const { duration, arrayBuffer, audioContext, url } = options\n        audioContext\n            .decodeAudioData(arrayBuffer,\n                (buffer) => {\n                    const [error, ] = trySync(() => {\n                        const isDifferentDuration = duration !== buffer.duration\n                        if (isDifferentDuration && duration > 0) {\n                            const editedBuffer = createEditedBuffer({ audioContext, buffer, duration })\n                            resolve(editedBuffer)\n                        }\n                        resolve(buffer)\n                    })()\n                    if (error) {\n                        reject(error)\n                    }\n                },\n                (error) => {\n                    options.eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadError, options.id)\n                    logger().error('[ecas] createBuffer: Failed to decode audio data at url ', url, 'Error:', error )\n                    reject('[ecas] failed to decode audio data')\n                }\n            )\n            .then(\n                buffer => resolve(buffer),\n                reason => reject(reason)\n            )\n            .catch(reason => {\n                reject(reason)\n            })\n    })\n}\n\nfunction createEditedBuffer(options: ICreateEditedBufferOptions): AudioBuffer {\n    const { duration, buffer, audioContext } = options\n    const length = Math.floor(duration * buffer.sampleRate)\n    const editedBuffer = audioContext.createBuffer(buffer.numberOfChannels, length, buffer.sampleRate)\n    return copyAudioBuffer({src: buffer, trg: editedBuffer})\n}\n\ninterface ICopyBuffer {\n    src: AudioBuffer\n    trg: AudioBuffer\n}\n\nfunction copyAudioBuffer(options: ICopyBuffer) {\n    const isDecentBrowser = exists(options.src.copyToChannel)\n    if (isDecentBrowser) {\n        return copyAudioBufferDefault(options)\n    }\n    return copyAudioBufferLegacy(options)\n}\n\nfunction copyAudioBufferDefault(options: ICopyBuffer) {\n    const { src, trg } = options\n    for (let i = 0; i < src.numberOfChannels; i++) {\n        trg.copyToChannel(src.getChannelData(i), i, 0)\n    }\n    return trg\n}\n\nfunction copyAudioBufferLegacy(options: ICopyBuffer) {\n    const { src, trg } = options\n    for (let i = 0; i < src.numberOfChannels; i++) {\n        const editedChannel = trg.getChannelData(i)\n        const originalChannel = src.getChannelData(i)\n        for (let j = 0; j < editedChannel.length; j++) {\n            editedChannel[j] = originalChannel[j] || 0\n        }\n    }\n    return trg\n}\n\nfunction createEmptyAudioBufferLike(buffer: AudioBuffer, audioContext: AudioContext) {\n    return audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate)\n}\n\nfunction reverseAudioBuffer(bufferMutable: AudioBuffer) {\n    for (let channelNumber = 0; channelNumber < bufferMutable.numberOfChannels; channelNumber++) {\n        const data = bufferMutable.getChannelData(channelNumber)\n        const reversedData = data.reverse()\n        bufferMutable.copyToChannel(reversedData, channelNumber)\n    }\n    return bufferMutable\n}\n\nexport function createReversedBuffer(src: AudioBuffer, audioContext: AudioContext) {\n    const newBufferEmpty = createEmptyAudioBufferLike(src, audioContext)\n    const newBufferFilled = copyAudioBuffer({src: src, trg: newBufferEmpty})\n    return reverseAudioBuffer(newBufferFilled)\n}\n", "export class SoundLoadError extends Error {\n    override name = \"SoundLoadError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class SoundFormatError extends Error {\n    override name = \"SoundFormatError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class SoundUndefinedError extends Error {\n    override name = \"SoundUndefinedError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class DecodeError extends Error {\n    override name = \"DecodeError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { Assert, Disposable, Exists, isUndefined, joinUrl } from '@netent-tech/ecas-utils'\nimport { Sound } from \"@netent-tech/ecas-common\"\nimport EventHandler from \"../event-handler\"\nimport { EcasOptions } from \"../options-creator\"\nimport { createBufferPromises, createReversedBuffer } from \"./buffers\"\nimport { SoundLoadError } from \"./errors\"\n\nexport interface ILoadSoundDetails {\n    url: string\n    isLoaded: boolean\n    isLoading: boolean\n    duration?: number\n}\n\nexport interface SoundHandlerOptions {\n    ecasOptions: EcasOptions\n    audioContext: AudioContext\n    eventHandler: EventHandler\n}\n\nexport class SoundHandler implements Disposable {\n    // priorityQueue: string[] = []\n    #audioContext: AudioContext\n    #details = new Map<Sound['id'], ILoadSoundDetails>()\n    #buffers = new Map<Sound['id'], AudioBuffer>()\n    #reversedBuffers = new Map<Sound['id'], AudioBuffer>()\n    #sounds: Map<Sound['id'], Sound>\n    #eventHandler: EventHandler\n\n    dispose () {\n        this.#buffers.clear()\n        this.#reversedBuffers.clear()\n        this.#details.clear()\n        this.#sounds.clear()\n        this.#eventHandler.dispose()\n    }\n\n    constructor(options: SoundHandlerOptions) {\n        const { ecasOptions, audioContext, eventHandler } = options\n        this.#audioContext = audioContext\n        this.#eventHandler = eventHandler\n\n        const { fileExtToUse, soundData, packageToUse } = ecasOptions.loadrConfig\n        const sounds = ecasOptions.soundConfig.sounds\n        const directory = joinUrl(ecasOptions.soundConfig.settings.loadPath, packageToUse)\n\n        for (const sound of sounds) {\n            this.details.set(sound.id, {\n                url: joinUrl(directory, sound.id) + fileExtToUse,\n                duration: soundData.get(sound.id) || 0,\n                isLoaded: false,\n                isLoading: false\n            })\n        }\n\n        this.#sounds = new Map(ecasOptions.soundConfig.sounds.map(sound => [sound.id, sound]))\n    }\n\n    get details() {\n        return this.#details\n    }\n\n    public getSound(id: Sound['id']): Sound {\n        Assert(this.#sounds.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] sound '${id}' does not exist.`\n        })\n        return Exists(this.#sounds.get(id))\n    }\n\n    public getDurationSeconds (id: Sound['id']) {\n        const detail = Exists(this.details.get(id))\n        if(isUndefined(detail.duration)) {\n            logger().error(`[ecas] sound '${id}' does not have a duration.`)\n        }\n        return detail.duration || this.getAudioBufferSync(id).duration // seconds\n    }\n\n    public async getAudioBuffer(id: Sound['id']) {\n        Assert(this.details.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] sound with id: ${id} cannot be loaded because it does not seem to exist`\n        })\n        if (Exists(this.details.get(id)).isLoaded) {\n            return Exists(this.#buffers.get(id))\n        }\n        logger().debug(\"[ecas] buffer has not been loaded yet, loading now...\")\n        await this.load([id]).catch(() => {\n            logger().log(`[ecas] sound with id: ${id} cannot be loaded`)\n        })\n        return Exists(this.#buffers.get(id))\n    }\n\n    public getAudioBufferSync(id: Sound['id']) {\n        Assert(this.details.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] getBuffer - Sound with id: ${id} cannot be loaded because it does not seem to exist`\n        })\n        if (Exists(this.details.get(id)).isLoaded) {\n            return Exists(this.#buffers.get(id))\n        }\n        logger().debug(\"[ecas] getBuffer; buffer has not been loaded yet. Cannot use the sync version for this, make sure you load the sound before calling this method.\")\n        return Exists(this.#buffers.get(id))\n    }\n\n    public async getAudioBufferReversed(id: Sound['id']) {\n        if (!this.#reversedBuffers.has(id)) {\n            await this.#createReversedBufferForSound(id)\n        }\n        return this.#reversedBuffers.get(id)\n    }\n\n    /**\n     * if buffer has already been loaded soundHandler will return already existing buffer\n    */\n    public async load (ids: Sound['id'][]) {\n        logger().debug(\"[ecas] load\", ids)\n        // Todo: Check that AudioContext has been allowed to start\n        const bufferPromises = createBufferPromises({\n            ids: ids,\n            mutDetails: this.details,\n            mutBuffers: this.#buffers,\n            audioContext: this.#audioContext,\n            eventHandler: this.#eventHandler\n        })\n\n        return Promise.all(bufferPromises)\n    }\n\n    public async loadAll () {\n        logger().debug(\"[ecas] loadAll\")\n        await this.load([...this.#sounds.keys()])\n    }\n\n    public getAllSoundIds () {\n        return [...this.#sounds.keys()]\n    }\n\n    public isLoaded (id: Sound['id']) {\n        const is = this.details.has(id) && Exists(this.details.get(id)).isLoaded\n        return is\n    }\n\n    async #createReversedBufferForSound(id: Sound['id']) {\n        const buffer = await this.getAudioBuffer(id)\n        const reversed = createReversedBuffer(buffer, this.#audioContext)\n        this.#reversedBuffers.set(id, reversed)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isNonEmptyArray, type Disposable } from '@netent-tech/ecas-utils'\nimport { AudioAction, Group, IPatternContext, Pool, Sound } from \"@netent-tech/ecas-common\"\nimport { EcasOptions } from \"../options-creator\"\nimport { SoundHandler, SoundHandlerOptions } from \"./SoundHandler\"\n\n/**\n * Purpose: handle loading of assets (audio files mainly) for ecas\n *  should:\n *      load audio-files\n *      store buffers\n *      have a priority\n *      does it need to be able to load other assets?\n *\n *      load single AudioFiles\n *      load all AudioFiles = one package (desktop or mobile)\n */\nexport class AssetHandler implements Disposable {\n    soundHandler: SoundHandler\n    #groups: Map<string, Group> = new Map()\n    #pools: Map<string, Pool> = new Map()\n    /** used to store assets to be loaded that are related to events **/\n    #eventAssets: Map<string, Sound['id'][]> = new Map()\n\n    // #patterns: Map<string, Pattern> = new Map()\n    #patternContexts: Map<string, IPatternContext> = new Map()\n\n    dispose () {\n        this.#groups = new Map()\n        this.#pools = new Map()\n        this.#eventAssets = new Map()\n        this.#patternContexts = new Map()\n        this.soundHandler.dispose()\n    }\n\n    constructor(options: SoundHandlerOptions) {\n        this.soundHandler = new SoundHandler(options)\n\n        for (const group of options.ecasOptions.soundConfig.groups) {\n            this.#groups.set(group.id, group)\n        }\n        for (const pool of options.ecasOptions.soundConfig.pools) {\n            this.#pools.set(pool.id, pool)\n        }\n        // for (const pattern of options.ecasOptions.soundConfig.patterns) {\n        //     this.#patterns.set(pattern.id, pattern)\n        // }\n        this.#storeSoundsRelatedToEvents(options.ecasOptions)\n    }\n\n    #storeSoundsRelatedToEvents(ecasOptions: EcasOptions) {\n        // todo: expand to work for more event targets than \"playSound\"\n        const events = ecasOptions.eventConfig\n\n        for (const { id, actions } of events) {\n            this.#eventAssets.set(id, findSoundsUsedInActions(actions))\n        }\n        return\n\n        function findSoundsUsedInActions (actions: readonly AudioAction[]) {\n            const soundsUsed: string[] = []\n            for (const action of actions) {\n                if (action.type === \"playSound\") {\n                    soundsUsed.push(action.args[0].toString())\n                }\n            }\n            return soundsUsed\n        }\n    }\n\n    loadAssetsRelatedToEvents(ids: string[]) {\n        const loadPromises = ids.map(id => {\n            const relatedAssets = this.#eventAssets.get(id)\n            if (isNonEmptyArray(relatedAssets)) {\n                return this.soundHandler.load(relatedAssets)\n            }\n            logger().debug(`[ecas] asset - found no assets for event '${id}' ${this.#eventAssets.get(id)}`)\n            return Promise.resolve()\n        })\n        return Promise.all(loadPromises)\n    }\n\n    getPool(id: string) {\n        if (!this.#pools.has(id)) {\n            logger().error('[ecas] asset - pool with id', id, 'does not exist')\n        }\n        return this.#pools.get(id)\n    }\n\n    hasPool(id: string) {\n        return this.#pools.has(id)\n    }\n\n    getGroup(id: string) {\n        if (!this.#groups.has(id)) {\n            logger().error('[ecas] asset - group with id', id, 'does not exist')\n        }\n        return this.#groups.get(id)\n    }\n\n    getPatternContext(id: string) {\n        if (!this.#patternContexts.has(id)) {\n            logger().error('[ecas] asset - pool with id', id, 'does not exist')\n        }\n        return this.#patternContexts.get(id)\n    }\n\n    hasPatternContext(id: string) {\n        this.#patternContexts.has(id)\n    }\n\n    setPatternContext(id: string, ctx: IPatternContext) {\n        this.#patternContexts.set(id, ctx)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { enumValues, hasOwnProperty, isDefined, isFunction } from \"@netent-tech/ecas-utils\"\nimport { AudioFileExtension } from \"@netent-tech/ecas-common\"\nimport { SoundFormatError } from \"./errors\"\n\nconst AudioFormats = {\n    caf: 'x-caf',\n    webm: 'webm',\n    ogg: 'ogg',\n    mp4: 'mp4',\n    mp3: 'mp3'\n} as const\n\n/**\n * Different browsers support different audio file formats\n * so this method is used to determine what files to load.\n */\nexport function getPrefferedFileExtension(available: AudioFileExtension[] = enumValues(AudioFileExtension)): AudioFileExtension {\n    // Todo: need to check for what extensions actually exists to use in formatPresets....\n    const supported = getBrowserSupportedAudioFormats()\n\n    logger().debug(\"[ecas] supported AudioFormats:\")\n    logger().table(supported)\n\n    // if error here it's because we dont have dom library,\n    // eg. its ecas-encoder using the function so we return a dummy value since it doesnt matter\n    if (supported === null) {\n        try {\n            isDefined(navigator)\n        }\n        catch {\n            return AudioFileExtension.WEBM\n        }\n    }\n\n    const isEdgeBrowser = () => /Edge/.test(navigator.userAgent)\n    const isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n    const actuallySupportsWebm = () => !isEdgeBrowser() && !isSafari()\n\n    const isSafariOnDesktop = () => hasOwnProperty(window, 'safari') && isDefined(window.safari)\n    const isSafariOnMobile = () => isSafari() && !isSafariOnDesktop()\n    if (isEdgeBrowser()) {\n        logger().debug('[ecas] Edge Browser detected.')\n    }\n    if (isSafariOnDesktop()) {\n        logger().debug('[ecas] Safari on desktop detected.')\n    }\n    if (isSafariOnMobile()) {\n        logger().debug('[ecas] Safari on mobile detected.')\n    }\n\n    if (supported !== null) {\n        const isAvailable = (ext: AudioFileExtension) => available.includes(ext) // encoding format exists in soundConfig\n        const usable = (ext: AudioFileExtension) => supported[ext] && isAvailable(ext)\n        if (usable(AudioFileExtension.WEBM) && actuallySupportsWebm()) // Edge supports opus but it is too slow at decoding, safari pretends to play but does not..\n            return AudioFileExtension.WEBM\n        if (usable(AudioFileExtension.MP4)) // safari .caf opus often don't work with ffmpeg encoding which is why we prefer mp4 over .caf\n            return AudioFileExtension.MP4\n        if (usable(AudioFileExtension.MP3))\n            return AudioFileExtension.MP3\n        if (usable(AudioFileExtension.CAF))\n            return AudioFileExtension.CAF\n    }\n\n    throw new SoundFormatError(\"[ecas] no available audio file format found.\")\n}\n\n/** Returns null if no supported formats found. */\nexport function getBrowserSupportedAudioFormats() {\n    let element: HTMLAudioElement\n    try {\n        element = new window.Audio()\n    }\n    catch {\n        return null\n    } // need to catch for ecas-encoder.....\n\n    if (!isFunction(element.canPlayType)) {\n        return null\n    }\n\n    const canPlay = (type: string) => {\n        const can = element.canPlayType(`audio/${type}`)\n        enum CanPlay { Probably = \"probably\", Maybe = \"maybe\" }\n        return can === CanPlay.Probably || can === CanPlay.Maybe\n    }\n\n    return {\n        [AudioFileExtension.WEBM]: canPlay(AudioFormats.webm), // return false if safari they be pretending, same with edge sorta\n        [AudioFileExtension.MP4]: canPlay(AudioFormats.mp4),\n        [AudioFileExtension.CAF]: canPlay(AudioFormats.caf),\n        [AudioFileExtension.OGG]: canPlay(AudioFormats.ogg),\n        [AudioFileExtension.MP3]: canPlay(AudioFormats.mp3)\n    }\n}\n", "export const TIME_LOOKAHEAD_SECONDS = 0.03 as const\nexport const TIME_LOOKAHEAD_MILLISECONDS = 30 as const\nexport const DEFAULT_CROSSFADE_MILLISECONDS = 10 as const\nexport const DEFAULT_FADEOUT_MILLISECONDS = 10 as const\nexport const MASTER_BUS_ID = \"master\" as const\nexport const OUTPUT_BUS_ID = \"OUTPUT\" as const\n\nexport const MAX_GAIN_LINEAR = 20 as const // totally arbitrary number\nexport const MIN_GAIN_LINEAR = 0.001 as const\nexport const MIN_PAN = -1 as const\nexport const MAX_PAN = 1 as const\nexport const MIN_FREQUENCY = 10 as const\nexport const MAX_FREQUENCY = 20000 as const\n\nexport const TIMEOUT_CALLERS = {\n    DEFAULT_STOP: 'default_stop',\n    POOL_STOP: 'pool_stop',\n    POOL_PLAY: 'pool_play',\n    POOL_PAUSE: 'pool_pause',\n    POOL_RESUME: 'pool_resume',\n    SOUND_START: 'sound_start',\n    SOUND_STOP: 'sound_stop',\n    SOUND_PAUSE: 'sound_pause',\n    SOUND_RESUME: 'sound_resume',\n    SOUND_COMPLETE: \"sound_completed\",\n    PATTERN_PLAY: 'pattern_play',\n    PATTERN_STOP: 'pattern_stop',\n    PATTERN_RESUME: 'pattern_resume',\n    PATTERN_PAUSE: 'pattern_pause',\n    PATTERN: 'pattern',\n    STOP: 'stop',\n    MIXER_PLAY_SOUND: \"mixer_playSound\",\n    ENVELOPE_SCHEDULED: \"envelope_scheduled\",\n    SCHEDULED: \"scheduled\",\n    SCHEDULED_REGEX: \"scheduled_(.)+\",\n    DISCONNECT: \"disconnect\",\n    VOLUME: \"volume\",\n    CROSSFADE: \"crossfade\",\n    PLAY: \"play\"\n} as const\n", "import { ITypeNamed, noop, PartialProperties } from \"@netent-tech/ecas-utils\"\nimport type { EnvelopeCurveType, EnvelopeParameterType, IEnvelopeContext, IEnvelopePoint, TargetType } from \"@netent-tech/ecas-common\"\n\nconst typename = \"EnvelopeContext\" as const\nexport class EnvelopeContext implements IEnvelopeContext, ITypeNamed<typeof typename> {\n    static typename = typename\n    get typename () {\n        return typename\n    }\n\n    type: TargetType = \"sound\"\n    parentId = ''\n    /** In seconds */\n    startTime = 0\n    onEnded = noop\n    onplay = noop\n    willStopSoundOnEnded = false\n    isPaused = false\n    isAFadeIn = false\n    curveType: EnvelopeCurveType = 'linear'\n    envelopePoints: IEnvelopePoint[] = []\n    param: EnvelopeParameterType = 'volume'\n\n    audioParam: AudioParam\n\n    node?: DynamicsCompressorNode | BiquadFilterNode | DelayNode | GainNode\n    pauseTime?: number\n\n    constructor(config: PartialProperties<EnvelopeContext> = {}) {\n        Object.assign(this, config)\n    }\n}\n\nexport function createEnvelopeContext(config: PartialProperties<EnvelopeContext> = {}) {\n    return new EnvelopeContext(config)\n}\n", "import { type Disposable } from \"@netent-tech/ecas-utils\"\nimport { EnvelopeContext } from \".\"\nexport class EnvelopeHandler implements Disposable {\n    #contexts = new Map<string, EnvelopeContext[]>()\n\n    dispose() {\n        this.#contexts.clear()\n    }\n\n    getContexts(id: string) {\n        if (!this.#contexts.has(id)) {\n            this.#contexts.set(id, [])\n        }\n        return this.#contexts.get(id)\n    }\n\n    setContexts(options: {id: string, contexts: EnvelopeContext[]}) {\n        this.#contexts.set(options.id, options.contexts)\n    }\n\n}\n", "import { arrayPowerMutate, arraySum, isNumber, type ITypeNamed, noop, range } from \"@netent-tech/ecas-utils\"\nimport { EnvelopeCurveType, EnvelopeParameterType, IEnvelopePoint, IPlayEnvelopeArgs, TargetType } from \"@netent-tech/ecas-common\"\n\nconst typename = \"PlayEnvelopeArgs\" as const\nexport class PlayEnvelopeArgs implements IPlayEnvelopeArgs, ITypeNamed<typeof typename> {\n    static typename = typename\n    get typename () {\n        return typename\n    }\n\n    startTime = 0\n    type: TargetType = 'sound'\n    curveType: EnvelopeCurveType = 'linear'\n    onEnded = noop\n    onplay = noop\n    willStopSoundOnEnded = false\n\n    param: EnvelopeParameterType\n    envelopePoints: IEnvelopePoint[] = []\n\n    constructor(config: IPlayEnvelopeArgs) {\n        Object.assign(this, config)\n        if (isNumber(config.startTime)) {\n            this.startTime = config.startTime / 1000\n            return\n        }\n        this.startTime = 0\n    }\n}\n\nexport function isPlayEnvelopeArgs(thing: object): thing is PlayEnvelopeArgs {\n    return thing['typename'] === PlayEnvelopeArgs.typename\n}\n\nexport function createPlayEnvelopeArgs(config: IPlayEnvelopeArgs) {\n    return new PlayEnvelopeArgs(config)\n}\n\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute(envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n    let pos = 0\n    return envelope.map((point: IEnvelopePoint) => {\n        pos += Number(point.pos)\n        return {\n            pos,\n            val: point.val\n        }\n    })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative(envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n    let last = 0\n    return envelope.map((val: IEnvelopePoint) => {\n        const currPos = val.pos\n        const pos = currPos - last\n        last = currPos\n        return {\n            pos: pos,\n            val: val.val\n        }\n    })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n */\nexport function createLogarithmicCurve(direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000) {\n    const base = 9 // what is base 9 supposed to do\n    const numSamples = Math.ceil(duration * sampleRate)\n    const curve = new Float32Array(numSamples)\n\n    const indexes = range(numSamples)\n    if (direction === -1) {\n        indexes.reverse()\n    }\n\n    for (const i of range(numSamples)) {\n        const x = base * i / numSamples + 1\n        curve[indexes[i]] = Math.log10(x)\n    }\n    return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace(first = 1, last = 10, num_samples = 10) {\n    const createSafeLogValue = (val: number) => {\n        if (val > 0) {\n            return Math.log10(val)\n        }\n        return Math.log10(1e-5) // -100 dBFS\n    }\n    const first_log10 = createSafeLogValue(first)\n    const last_log10 = createSafeLogValue(last)\n\n    const increment = (last_log10 - first_log10) / (num_samples - 1)\n    const vector = new Float32Array(num_samples)\n    let accumulated = first_log10\n\n    vector[0] = first\n    for (let index = 1; index < num_samples - 1; index++) {\n        accumulated += increment\n        vector[index] = Math.pow(10, accumulated)\n    }\n    vector[num_samples - 1] = last\n\n    return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace(first = 1, last = 10, num_samples = 10) {\n    const increment = (last - first) / (num_samples - 1)\n    const vector = new Float32Array(num_samples)\n    let accumulated = first\n    for (let index = 0; index < num_samples; index++) {\n        vector[index] = accumulated\n        accumulated += increment\n    }\n    vector[0] = first\n    vector[vector.length-1] = last\n    return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace(first = 1, last = 0, numSamples = 10) {\n    const phaseStart = Math.PI / 2\n    const vector = new Float32Array(numSamples)\n\n    // create half of a sigmoid between 0-1\n    for (let i = 0; i < numSamples; i++) {\n        const phasei = Math.PI * i / (numSamples - 1)\n        const phasen = phasei - phaseStart\n        vector[i] = Math.sin(phasen) / 2 + 0.5\n    }\n\n    // scale the curve\n    const scale = last - first\n    for (let i = 0; i < numSamples; i++) {\n        vector[i] = vector[i] * scale + first\n    }\n    return vector\n}\n\nexport function powspace(first = 1, last = 0, numSamples = 10, power = 2) {\n    const linStart = Math.pow(first, 1 / power)\n    const linEnd = Math.pow(last, 1 / power)\n    const lin = linspace(linStart, linEnd, numSamples)\n    return arrayPowerMutate(lin, power)\n}\n\nexport function coolspace(numSamples = 10, shape = 2.5) {\n    const result = new Float32Array(numSamples)\n    for (let i = 0; i < numSamples; i++) {\n        result[i] = Math.pow (\n            Math.E,\n            (-i / numSamples)\n                * shape\n                * (- Math.log(0.01))\n        )\n    }\n    return result\n}\n\nfunction createCurve(values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array) {\n    const totalNumSamples = arraySum(numSamples)\n    const curve = new Float32Array(totalNumSamples)\n\n    let value_prev = values[0]\n    let start = 0\n    for (let i = 0; i < values.length; i++) {\n        const ns = numSamples[i]\n        const slice = curveCreator(value_prev, values[i], numSamples[i])\n        curve.set(slice, start)\n        start += ns\n        value_prev = values[i]\n    }\n    return curve\n}\n\nfunction getCurveCreator(curveType: EnvelopeCurveType) {\n    return {\n        \"linear\": linspace,\n        \"exponential\": logspace,\n        \"logarithmic\": logspace,\n        \"s-curve\": sigspace,\n    }[curveType]\n}\n\n\nexport function createAutomationCurve(opt: {\n        values: number[],\n        positions: number[],\n        curveType: EnvelopeCurveType\n    }) {\n    const { values, positions, curveType } = opt\n    const numSamples = getNumSamples(positions)\n\n    const curveCreator = getCurveCreator(curveType)\n    const curve = createCurve(values, numSamples, curveCreator)\n    return curve\n}\n\nfunction getNumSamples(positions: number[]) {\n    const numSamplesPerPoint = 1/4\n    return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n\nexport * from \"./envelope-context\"\nexport * from './EnvelopeHandler'\n\n", "import { EnvelopeContext } from \".\"\n\nexport function createEnvelopePointsInOriginalState(points: readonly EnvelopeContext[], parentId: string) {\n    return points.reduce(\n        (acc, curr) => {\n            if (curr.parentId === parentId) {\n                return curr\n            }\n            return acc\n        }\n    )\n        .envelopePoints\n}\n", "import { TIMEOUT_CALLERS } from \"../constants\"\n\nexport function joinTimeoutCallers(...args: string[]) {\n    return args.join('::')\n}\n\nexport function createTimeoutCallerForPlayEnvelope(arg: {targetId: string, param: string, parentId: string, willStopSoundOnEnded: boolean}) {\n    const caller = joinTimeoutCallers(arg.targetId, arg.parentId, arg.param)\n    if (arg.willStopSoundOnEnded) {\n        return joinTimeoutCallers(caller, TIMEOUT_CALLERS.STOP)\n    }\n    return caller\n}\n", "import { exists } from '@netent-tech/ecas-utils'\nimport { IStringMap, ITimerCallback, ITimerItem } from \"@netent-tech/ecas-common\"\n\n/**\n * Wrapper for setTimeout and clearTimeout\n * Used to calculate remaining time of an timeout\n * and to dispatch callbacks when timeout ends.\n */\nexport class Timer {\n    /**\n     * Storage of callers and their timeout data.\n     */\n    private static _map: IStringMap<ITimerItem> = {}\n    /**\n     *\n     * Set a timeout and save its caller id in _map.\n     * If a caller already exists, we clear its timeout\n     * and save its callback to be dispatched once the new caller\n     * has finished.\n     * @param {() => void} callback Callback function to be called when timer ends\n     * @param {number} timeout Seconds until the timeout ends\n     * @param {string} caller Caller id of setTimeout\n     * @param {unknown[]} args Arguments for setTimeout\n     */\n\n    public static setTimeout(callback: () => void, timeout: number, caller = \"\", ...args: unknown[]) {\n        if (caller === \"\") {\n            window.setTimeout(callback, timeout * 1000, args)\n            return\n        }\n\n        const start = this.dateProvider()()\n        let callbacks: ITimerCallback[] = []\n        const callerHandle = this._map[caller]\n        if (callerHandle) {\n            callbacks = callbacks.concat(callerHandle.callbacks)\n            window.clearTimeout(callerHandle.id)\n        }\n        callbacks.push({args, callback})\n        const id = window.setTimeout(() => this.onDone(caller), timeout * 1000)\n        this._map[caller] = {id, remaining: timeout, start, callbacks, caller}\n    }\n\n    /**\n     * Renames existing timeout and clears its timeout.\n     * @param {string} caller New caller id of setTimeout\n     * @param {string} oldCaller Old caller id of setTimeout\n     * @param {number} newTimeout Seconds until the timeout ends\n     */\n    public static renameTimeout(caller: string, oldCaller: string, newTimeout?: number) {\n        const callerHandle = this._map[oldCaller]\n\n        if (callerHandle) {\n            const remaining = newTimeout || callerHandle.remaining\n            window.clearTimeout(callerHandle.id)\n            Timer.clearTimeout(oldCaller)\n            const id = window.setTimeout(() => this.onDone(caller), remaining * 1000)\n            this._map[caller] = {...callerHandle, id, remaining, caller}\n        }\n    }\n\n    /**\n     * Pauses the timeout by clearing it and calculating the remaining time of the timeout, and store that information.\n     * @param {string} caller Caller id of pause\n     */\n    public static pause(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            const now: number = this.dateProvider()()\n            window.clearTimeout(callerHandle.id)\n            callerHandle.remaining -= now - callerHandle.start\n        }\n    }\n\n    /**\n     * Pause all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static pauseMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.pause(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Resumes the timeout using the previously set value \"remaining\", \"start\" value is set to now() for\n     * future pause/resume.\n     * @param {string} caller Caller id of resume\n     */\n    public static resume(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            const now = this.dateProvider()()\n            callerHandle.start = now\n            const id = window.setTimeout(this.onDone.bind(this, caller, callerHandle.callbacks), callerHandle.remaining * 1000)\n            callerHandle.id = id\n        }\n    }\n\n    /**\n     * Resume all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static resumeMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.resume(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Clears all timeouts for a caller id.\n     * @param {string} caller Caller id of clearTimeout\n     */\n    public static clearTimeout(caller: string) {\n        if (this._map[caller]) {\n            window.clearTimeout(this._map[caller].id)\n            delete this._map[caller]\n        }\n    }\n\n    /**\n     * Clear all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static clearMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.clearTimeout(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Check if a timeout exists for an id.\n     * @param caller Id of timeout to check.\n     * @return {boolean} True if timeout exists.\n     */\n    public static hasTimeout(caller: string): boolean {\n        const has = exists(this._map[caller])\n        return has\n    }\n    /**\n     * Wrapper for Date\n     * @returns {number} Date.now Return current time\n     */\n    public static dateProvider = () => () => Date.now() / 1000\n\n    /**\n     * In this function all the collected callbacks are dispatched once the last sound of the caller has finished\n     * @param {caller} caller Caller id of onDone\n     */\n    private static onDone(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            delete this._map[caller]\n            callerHandle.callbacks.forEach((val: ITimerCallback) => {\n                val.callback.call(val.args)\n            })\n            window.clearTimeout(callerHandle.id)\n        }\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { exists } from \"@netent-tech/ecas-utils\"\nimport { ISoundContext } from \"@netent-tech/ecas-common\"\nimport EventHandler, { EcasEvents } from \"../event-handler\"\nimport { Timer } from \"../scheduling/Timer\"\n\nexport function getAudioBufferSourceNode(bufferData: AudioBuffer, audioContext: AudioContext, soundContext: ISoundContext) {\n    const source = exists(soundContext.soundSource.source)\n        ? soundContext.soundSource.source as AudioBufferSourceNode // Todo: fix these types so they dont intermingle\n        : audioContext.createBufferSource()\n    source.buffer = bufferData\n    source.loop = soundContext.isLoop\n    return source\n}\n\nexport function playBufferSource(source: AudioBufferSourceNode, duration: number, startTimeSeconds: number, context: ISoundContext, id: string, eventHandler: EventHandler, audioContext: AudioContext) {\n    try {\n        const pos = Math.max(context.currentTime * context.playbackRate, 0)\n\n        if (duration > 0) {\n            // used to add fade to time of duration here before but we considered fade should not add to duration but start before endtime instead\n            Timer.setTimeout(\n                () => eventHandler.triggerAudioEvent(EcasEvents.Sound.PlaybackStart, id),\n                startTimeSeconds - audioContext.currentTime\n            )\n            source.start(startTimeSeconds, pos, duration)\n        }\n        else {\n            if (duration < 0) {\n                logger().warn(\"[ecas] duration cannot be negative. was \" + duration + \" when playing sound '\" + id + \"'.\")\n            }\n            Timer.setTimeout(\n                () => eventHandler.triggerAudioEvent(EcasEvents.Sound.PlaybackStart, id),\n                startTimeSeconds - audioContext.currentTime\n            )\n            source.start(startTimeSeconds, pos)\n        }\n        source.onended = context.onSourceNodeEnded\n        source.playbackRate.value = context.playbackRate\n    }\n    catch (err) {\n        logger().error(err)\n    }\n}\n", "export const idGen = {\n    nextId: 0,\n    next() {\n        return idGen.nextId++\n    }\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isNumeric } from '@netent-tech/ecas-utils'\n\nexport interface ITypeNamed<T extends string> {\n  typename: T\n}\n\nexport function getWetMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix >= 0.5) {\n    return 1\n  }\n  return 1 - ((0.5 - mix) * 2)\n}\n\nexport function getDryMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix <= 0.5) {\n    return 1\n  }\n  return 1 - ((mix - 0.5) * 2)\n}\n\nexport function lastElement<T> (arr: T[]): T | undefined {\n  return arr.at(-1)\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\n\nexport interface SoundHandler {\n  dispose: () => void\n  details: Map<string, any>\n  getSound: (id: string) => any\n  getDurationSeconds: (id: string) => number\n  getAudioBuffer: (id: string) => Promise<AudioBuffer>\n  getAudioBufferSync: (id: string) => AudioBuffer\n  getAudioBufferReversed: (id: string) => Promise<AudioBuffer>\n  // eslint-disable-next-line\n    load: (ids: string[]) => Promise<void[]>\n  loadAll: () => Promise<void>\n  getAllSoundIds: () => string[]\n  isLoaded: (id: string) => boolean\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable { // implements ConvolverNode {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'AlgorithmicReverbInsert' as const\n/**\n * AlgorithmicReverb class is responsible to generate reverb nodes based on configuration given\n */\nexport class AlgorithmicReverbInsert implements InsertApi<AlgorithmicReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): AlgorithmicReverbInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options for algorithmic reverb\n     */\n  private readonly options: Required<AlgorithmicReverbInsertOptions>\n  /**\n     * Input node for algorithmic reverb\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node for algorithmic reverb\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node for algorithmic reverb\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node for algorithmic reverb\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Convolver node for algorithmic reverb\n     */\n  private reverbNode: ConvolverNode\n  /**\n     * Audio context for algorithmic reverb\n     */\n  private readonly audioContext: AudioContext\n\n  /**\n   * Creates an instance of algorithmic reverb.\n   * @param audioContext\n   * @param options\n   */\n  constructor (audioContext: AudioContext, options: AlgorithmicReverbInsertOptions = { id: TYPENAME }) {\n    this.options = {\n      id: options.id,\n      mix: 1,\n      time: 0.2,\n      decay: 0.2,\n      reverse: false\n    }\n\n    this.audioContext = audioContext\n\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.reverbNode = audioContext.createConvolver()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.dryGainNode)\n    this.dryGainNode.connect(this.outputGainNode)\n    this.inputGainNode.connect(this.reverbNode)\n    this.reverbNode.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.modify({ ...this.options, ...options }).catch(logger().error)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain, options.mix)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  async modify (options: PartialProperties<AlgorithmicReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let smoothingTimeSeconds = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      smoothingTimeSeconds = true\n    }\n\n    if (options.time !== undefined && this.options.time !== options.time) {\n      const MAX_TIME = 10 as const\n      // large impulses are costly\n      this.options.time = clamp(options.time, MIN, MAX_TIME)\n      smoothingTimeSeconds = true\n    }\n    // no need to rebuild if no change since previous update\n    if (options.decay !== undefined && this.options.decay !== options.decay) {\n      smoothingTimeSeconds = true\n      this.options.decay = Math.min(\n        Math.max(options.decay, MIN),\n        this.options.time\n      )\n    }\n\n    if (smoothingTimeSeconds) {\n      this.buildImpulse()\n    }\n  }\n\n  buildImpulse (): void {\n    const length = this.audioContext.sampleRate * this.options.time\n    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate)\n    const impulseL = impulse.getChannelData(0)\n    const impulseR = impulse.getChannelData(1)\n\n    let n: number\n    let i: number\n\n    for (i = 0; i < length; i++) {\n      n = this.options.reverse ? length - i : i\n      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n    }\n\n    if (this.reverbNode.buffer != null) {\n      this.inputGainNode.disconnect(this.reverbNode)\n      this.reverbNode.disconnect(this.wetGainNode)\n\n      this.reverbNode = this.audioContext.createConvolver()\n      this.inputGainNode.connect(this.reverbNode)\n      this.reverbNode.connect(this.wetGainNode)\n    }\n\n    this.reverbNode.buffer = impulse\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { FILTER_TYPES } from '../utils'\nimport { type InsertApi } from './types'\n\n/**\n * Uses BiquadFilterNode\n * see https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n **/\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport default BiquadFilterInsertOptions\n\n/** Converted to not extend BiquadFilterNode cause doesn't work on old browsers */\nconst TYPENAME = 'BiquadFilterInsert' as const\nexport class BiquadFilterInsert implements InsertApi<BiquadFilterInsert> {\n  static typename = TYPENAME\n  typename = BiquadFilterInsert.typename\n  id: string = TYPENAME\n  automator = new Automator(['frequency', 'detune', 'Q', 'gain'] as const)\n\n  private readonly options: BiquadFilterInsertOptions\n\n  node: BiquadFilterNode\n\n  constructor (context: BaseAudioContext, options: BiquadFilterInsertOptions) {\n    // will set the parameters to any options provided so no need to run modify in constructor\n    this.node = context.createBiquadFilter()\n    this.id = options.id\n    // any options provided overrides default\n    this.options = Object.assign({\n      id: options.id,\n      detune: 0,\n      frequency: context.sampleRate / 2,\n      gain: 0,\n      Q: 1,\n      type: 'lowpass'\n    }, options)\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.Q.value = this.options.Q!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.detune.value = this.options.detune!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.frequency.value = this.options.frequency!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.gain.value = this.options.gain!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.type = this.options.type!\n\n    this.automator.add('Q', this.node.Q)\n    this.automator.add('detune', this.node.detune)\n    this.automator.add('frequency', this.node.frequency)\n    this.automator.add('gain', this.node.gain)\n  }\n\n  get input (): BiquadFilterNode {\n    return this.node\n  }\n\n  get output (): BiquadFilterNode {\n    return this.node\n  }\n\n  get getOptions (): BiquadFilterInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the filter options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     */\n  async modify (\n    options: BiquadFilterInsertOptions,\n    endTimeSeconds: number,\n    sampleRate: number\n  ): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/Q\n         *\n         * The Q property of the BiquadFilterNode interface is an a-rate AudioParam, a double representing a Q factor, or quality factor.\n         * It is a dimensionless value with a default value of 1 and a nominal range of 0.0001 to 1000.\n         */\n    if (typeof options.Q === 'number') {\n      const MIN_Q = 0.0001 as const\n      const MAX_Q = 1000 as const\n      this.options.Q = clamp(options.Q, MIN_Q, MAX_Q)\n      this.node.Q.cancelScheduledValues(0)\n      this.node.Q.linearRampToValueAtTime(this.options.Q, endTimeSeconds)\n    }\n\n    /**\n         * Detune is basically the same as using frequency\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/detune\n         * https://webaudio.github.io/web-audio-api/dom-audiobuffersourcenode-detune\n         *\n         * The detune property of the BiquadFilterNode interface is an a-rate AudioParam representing detuning of the frequency in cents.\n         * For many AudioParams the minValue and maxValue is intended to be set to the maximum possible range.\n         * In this case, maxValue should be set to the most-positive-single-float value, which is 3.4028235e38.\n         * (However, in JavaScript which only supports IEEE-754 double precision float values,\n         * this must be written as 3.4028234663852886e38.)\n         * Similarly, minValue should be set to the most-negative-single-float value,\n         * which is the negative of the most-positive-single-float: -3.4028235e38.\n         * (Similarly, this must be written in JavaScript as -3.4028234663852886e38.)\n         */\n    if (typeof options.detune === 'number') {\n      const MOST_POSITIVE_SINGLE_FLOAT_VALUE = 3.4028234663852886e38 as const\n      const MOST_NEGATIVE_SINGLE_FLOAT_VALUE = -3.4028234663852886e38 as const\n      this.options.detune = clamp(\n        options.detune,\n        MOST_NEGATIVE_SINGLE_FLOAT_VALUE,\n        MOST_POSITIVE_SINGLE_FLOAT_VALUE\n      )\n      this.node.detune.cancelScheduledValues(0)\n      this.node.detune.linearRampToValueAtTime(\n        this.options.detune,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The frequency property of the BiquadFilterNode interface is an a-rate AudioParam\n         *  \u2014 a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n         * Its default value is 350, with a nominal range of 10 to the Nyquist frequency \u2014 that is, half of the sample rate.\n         */\n    if (typeof options.frequency === 'number') {\n      const minFrequency = 10 as const\n      const maxFrequency = sampleRate / 2\n      this.options.frequency = clamp(options.frequency, minFrequency, maxFrequency)\n      this.node.frequency.cancelScheduledValues(0)\n      this.node.frequency.exponentialRampToValueAtTime(\n        this.options.frequency,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The gain property of the BiquadFilterNode interface is an a-rate AudioParam\n         *    \u2014 a double representing the gain used in the current filtering algorithm.\n         * When its value is positive, it represents a real gain; when negative, it represents an attenuation.\n         *  It is expressed in dB, has a default value of 0, and can take a value in a nominal range of -40 to 40.\n         */\n    if (typeof options.gain === 'number') {\n      const maxGainDecibel = 40 as const\n      const minGainDecibel = -40 as const\n      this.options.gain = clamp(\n        options.gain,\n        minGainDecibel,\n        maxGainDecibel\n      )\n      this.node.gain.cancelScheduledValues(0)\n      this.node.gain.linearRampToValueAtTime(\n        this.options.gain,\n        endTimeSeconds\n      )\n    }\n\n    if (options.type !== undefined && options.type !== null && FILTER_TYPES.includes(options.type)) {\n      this.node.type = this.options.type = options.type\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.node.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, Exists, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type SoundHandler } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface ConvolverReverbInsertOptions extends Identifiable { //, Omit<ConvolverOptions, keyof AudioNode> {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: string\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'ReverbConvolverInsert' as const\n/**\n * ReverbConvolver class is responsible to generate a reverb node based on configuration given\n */\nexport class ConvolverReverbInsert implements InsertApi<ConvolverReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): ConvolverReverbInsertOptions {\n    return this.options\n  }\n\n  get audioParams (): { dryGain: AudioParam, wetGain: AudioParam } {\n    return { dryGain: this.dryGainNode.gain, wetGain: this.wetGainNode.gain }\n  }\n\n  private readonly soundHandler: SoundHandler // to fetch buffers for the impulses\n\n  /**\n     * Options of ConvolverNode\n     */\n  private readonly options: Required<ConvolverReverbInsertOptions> = {\n    id: TYPENAME,\n    normalize: false,\n    reverse: false,\n    impulseResponse: 'none', // updated in .modify\n    mix: 1\n  } as const\n\n  /**\n     * Input node of ConvolverNode\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ConvolverNode\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ConvolverNode\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ConvolverNode\n     */\n  private readonly wetGainNode: GainNode\n\n  /**\n     * convolver node of ConvolverNode\n     */\n  private readonly convolverNode: ConvolverNode\n\n  /**\n     * Creates an instance of Reverb Convolver node.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: ConvolverReverbInsertOptions, soundHandler: SoundHandler) {\n    this.soundHandler = soundHandler\n    this.inputGainNode = audioContext.createGain()\n    this.convolverNode = audioContext.createConvolver()\n    this.outputGainNode = audioContext.createGain()\n\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.convolverNode)\n\n    this.convolverNode.connect(this.wetGainNode)\n    this.inputGainNode.connect(this.dryGainNode)\n\n    this.dryGainNode.connect(this.outputGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n\n    this.id = options.id\n    if (options.impulseResponse === undefined) {\n      logger().warn('[ecas] convolver reverb impulse file should be specified.')\n      return\n    }\n    this.modify(options).catch(logger().error)\n  }\n\n  async modify (options: PartialProperties<ConvolverReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let shouldUpdateBuffer = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n\n    if (options.normalize !== undefined && this.options.normalize !== options.normalize) {\n      this.options.normalize = options.normalize\n      this.convolverNode.normalize = this.options.normalize\n      shouldUpdateBuffer = true\n    }\n\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      shouldUpdateBuffer = true\n    }\n\n    // no need to rebuild if no change since previous update\n    if (options.impulseResponse !== undefined && this.options.impulseResponse !== options.impulseResponse) {\n      shouldUpdateBuffer = true\n      this.options.impulseResponse = options.impulseResponse\n    }\n\n    if (shouldUpdateBuffer) {\n      await this.updateBuffer()\n    }\n  }\n\n  async updateBuffer (): Promise<void> {\n    const bufferPromise = this.options.reverse\n      ? this.soundHandler.getAudioBufferReversed(this.options.impulseResponse)\n      : this.soundHandler.getAudioBuffer(this.options.impulseResponse)\n\n    this.convolverNode.buffer = Exists(await bufferPromise)\n  }\n}\n", "\nimport { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, max, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nconst TYPENAME = 'DelayInsert' as const\n/**\n * Delay class is responsible to generate a delay node based on configuration given\n */\nexport class DelayInsert implements InsertApi<DelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  automator = new Automator(['delayTime', 'feedback', 'dry-gain', 'wet-gain', 'cutoff'] as const)\n\n  get id (): string {\n    return this.options.id\n  }\n\n  set id (newId: string) {\n    this.options.id = newId\n  }\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): DelayInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of delay\n     */\n  private readonly options: Required<DelayInsertOptions>\n  /**\n     * Input node of delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of delay\n     */\n  private readonly delayNode: DelayNode\n\n  private readonly filterNode: BiquadFilterNode\n\n  /**\n     * Creates an instance of delay.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: DelayInsertOptions = { id: 'delay' }) {\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n    this.feedbackGainNode = audioContext.createGain()\n    this.filterNode = audioContext.createBiquadFilter()\n    this.filterNode.type = 'lowpass'\n    this.delayNode = audioContext.createDelay(options.maxDelayTime !== undefined ? options.maxDelayTime : 1)\n\n    // final graph\n    // input->dry->output\n    // input->delay->feedback\n    //        feedback->delay\n    //        delay->wet->output\n    this.inputGainNode\n      .connect(this.dryGainNode)\n      .connect(this.outputGainNode)\n\n    this.inputGainNode\n      .connect(this.delayNode)\n      .connect(this.wetGainNode)\n      .connect(this.outputGainNode)\n\n    this.delayNode\n      .connect(this.feedbackGainNode)\n      .connect(this.filterNode)\n      .connect(this.delayNode)\n\n    this.options = {\n      id: options.id,\n      feedback: 0.1,\n      mix: 1,\n      delayTime: 0.3,\n      maxDelayTime: 1,\n      cutoff: 20000\n    }\n\n    this.modify(Object.assign(this.options, options)).catch(logger().error)\n\n    this.automator.add('cutoff', this.filterNode.frequency)\n    this.automator.add('delayTime', this.delayNode.delayTime)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  public async modify (options: PartialProperties<DelayInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const GAIN_MIN = 0.0001 as const\n\n    if (options.delayTime !== undefined) {\n      this.options.delayTime = clamp(options.delayTime, 0, this.options.maxDelayTime)\n\n      this.delayNode.delayTime.cancelScheduledValues(0)\n      this.delayNode.delayTime.linearRampToValueAtTime(this.options.delayTime, endTimeSeconds)\n    }\n    if (options.feedback !== undefined) {\n      this.options.feedback = clamp(options.feedback, GAIN_MIN, 1)\n\n      this.feedbackGainNode.gain.cancelScheduledValues(0)\n      this.feedbackGainNode.gain.exponentialRampToValueAtTime(this.options.feedback, endTimeSeconds)\n    }\n    if ((options.maxDelayTime !== undefined)) {\n      this.options.maxDelayTime = clamp(options.maxDelayTime, 0, 10)\n    }\n    if ((options.mix !== undefined)) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, GAIN_MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(clamp(1 - this.options.mix, GAIN_MIN, MIX_MAX), endTimeSeconds)\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(this.options.mix, endTimeSeconds)\n    }\n    if ((options.id !== undefined)) {\n      this.options.id = options.id\n    }\n\n    if ((options.cutoff !== undefined)) {\n      this.options.cutoff = clamp(options.cutoff, 10, 20000)\n      this.filterNode.frequency.exponentialRampToValueAtTime(this.options.cutoff, endTimeSeconds)\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.outputGainNode.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nconst TYPENAME = 'DynamicsCompressorInsert' as const\nexport class DynamicsCompressorInsert implements InsertApi<DynamicsCompressorInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  private readonly options: DynamicsCompressorInsertOptions\n  automator = new Automator(['threshold', 'ratio', 'attack', 'release', 'knee'] as const)\n  node: DynamicsCompressorNode\n  context: BaseAudioContext\n\n  constructor (context: BaseAudioContext, options: DynamicsCompressorInsertOptions) {\n    this.context = context\n    this.id = options.id\n    this.options = { ...options }\n    this.node = context.createDynamicsCompressor()\n    this.automator.add('threshold', this.threshold)\n    this.automator.add('ratio', this.ratio)\n    this.automator.add('attack', this.attack)\n    this.automator.add('release', this.release)\n    this.automator.add('knee', this.knee)\n    void this.modify(options, 0)\n  }\n\n  get attack (): AudioParam {\n    return this.node.attack\n  }\n\n  get knee (): AudioParam {\n    return this.node.knee\n  }\n\n  get ratio (): AudioParam {\n    return this.node.ratio\n  }\n\n  get release (): AudioParam {\n    return this.node.release\n  }\n\n  get threshold (): AudioParam {\n    return this.node.threshold\n  }\n\n  get input (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get output (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get getOptions (): DynamicsCompressorInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the compressor options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     * @param node\n     * @param options -\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * @param endTime\n     * @param sampleRate\n     */\n  async modify (options: DynamicsCompressorInsertOptions, endTime: number): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode/attack\n         * The attack property's default value is 0.003 and it can be set between 0 and 1\n         */\n    if (typeof options.attack === 'number') {\n      const MIN_ATTACK = 0 as const\n      const MAX_ATTACK = 1 as const\n      this.attack.cancelScheduledValues(0)\n      this.attack.linearRampToValueAtTime(\n        clamp(\n          options.attack,\n          MIN_ATTACK,\n          MAX_ATTACK\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The knee property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam containing a decibel value\n         * representing the range above the threshold where\n         * the curve smoothly transitions to the compressed portion\n         * The knee property's default value is 30 and it can be set between 0 and 40\n         */\n    if (typeof options.knee === 'number') {\n      const MIN_KNEE = 0 as const\n      const MAX_KNEE = 40 as const\n      this.knee.cancelScheduledValues(0)\n      this.knee.linearRampToValueAtTime(\n        clamp(\n          options.knee,\n          MIN_KNEE,\n          MAX_KNEE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The ratio property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n         * The ratio property's default value is 12 and it can be set between 1 and 20.\n         */\n    if (typeof options.ratio === 'number') {\n      const MIN_RATIO = 1 as const\n      const MAX_RATIO = 20 as const\n      this.ratio.cancelScheduledValues(0)\n      this.ratio.linearRampToValueAtTime(\n        clamp(\n          options.ratio,\n          MIN_RATIO,\n          MAX_RATIO\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The release property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of time, in seconds,\n         * required to increase the gain by 10 dB.\n         * It defines how quick the signal is adapted when its volume is reduced.\n         * The release property's default value is 0.25 and it can be set between 0 and 1.\n         */\n    if (typeof options.release === 'number') {\n      const MAX_RELEASE = 1 as const\n      const MIN_RELEASE = 0 as const\n      this.release.cancelScheduledValues(0)\n      this.release.exponentialRampToValueAtTime(\n        clamp(\n          options.release,\n          MIN_RELEASE,\n          MAX_RELEASE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The threshold property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n         * The threshold property's default value is -24 and it can be set between -100 and 0.\n         */\n    if (typeof options.threshold === 'number') {\n      const MIN_THRESHOLD = -100 as const\n      const MAX_THRESHOLD = 0 as const\n      this.threshold.cancelScheduledValues(0)\n      this.threshold.linearRampToValueAtTime(\n        clamp(\n          options.threshold,\n          MIN_THRESHOLD,\n          MAX_THRESHOLD\n        ),\n        endTime\n      )\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTime - this.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { type Identifiable } from '@netent-tech/ecas-utils'\nimport { getDryMixValue, getWetMixValue } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport default PingPongInsertOptions\n\nconst TYPENAME = 'PingPongDelayInsert' as const\n/**\n * PingPongDelay class is responsible to generate a ping pong delay nodes based on configuration given\n */\nexport class PingPongDelayInsert implements InsertApi<PingPongDelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain', 'delay-time-left', 'delay-time-right', 'feedback'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  /** Todo: implement */\n  async modify (): Promise<void> {\n    await Promise.resolve<undefined>(undefined)\n  }\n\n  get getOptions (): PingPongInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of ping pong delay\n     */\n  private readonly options: Required<PingPongInsertOptions>\n  /**\n     * Input node of ping pong  delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ping pong  delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ping pong delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ping pong delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of ping pong delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of ping pong delay\n     */\n  private readonly delayNodeLeft: DelayNode\n  /**\n     * Delay node right of ping pong delay\n     */\n  private readonly delayNodeRight: DelayNode\n  /**\n     * Channel merger of ping pong delay\n     */\n  private readonly channelMerger: ChannelMergerNode\n\n  /**\n     * Creates an instance of ping pong delay.\n     * @param ecasContext\n     * @param options\n     */\n  constructor (ecasContext: AudioContext, options: PingPongInsertOptions = { id: TYPENAME }) {\n    this.options = Object.assign({\n      feedback: 0.5,\n      mix: 0.5,\n      delayTime: 0.3,\n      maxDelayTime: 1\n    }, options)\n\n    this.maxDelayTime = options.maxDelayTime !== undefined ? options.maxDelayTime : 1\n\n    this.inputGainNode = ecasContext.createGain()\n    this.outputGainNode = ecasContext.createGain()\n    this.dryGainNode = ecasContext.createGain()\n    this.wetGainNode = ecasContext.createGain()\n    this.feedbackGainNode = ecasContext.createGain()\n    this.delayNodeLeft = ecasContext.createDelay(this.maxDelayTime)\n    this.delayNodeRight = ecasContext.createDelay(this.maxDelayTime)\n    this.channelMerger = ecasContext.createChannelMerger(2)\n\n    // dry mix\n    this.inputGainNode.connect(this.dryGainNode)\n    // dry out\n    this.dryGainNode.connect(this.outputGainNode)\n\n    // feedback loop\n    this.delayNodeLeft.connect(this.channelMerger, 0, 0)\n    this.delayNodeRight.connect(this.channelMerger, 0, 1)\n    this.delayNodeLeft.connect(this.delayNodeRight)\n    this.feedbackGainNode.connect(this.delayNodeLeft)\n    this.delayNodeRight.connect(this.feedbackGainNode)\n\n    // wet mix\n    this.inputGainNode.connect(this.feedbackGainNode)\n    // wet out\n    this.channelMerger.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.id = options.id\n\n    this.automator.add('delay-time-left', this.delayNodeLeft.delayTime)\n    this.automator.add('delay-time-right', this.delayNodeRight.delayTime)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n  }\n\n  public get mix (): number {\n    return this.options.mix\n  }\n\n  public set mix (mix: number) {\n    this.options.mix = mix\n    this.dryGainNode.gain.value = getDryMixValue(this.mix)\n    this.wetGainNode.gain.value = getWetMixValue(this.mix)\n  }\n\n  public get feedback (): number {\n    return this.options.feedback\n  }\n\n  public set feedback (feedback: number) {\n    if (feedback < 0 || feedback > 1) {\n      return\n    }\n    this.options.feedback = feedback\n    this.feedbackGainNode.gain.value = this.feedback\n  }\n\n  public get delayTime (): number {\n    return this.options.delayTime\n  }\n\n  public set delayTime (time: number) {\n    if (time < 0 || time > this.maxDelayTime) {\n      return\n    }\n    this.options.delayTime = time\n    this.delayNodeLeft.delayTime.value = this.delayTime\n    this.delayNodeRight.delayTime.value = this.delayTime\n  }\n\n  public get maxDelayTime (): number {\n    return this.options.maxDelayTime\n  }\n\n  public set maxDelayTime (maxDelay) {\n    this.options.maxDelayTime = maxDelay\n  }\n\n  public getPingPongDelayNodes (param: string): GainNode | DelayNode[] {\n    if (param === 'feedback') {\n      return this.feedbackGainNode\n    }\n    return [\n      this.delayNodeLeft,\n      this.delayNodeRight\n    ]\n  }\n\n  public getGeneratedGraph (): { leftNode: GainNode, rightNode: GainNode } {\n    return {\n      leftNode: this.inputGainNode,\n      rightNode: this.outputGainNode\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { InsertHandlerError, type SoundHandler } from '../utils'\nimport { AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { BiquadFilterInsert } from './BiquadFilterInsert'\nimport { ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { DelayInsert } from './DelayInsert'\nimport { DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { PingPongDelayInsert } from './PingPongDelayInsert'\nimport { type InsertClass, type InsertOptions, type InsertTypenames } from './types'\n\nexport function createInsert<T extends InsertTypenames> (\n  audioContext: AudioContext,\n  soundHandler: SoundHandler,\n  typename: T,\n  options: InsertOptions<T>\n): InsertClass<T> {\n  logger().debug('createInsert;', typename)\n  switch (typename) {\n    case BiquadFilterInsert.typename: {\n      return new BiquadFilterInsert(audioContext, options as BiquadFilterInsert['options']) as InsertClass<T>\n    }\n    case DynamicsCompressorInsert.typename: {\n      return new DynamicsCompressorInsert(audioContext, options as DynamicsCompressorInsert['options']) as InsertClass<T>\n    }\n    case DelayInsert.typename: {\n      return new DelayInsert(audioContext, options as DelayInsert['options']) as InsertClass<T>\n    }\n    case AlgorithmicReverbInsert.typename: {\n      return new AlgorithmicReverbInsert(audioContext, options as AlgorithmicReverbInsert['options']) as InsertClass<T>\n    }\n    case ConvolverReverbInsert.typename: {\n      return new ConvolverReverbInsert(audioContext, options as ConvolverReverbInsert['options'], soundHandler) as InsertClass<T>\n    }\n    case PingPongDelayInsert.typename: {\n      return new PingPongDelayInsert(audioContext, options as PingPongDelayInsert['options']) as InsertClass<T>\n    }\n    default: {\n      throw new InsertHandlerError(`create insert failed to create any insert for, ${typename as string}`)\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { createInsert, type InsertAny, type InsertClass, type InsertOptions, type InsertTypenames } from '.'\nimport { InsertHandlerError, lastElement, type SoundHandler } from '../utils'\n\nexport class InsertHandler implements Disposable {\n  private readonly insertMap = new Map<InsertAny['id'], Readonly<InsertAny>>()\n  private inserts: Array<Readonly<InsertAny>>\n  private readonly audioContext: AudioContext\n  private readonly soundHandler: SoundHandler\n  private readonly source: AudioNode\n  private readonly destination: AudioNode\n\n  constructor (audioContext: AudioContext, soundHandler: SoundHandler, source: AudioNode, destination: AudioNode) {\n    this.audioContext = audioContext\n    this.soundHandler = soundHandler\n    this.source = source\n    this.destination = destination\n    this.inserts = []\n  }\n\n  create<T extends InsertTypenames>(typename: T, options: InsertOptions<T>): void {\n    logger().debug('[ecas] insert.create', typename)\n    const insert = createInsert(\n      this.audioContext,\n      this.soundHandler,\n      typename,\n      options\n    )\n    this.add(insert)\n  }\n\n  add<T extends InsertTypenames>(insert: Readonly<InsertClass<T>>): void {\n    logger().debug('[ecas] insert.add')\n    const last = lastElement(this.inserts)\n\n    if (last != null) {\n      last.output.disconnect(this.destination)\n      last.output.connect(insert.input)\n    } else {\n      this.source.disconnect(this.destination)\n      this.source.connect(insert.input)\n    }\n\n    insert.output.connect(this.destination)\n\n    this.inserts.push(insert)\n    this.insertMap.set(insert.id, insert)\n  }\n\n  remove (id: string): void {\n    logger().debug('[ecas] insert.remove', id)\n    const newInserts: Array<Readonly<InsertAny>> = []\n    for (const [index, insert] of this.inserts.entries()) {\n      if (insert.id === id) {\n        const next = this.inserts[index + 1]?.input ?? this.destination\n        const prev = this.inserts[index - 1]?.output ?? this.source\n        prev.disconnect()\n        insert.output.disconnect()\n        prev.connect(next)\n      } else {\n        newInserts.push(insert)\n      }\n    }\n    this.inserts = newInserts\n    this.insertMap.delete(id)\n  }\n\n  get<T extends InsertTypenames>(id: string): InsertClass<T> {\n    if (!this.insertMap.has(id)) {\n      throw new InsertHandlerError(`[ecas] cannot get insert: ${id} since it does not exist`)\n    }\n    return this.insertMap.get(id) as InsertClass<T>\n  }\n\n  logInserts (): void {\n    logger().log(this.inserts)\n  }\n\n  has (id?: string): boolean {\n    return typeof id === 'string'\n      ? this.insertMap.has(id)\n      : isArrayEmpty(this.inserts)\n  }\n\n  dispose (): void {\n    for (const id of this.insertMap.keys()) {\n      this.insertMap.delete(id)\n    }\n\n    while (this.inserts.length > 0) {\n      const insert = this.inserts.pop()\n      insert?.input.disconnect()\n      insert?.output.disconnect()\n    }\n  }\n}\n", "import { type AutomatableParameters, type Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type ITypeNamed } from '../utils'\nimport { type AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { type BiquadFilterInsert } from './BiquadFilterInsert'\nimport { type ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { type DelayInsert } from './DelayInsert'\nimport { type DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { type PingPongDelayInsert } from './PingPongDelayInsert'\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { clamp } from \"@netent-tech/ecas-utils\"\n\n/**\n * Create a pan node.\n *\n * @param {number} pan Pan value between -1 and 1. Defaults to 0 (center).\n *\n * @returns {StereoPannerNode} The created pan node instance.\n * @private\n */\nexport function createPanNode(audioContext: AudioContext, pan = 0): StereoPannerNode {\n    const stereoPanner = audioContext.createStereoPanner()\n    stereoPanner.pan.value = clamp(pan, -1, 1)\n    return stereoPanner\n}\n\nexport function createGainNode(audioContext: AudioContext, gain = 1): GainNode {\n    const gainNode = audioContext.createGain()\n    gainNode.gain.value = Math.max(gain, 0)\n    return gainNode\n}\n", "export function playSilenceToNode(audioContext: AudioContext, node: AudioNode) {\n    const silence = audioContext.createBufferSource()\n    silence.buffer = audioContext.createBuffer(2, 128, audioContext.sampleRate)\n    silence.connect(node)\n    silence.loop = true\n    silence.start()\n}\n", "import { Automatable, AutomatableParameters, Automator } from \"@netent-tech/ecas-automator\"\nimport { clamp, type Disposable } from \"@netent-tech/ecas-utils\"\nimport { Timer } from \"../../scheduling/Timer\"\nimport { SoundHandler } from \"../../asset-handler/SoundHandler\"\nimport { MAX_GAIN_LINEAR, MAX_PAN, MIN_GAIN_LINEAR, MIN_PAN, TIME_LOOKAHEAD_SECONDS } from \"../../constants\"\nimport { idGen } from \"../../id-generator\"\nimport { BusConfig } from \"@netent-tech/ecas-common\"\nimport { InsertHandler } from \"@netent-tech/ecas-inserts\"\nimport { createGainNode, createPanNode } from \"../node-creators\"\nimport { playSilenceToNode } from \"../silence\"\n\n/** #inputNode -> inserts -> #pannerNode -> #gainNode */\nexport class Bus implements Disposable, Automatable<AutomatableParameters<Bus>> {\n    automator = new Automator([\"gain\", \"pan\"] as const)\n    #audioContext: AudioContext\n    #soundHandler: SoundHandler\n\n    /** The name of this bus */\n    #id: string\n\n    // just here to provide something to be connected to without having to change every time an insert is added\n    #inputNode: GainNode\n\n    /** inserts destination connect to this node **/\n    #pannerNode: StereoPannerNode\n\n    /** Used as output node, pannerNode connects to this node */\n    #outputNode: GainNode\n\n    inserts: InsertHandler\n\n    constructor(audioContext: AudioContext, soundHandler: SoundHandler, config: BusConfig) {\n        this.#audioContext = audioContext\n        this.#soundHandler = soundHandler\n        this.#inputNode = createGainNode(audioContext, 1)\n        this.#outputNode = createGainNode(audioContext, clamp(config.volume, MIN_GAIN_LINEAR, MAX_GAIN_LINEAR))\n        this.#pannerNode = createPanNode(audioContext, clamp(config.pan, MIN_PAN, MAX_PAN))\n\n        // Adding a silence node to keep bus nodes from being reset when no sound is playing\n        // This is causing pan and gain changes set by envelopes to be lost. (ECAS-218)\n        // Note that this could break since clearing of unused nodes is not specified in the spec and might change\n        playSilenceToNode(this.#audioContext, this.#inputNode)\n\n        this.#inputNode\n            .connect(this.#pannerNode)\n            .connect(this.#outputNode)\n\n        this.setGain(config.volume)\n        this.setPan(config.pan)\n        this.#id = config.id\n        this.inserts = new InsertHandler(\n            this.#audioContext,\n            this.#soundHandler,\n            this.#inputNode,\n            this.#pannerNode\n        )\n\n        this.automator.add(\"gain\", this.#outputNode.gain)\n        this.automator.add(\"pan\", this.#pannerNode.pan)\n    }\n\n    get input () {\n        return this.#inputNode\n    }\n\n    get output () {\n        return this.#outputNode\n    }\n\n    get id () {\n        return this.#id\n    }\n\n    /** Used as input node when no inserts active */\n    get pannerNode () {\n        return this.#pannerNode\n    }\n\n    /** Used as output node */\n    get gainNode () {\n        return this.#outputNode\n    }\n\n    get gain() {\n        return this.#outputNode.gain\n    }\n\n    /**\n     * Set the output volume for a bus.\n     *\n     * @param {string} bussId ID of bus to modify.\n     * @param {number} val Volume value between 0-1.\n     */\n    setGain(newGain: number, duration = 0) {\n        const clampedValue = clamp(newGain, MIN_GAIN_LINEAR, MAX_GAIN_LINEAR)\n        this.#outputNode.gain.cancelScheduledValues(0)\n        this.#outputNode.gain.exponentialRampToValueAtTime(\n            clampedValue,\n            this.#audioContext.currentTime + TIME_LOOKAHEAD_SECONDS + duration\n        )\n        return new Promise<void>((resolve) => Timer.setTimeout(\n            () => resolve(),\n            (TIME_LOOKAHEAD_SECONDS + duration) * 1000,\n            String(idGen.next())\n        ))\n    }\n\n    /**\n     * Change pan position for a bus.\n     *\n     * @param {string} bussId ID of bus to modify.\n     * @param {number} newPan position between -1 to 1.\n     */\n    setPan(newPan: number, duration = 0) {\n        this.#outputNode.gain.cancelScheduledValues(0)\n        // linearRamp to prevent distortion when instantly changing pan value\n        this.#pannerNode.pan.linearRampToValueAtTime(\n            clamp(newPan, MIN_PAN, MAX_PAN),\n            this.#audioContext.currentTime + TIME_LOOKAHEAD_SECONDS + duration\n        )\n        return new Promise<void>((resolve) => Timer.setTimeout(\n            () => resolve(),\n            (TIME_LOOKAHEAD_SECONDS + duration) * 1000,\n            String(idGen.next())\n        ))\n    }\n\n    get pan() {\n        return this.#pannerNode.pan\n    }\n\n    dispose() {\n        this.#inputNode.disconnect()\n        this.#outputNode.disconnect()\n        this.#pannerNode.disconnect()\n    }\n}\n", "import { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { SoundHandler } from \"../../asset-handler/SoundHandler\"\nimport { MASTER_BUS_ID, OUTPUT_BUS_ID } from \"../../constants\"\nimport { BusConfig, BusHandlerError, IBusConnection, ISoundSource } from \"@netent-tech/ecas-common\"\nimport { topoSort } from \"../../utils\"\nimport { Bus } from \"./Bus\"\n\nexport class BusHandler implements Disposable {\n    #buses = new Map<Bus['id'], Bus>()\n    #busConnections = new Map<Bus['id'], IBusConnection>()\n    #audioContext: AudioContext\n    #soundHandler: SoundHandler\n\n    constructor(\n        audioContext: AudioContext,\n        soundHandler: SoundHandler,\n        busConfigs: BusConfig[]\n    ) {\n        this.#audioContext = audioContext\n        this.#soundHandler = soundHandler\n\n        const masterBusConfig = new BusConfig({\n            id: MASTER_BUS_ID,\n            destination: OUTPUT_BUS_ID\n        })\n        busConfigs.unshift(masterBusConfig)\n\n        // Should not be modified by anyone but ecas, only used for mute / unmute atm.\n        const outputBusConfig = new BusConfig({\n            id: OUTPUT_BUS_ID,\n            destination: null\n        })\n        busConfigs.unshift(outputBusConfig)\n\n        const connections = createSortedConnections(busConfigs)\n        connections.forEach(this.#setupBuss)\n    }\n\n    #setupBuss = (busConfig: BusConfig) => {\n        const bus = new Bus(this.#audioContext, this.#soundHandler, busConfig)\n\n        if (bus.id === OUTPUT_BUS_ID) {\n            bus.output\n                .connect(this.#audioContext.destination)\n        }\n        else {\n            bus.output\n                .connect(this.get(busConfig.destination).input)\n        }\n\n        this.#buses.set(bus.id, bus)\n\n        this.#busConnections\n            .set(bus.id, {\n                inputs: [],\n                outputs: [{\n                    index: 0,\n                    originalDestinationNode: busConfig.destination,\n                    node: this.#audioContext.destination,\n                    nodeId: bus.id + \"_0\",\n                    soundContext: null,\n                    isUsed: true\n                }]\n            })\n    }\n\n    get(id: string) {\n        if (!this.#buses.has(id)) {\n            throw new BusHandlerError(`[ecas] cannot get bus: ${id} since it does not exist`)\n        }\n        return this.#buses.get(id)\n    }\n\n    getBusConnections(id: string) {\n        if (!this.#busConnections.has(id)) {\n            throw new BusHandlerError(`[ecas] cannot get bus: ${id} since it does not exist`)\n        }\n        return this.#busConnections.get(id)\n    }\n\n    /**\n     * Remove a node connection from internal bus connection references\n     *\n     * @param {string} soundId Id of sound associated with SourceAudioNode.\n     * @param {string} parentId Id of sound parent (pattern or pool id).\n     * @param {ISoundSource} soundSource SourceAudioNode of the sound connection to purge.\n     * @param {string} busId The bus ID to purge sound connection from.\n     */\n    purgeConnections(soundId: string, parentId: string, soundSource: ISoundSource, busId: string): void {\n        const connections = this.getBusConnections(busId)\n\n        if (isArrayEmpty(connections.inputs)) {\n            return\n        }\n\n        connections.inputs = connections.inputs.filter (\n            (node) =>\n                node.soundContext.id !== soundId\n                && node.soundContext.parentId !== parentId\n                && node.soundContext.soundSource !== soundSource\n                && node.soundContext.bussId !== busId\n        )\n    }\n\n    dispose() {\n        for (const busNode of this.#buses.values()) {\n            busNode.dispose()\n        }\n    }\n}\n\nfunction createSortedConnections(buses: BusConfig[]) {\n    const busConnections = buses.map(bus => [bus.id, bus.destination])\n    const sortedConnections = topoSort(busConnections)\n    return sortedConnections.map(\n        val => buses.reduce(\n            (curr, acc) => curr.id === val ? curr : acc\n        )\n    )\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isDefined } from \"@netent-tech/ecas-utils\"\nimport { BusConfig, EnvelopeParameterType, ISoundContext, ISoundNodes, Sound, TargetType } from \"@netent-tech/ecas-common\"\nimport { joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Bus } from \"./buses/Bus\"\n\ninterface IGetAudioParamsOptions {\n    targetId: BusConfig['id'] | Sound['id']\n    param: EnvelopeParameterType\n    type: TargetType\n    parentId: BusConfig['id'] | Sound['id']\n    getSoundContexts: (id: string, parentId: string) => ISoundContext[]\n    getSoundConnections: (id: string) => ISoundNodes[]\n    getBuss: (id: BusConfig['id']) => Bus\n}\n\n/**\n * Read parameters from a bus or sound.\n *\n * @param {string} target ID of bus or sound to read from.\n * @param {string} param Type of value to read. \"volume\" or \"pan\" or \"pitch\".\n * @param {string} targetType Type of bus to read param from. Defaults to \"bus\", else interpreted as parentId for \"sound\".\n * @param {string} parentId Id of sound parent (pattern or pool id)\n * @returns {AudioParam} The retrieved AudioParam.\n*/\nexport function createAudioParams(options: IGetAudioParamsOptions): Array<AudioParam> {\n    if (options.type === \"bus\") {\n        return createAudioParamArrayForBuss(options)\n    }\n    // target type not bus, probably a sound parent id\n    return createAudioParamArrayForSound(options)\n}\n\nfunction createAudioParamArrayForBuss(options: IGetAudioParamsOptions) {\n    const { getBuss, targetId } = options\n    return createAudioParamArray(options, [getBuss(targetId)])\n}\n\nfunction createAudioParamArrayForSound(options: IGetAudioParamsOptions) {\n    const { targetId, parentId, getSoundConnections } = options\n    const connections = getSoundConnections(joinTimeoutCallers(targetId, parentId))\n    return createAudioParamArray(options, connections)\n}\n\nfunction createAudioParamArray (options: IGetAudioParamsOptions, arr: Array<ISoundNodes> | Array<Bus>) {\n    const { targetId, parentId, getSoundContexts, param } = options\n    const audioParams = new Array<AudioParam>()\n    for (const item of arr) {\n        switch (param) {\n            case \"volume\":\n                audioParams.push(item.gainNode.gain)\n                break\n            case \"pan\":\n                audioParams.push(item.pannerNode.pan)\n                break\n            case \"pitch\": {\n                // Todo: Check this\n                const soundContexts: ISoundContext[] = getSoundContexts(targetId, parentId)\n                const ctx = soundContexts.pop()\n                if (isDefined(ctx)) {\n                    const src = ctx.soundSource\n                    if (isDefined(src)) {\n                        const source = src.source as AudioBufferSourceNode\n                        audioParams.push(source.playbackRate)\n                    }\n                }\n                break\n            }\n            default:\n                logger().warn(\"[ecas] createAudioParamArray needs either \\\"volume\\\", \\\"pan\\\" or \\\"pitch\\\" as param type\")\n                break\n        }\n    }\n    return audioParams\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isArray } from \"@netent-tech/ecas-utils\"\nimport { SoundHandler } from \"../asset-handler/SoundHandler\"\nimport { SoundConfig } from \"@netent-tech/ecas-common\"\n\n/**\n* Get audio param (volume,pan and pitch) default value of sound/bus\n*\n* @param {string} target SoundId, bussId or EffectId.\n* @param {string} param Audio param volume,pan and pitch.\n* @param {string} targetType type of the target node.\n* @returns {number|undefined} Return number if audio param is configured, otherwise return undefined.\n*/\nexport function getDefaultValueFromSoundConfig(opt: {\n        targetId: string,\n        targetParam: string,\n        targetType: string,\n        soundConfig: SoundConfig,\n        soundHandler: SoundHandler\n    }): number | undefined {\n    const soundParams = [\"volume\", \"pan\", \"pitch\"] as const\n    function isSoundParam(thing: string): thing is typeof soundParams[number] {\n        return soundParams.includes(thing as typeof soundParams[number])\n    }\n\n    const { targetId: target, targetParam: param, targetType, soundConfig, soundHandler } = opt\n\n    if (targetType === \"sound\") {\n        const sound = soundHandler.getSound(target)\n\n        if (!isSoundParam(param)) {\n            logger().warn('[ecas] targetType is sound, but param is not eligible on sound.', target, param, targetType)\n        }\n\n        const soundParam = sound[param]\n        if (isArray(soundParam)) {\n            return getFirstValueInNDimensionalArray(soundParam)\n        }\n        return soundParam\n    }\n\n    const busConfig = soundConfig.buses.filter(bus_ => bus_.id === target)[0]\n    return busConfig[param]\n}\n\nfunction getFirstValueInNDimensionalArray<T> (arr: T) {\n    if (isArray(arr)) {\n        return getFirstValueInNDimensionalArray(arr[0])\n    }\n    return arr[0]\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isFunction, isString } from \"@netent-tech/ecas-utils\"\nimport EventHandler from \"../event-handler\"\n\n\nexport function callOnEnded(val: unknown, eventHandler: EventHandler): void {\n    if (isFunction(val)) {\n        val()\n        return\n    }\n\n    if (isString (val)) {\n        eventHandler.triggerOnEndedEvent(val)\n        return\n    }\n\n    logger().warn(\"[ecas] invalid parameter type specified in onEnded.\")\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { arraySum, clamp, Disposable, exists, isArrayNonEmpty, isDefined, isNull, isUndefined, noop } from '@netent-tech/ecas-utils'\nimport { AssetHandler } from \"../asset-handler\"\nimport { MAX_GAIN_LINEAR, MIN_GAIN_LINEAR, TIMEOUT_CALLERS, TIME_LOOKAHEAD_SECONDS } from \"../constants\"\nimport { BusConfig, IConnection, ISoundContext, ISoundNodes, ISoundSource, IStringMap, Sound, SourceAudioNode } from \"@netent-tech/ecas-common\"\nimport { createAutomationCurve, createEnvelopeContext, EnvelopeContext, EnvelopeHandler } from \"../envelopes\"\nimport { createEnvelopePointsInOriginalState } from \"../envelopes/envelopes\"\nimport { EcasEvents, EventHandler } from \"../event-handler\"\nimport { EcasOptions } from \"../options-creator\"\nimport { createTimeoutCallerForPlayEnvelope, joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Timer } from \"../scheduling/Timer\"\nimport { Utils } from \"../utils\"\nimport { getAudioBufferSourceNode, playBufferSource } from \"./buffer\"\nimport { BusHandler } from \"./buses/BusHandler\"\nimport { createAudioParams } from \"./create-audio-params\"\nimport { getDefaultValueFromSoundConfig } from \"./get-default-value-from-sound-config\"\nimport { createPanNode } from \"./node-creators\"\nimport { callOnEnded } from \"./onended\"\n\nexport class Mixer implements Disposable {\n    buses: BusHandler\n    #envelopeHandler: EnvelopeHandler\n\n    // #envelopes: IStringMap<IEnvelopeContext[]>;\n    #soundConnections: IStringMap<ISoundNodes[]>\n    #elementSoundSources: IStringMap<ISoundSource>\n    #audioContext: AudioContext\n    #soundContexts: IStringMap<ISoundContext[]>\n    #options: EcasOptions\n    #eventHandler: EventHandler\n    #assetHandler: AssetHandler\n\n    /**\n     * @param {ECASContext} context Context object with configuration.\n     */\n    constructor(audioContext: AudioContext, ecasOptions: EcasOptions, eventHandler: EventHandler, assetHandler: AssetHandler, envelopeHandler: EnvelopeHandler) {\n        this.#audioContext = audioContext\n        this.#eventHandler = eventHandler\n        this.#assetHandler = assetHandler\n        this.#envelopeHandler = envelopeHandler\n        this.#options = ecasOptions\n        this.#soundConnections = {}\n        this.#elementSoundSources = {}\n        this.#soundContexts = {}\n        this.buses = new BusHandler(\n            this.#audioContext,\n            this.#assetHandler.soundHandler,\n            ecasOptions.soundConfig.buses\n        )\n    }\n\n    get audioContext () {\n        return this.#audioContext\n    }\n\n    get assetHandler () {\n        return this.#assetHandler\n    }\n\n    get elementSoundSources () {\n        return this.#elementSoundSources\n    }\n\n    //Needed for testing\n    get soundConnections () {\n        return this.#soundConnections\n    }\n\n    /**\n     * Get current time since sound context was started.\n     * @returns {number} Current time in seconds\n     * why is this function in the mixer????\n     */\n    now(): number {\n        return this.#audioContext.currentTime\n    }\n\n\n    /**\n     * Pause a sound.\n     * @param {string} id Id of sound to pause.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     */\n    pauseSound(id: Sound['id'], parentId = id) {\n        const contexts = this.#getSoundContexts(id, parentId)\n        const fullId = joinTimeoutCallers(id, parentId)\n\n        if (isNull(contexts)) {\n            return null\n        }\n        for (const ctx of contexts) {\n            if (ctx && !ctx.isPaused) {\n                ctx.startTimeSeconds = Utils.defaultNumber(ctx.startTimeSeconds)\n                ctx.currentTime = Utils.defaultNumber(ctx.currentTime)\n                const elapsed = (ctx.currentTime + (this.now() - ctx.startTimeSeconds)) % (this.#assetHandler.soundHandler.getDurationSeconds(id) / ctx.playbackRate)\n\n                ctx.currentTime = elapsed\n                ctx.isPaused = true\n                ctx.playing = false\n\n                this.#stopSoundSource(id, parentId, ctx.soundSource, ctx.bussId)\n                Timer.clearTimeout(fullId)\n\n                if (!ctx.isLoop) {\n                    Timer.clearTimeout(\n                        joinTimeoutCallers(\n                            fullId,\n                            TIMEOUT_CALLERS.STOP\n                        )\n                    )\n                    Timer.clearTimeout(\n                        joinTimeoutCallers(\n                            fullId,\n                            TIMEOUT_CALLERS.DEFAULT_STOP\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * Resume a paused sound.\n     * @param {string} id Id of sound to resume.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     */\n    resumeSound(id: string, parentId = id) {\n        const contexts: ISoundContext[] = this.#getSoundContexts(id, parentId)\n\n        if (contexts) {\n            for (const ctx of contexts) {\n                if (ctx && ctx.isPaused) {\n                    ctx.startTimeSeconds = this.now()\n                    this.connectSound(null, id, ctx, () => {\n                        this.playSound(id, ctx)\n                    })\n                }\n                else {\n                    logger().debug(`[ecas] unable to resume sound with sound id ${id}. sound was not paused`)\n                }\n            }\n        }\n    }\n\n    /**\n     * Play a sound.\n     *\n     * @param {string} id - Id of sound to play.\n     * @param {ISoundContext} context - Context for sound to play.\n     * @return {Promise<void>}\n     */\n    playSound(id: string, context: ISoundContext) {\n        const fullId = joinTimeoutCallers(id, context.parentId)\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Play, id, fullId)\n\n        if (isUndefined(context.parentId)) {\n            context.parentId = id\n        }\n        if (isUndefined(context.playbackRate)) {\n            context.playbackRate = 1\n        }\n\n        const startTimeSeconds = Utils.defaultNumber(context.startTimeSeconds)\n        const startPositionSeconds = context.currentTime || Utils.defaultNumber(context.startPos)\n        const delay = Utils.defaultNumber(context.delaySeconds)\n\n        context.durationSeconds = Utils.defaultNumber(context.durationSeconds)\n        const confDuration = context.durationSeconds ? context.durationSeconds : Number.POSITIVE_INFINITY\n        const soundDurationSeconds = (this.#assetHandler.soundHandler.getDurationSeconds(id) / context.playbackRate) - startPositionSeconds\n        const duration = context.isLoop ? undefined : Math.min(confDuration || Number.POSITIVE_INFINITY, soundDurationSeconds)\n\n        context.currentTime = startPositionSeconds\n        context.delaySeconds = delay ? delay : 0\n\n        // If the sound duration is less than configured duration, we handle ending the sound here,\n        // otherwise we will get the stop from sequencer.\n        if (!context.isLoop && !context.isScheduled && confDuration >= soundDurationSeconds) {\n            const endPositionSeconds = this.#audioContext.currentTime + soundDurationSeconds\n            const timeoutSeconds = soundDurationSeconds - TIME_LOOKAHEAD_SECONDS\n            Timer.setTimeout(\n                this.stopSound.bind(this, id, context.parentId, endPositionSeconds),\n                timeoutSeconds,\n                joinTimeoutCallers(\n                    fullId,\n                    TIMEOUT_CALLERS.DEFAULT_STOP\n                )\n            )\n        }\n\n        context.isPaused = false\n        this.createSourceNodeAndStartSource(id, context, duration, startTimeSeconds)\n    }\n\n    async createSourceNodeAndStartSource(id: string, soundContext: ISoundContext, durationSeconds: number, startTimeSeconds: number) {\n        const getAudioBuffer = async (reverse: boolean) => {\n            if (reverse) {\n                return this.assetHandler.soundHandler.getAudioBufferReversed(id)\n            }\n            return this.assetHandler.soundHandler.getAudioBuffer(id)\n        }\n\n        const audioBuffer = await getAudioBuffer(soundContext.reverse)\n        const sourceNode = getAudioBufferSourceNode(audioBuffer, this.#audioContext, soundContext)\n        playBufferSource(sourceNode, durationSeconds, startTimeSeconds, soundContext, id, this.#eventHandler, this.#audioContext)\n    }\n\n    /**\n     * Stop a sound.\n     * @param {string} id Id of sound to stop.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     * @param {number} when When to stop, as current position in seconds.\n     */\n    stopSound(id: Sound['id'], parentId = id, when = 0, onEnded?: string) {\n        logger().debug(`[ecas] stop sound ${id} at ${when} seconds with onEnded ${onEnded}`)\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Stop, id)\n\n        const contexts = this.#getSoundContexts(id, parentId)\n\n        if (contexts) {\n            contexts.forEach((ctx) => {\n                if (onEnded !== undefined) {\n                    ctx.onEnded = () => this.#eventHandler.triggerAudioEvent(onEnded)\n                }\n\n                this.#onCompleteSound(id, ctx, when)\n            })\n        }\n    }\n\n    /**\n     * Logs ID's of all of the currently playing sounds.\n     */\n    logActiveSounds() {\n        logger().log(this.getActiveSounds())\n    }\n\n    /**\n     * Gets a list of all of the currently playing sounds.\n     */\n    getActiveSounds(): string[] {\n        const active: string[] = []\n        for (const key of Object.keys(this.#soundContexts)) {\n            const contexts: ISoundContext[] = this.#soundContexts[key]\n            if (contexts) {\n                contexts.forEach((context: ISoundContext) => {\n                    active.push(context.id)\n                })\n            }\n        }\n        return active\n    }\n\n    /**\n     * Remove a sound from mixer.\n     *\n     * @param {string} id The individual id of the sound.\n     * @param {string} parentId Pool or group of the sound.\n     * @param {ISoundSource} soundSource The connected ISound.\n     * @param {string} bussId The id of the bus sound is connected to.\n     */\n    removeSound(id: string, parentId: string, soundSource: ISoundSource, bussId: string): void {\n        this.buses.purgeConnections(id, parentId, soundSource, bussId)\n        if (soundSource.source) {\n            soundSource.source.disconnect()\n            soundSource.source = null\n        }\n    }\n\n    buildAudioParamArray(targetId: BusConfig['id'] | Sound['id'], ctx: EnvelopeContext) {\n        if (!ctx.node) {\n            return createAudioParams({\n                targetId: targetId,\n                ...ctx,\n                getSoundContexts: this.#getSoundContexts.bind(this),\n                getSoundConnections: this.getSoundConnections.bind(this),\n                getBuss: this.buses.get.bind(this.buses)\n            })\n        }\n\n        const param = ctx.node[ctx.param]\n        return [param] as [AudioParam]\n    }\n\n    /**\n     * Play an envelope.\n     * @param {string} targetId Id of a bus or a sound.\n     * @param {IEnvelopeContext} context Context object with configuration.\n     */\n    playEnvelope(targetId: BusConfig['id'] | Sound['id'], context: Readonly<EnvelopeContext>): void {\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Play, targetId)\n\n        const envelopeContext: EnvelopeContext = createEnvelopeContext(context)\n        envelopeContext.parentId = context.parentId || targetId\n\n        if (envelopeContext.startTime === 0) {\n            envelopeContext.startTime = this.#audioContext.currentTime\n        }\n\n        const audioParamArray = this.buildAudioParamArray(targetId, envelopeContext)\n\n        //Naming? :|\n        const createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout = (passedAudioParam: AudioParam) => {\n            envelopeContext.audioParam = passedAudioParam\n            const originalAudioParamValue = passedAudioParam.value\n\n            const envelopeContexts = this.#envelopeHandler.getContexts(targetId)\n\n            // Store the provided context\n            envelopeContexts.push(envelopeContext)\n\n            // I don't know what this is for\n            if (isArrayNonEmpty(envelopeContexts)) {\n                const firstEnvelope = envelopeContexts[0]\n                const tid = createTimeoutCallerForPlayEnvelope({\n                    targetId: targetId,\n                    param: firstEnvelope.param,\n                    parentId: firstEnvelope.parentId,\n                    willStopSoundOnEnded: firstEnvelope.willStopSoundOnEnded\n                })\n                Timer.clearTimeout(tid)\n                passedAudioParam.cancelScheduledValues(0)\n            }\n\n            // Since resume operation modifies envelope to start from pause position\n            // we need to restore envelope to original state when playing back again\n            if (!envelopeContext.isPaused) {\n                envelopeContext.envelopePoints = createEnvelopePointsInOriginalState(envelopeContexts, envelopeContext.parentId)\n            }\n\n            const createRealValuesFromDefaultOrCurrent = () => {\n                // get real values out of default and current\n                return envelopeContext.envelopePoints.map(point => {\n                    if (point.val === \"default\") {\n                        return getDefaultValueFromSoundConfig({\n                            targetId: targetId,\n                            targetType: envelopeContext.type,\n                            targetParam: envelopeContext.param,\n                            soundConfig: this.#options.soundConfig,\n                            soundHandler: this.#assetHandler.soundHandler\n                        })\n                    }\n                    if (point.val === \"current\") {\n                        return originalAudioParamValue\n                    }\n                    return point.val\n                })\n            }\n\n            const values = createRealValuesFromDefaultOrCurrent()\n            const positions = envelopeContext.envelopePoints.map(point => point.pos)\n\n            // Calculate playbackRate if target parameter is pitch\n            if (envelopeContext.param === \"pitch\") {\n                for (let i = 0; i < values.length; i++) {\n                    values[i] = Utils.pitchToPlaybackRate(values[i])\n                }\n            }\n\n            const curve = createAutomationCurve({\n                values: values,\n                positions: positions,\n                curveType: envelopeContext.curveType\n            })\n\n            const totalDurationMilliSeconds = arraySum(envelopeContext.envelopePoints.map(point => point.pos))\n            const totalDurationSeconds = totalDurationMilliSeconds / 1000\n\n            passedAudioParam.cancelScheduledValues(envelopeContext.startTime) // if a previous envelope is still running we need to override that one\n\n            passedAudioParam.setValueCurveAtTime(curve, envelopeContext.startTime, totalDurationSeconds)\n\n            // Seems like unless you specify at least a frame worth of delay, timeout will trigger before envelope completed\n            // Since the onEnded callback and value update is not really timing critical, it should be safe to add some margin.\n            const safety = 0.05\n\n            Timer.setTimeout(\n                () => {\n                    if (envelopeContext.onplay) {\n                        envelopeContext.onplay()\n                    }\n                    this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Start, targetId)\n                },\n                envelopeContext.startTime + safety,\n                joinTimeoutCallers(targetId, TIMEOUT_CALLERS.ENVELOPE_SCHEDULED, \"START\")\n            )\n\n            Timer.setTimeout(\n                () => {\n                    if (this.#audioContext.state === \"suspended\") {\n                        return\n                    }\n\n                    if (envelopeContext.onEnded) {\n                        this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Ended, targetId)\n                        callOnEnded(envelopeContext.onEnded, this.#eventHandler)\n                    }\n\n                    this.#envelopeHandler.setContexts({\n                        id: targetId,\n                        contexts: envelopeContexts.filter((val) => envelopeContext.parentId !== val.parentId)\n                    })\n                },\n                totalDurationSeconds + safety,\n                createTimeoutCallerForPlayEnvelope({\n                    targetId: targetId,\n                    param: envelopeContext.param,\n                    parentId: envelopeContext.parentId,\n                    willStopSoundOnEnded: context.willStopSoundOnEnded\n                })\n            )\n        }\n\n        if (context.isAFadeIn) createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout(audioParamArray[audioParamArray.length - 1])\n        else for (const audioParam of audioParamArray) {\n            createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout(audioParam)\n        }\n    }\n\n    connect(src: AudioNode, dst: AudioNode) {\n        src.connect(dst)\n    }\n\n    getSoundParam (soundId: Sound['id'], param: keyof Sound) {\n        const sound: Sound = this.#assetHandler.soundHandler.getSound(soundId)\n        return sound[param]\n    }\n\n    getSoundConnections(id: Sound['id']): ISoundNodes[] {\n        if (!exists(this.#soundConnections[id])) {\n            logger().warn(\"[ecas] no sound connections found for id\", id, \"in\", this.#soundConnections)\n        }\n        return this.#soundConnections[id] || []\n    }\n\n    stopAll({onEnded}: {onEnded?: string} = {}) {\n        Object.values(this.#soundContexts)\n            .forEach(\n                (contexts) => {\n                    contexts\n                        .forEach(\n                            (ctx: ISoundContext) => {\n                                this.stopSound(ctx.id, ctx.parentId, 0, onEnded)\n                            }\n                        )\n                }\n            )\n    }\n\n    dispose() {\n        this.stopAll()\n        this.buses.dispose()\n    }\n\n    /**\n     * Connect a source to mixer.\n     *\n     * @param {AudioNode} sourceNode The AudioNode to connect. From an HTMLMediaElement or buffer source.\n     * @param {string} id The id of the sound to connect.\n     * @param {ISoundContext} context Sound context for the sound to connect.\n     * @param {Function} cb Callback invoked with the index of the input connected to if successful.\n     */\n    connectSound(sourceNode: SourceAudioNode, id: string, soundContext: ISoundContext, cb: (connection: IConnection) => void = noop) {\n        if (!exists(sourceNode)) {\n            sourceNode = this.#audioContext.createBufferSource()\n        }\n\n        // Signal flow as follows:\n        // element -> panNode -> gainNode -> bus -> audioContext\n        const gainNode = this.#audioContext.createGain()\n\n        const panValue = isDefined(soundContext.pan)\n            ? clamp(Utils.randomizeValues(soundContext.pan), -1, 1)\n            : 0\n\n        const panNode = createPanNode(this.#audioContext, panValue)\n\n        sourceNode.disconnect()\n        sourceNode.connect(panNode)\n        panNode.connect(gainNode)\n        gainNode.connect(this.buses.get(soundContext.bussId).input)\n\n        const inputs = this.buses.getBusConnections(soundContext.bussId).inputs\n        const inputIndex = inputs.length\n        const nodeId = Utils.generateUniqueId(id)\n        const connection: IConnection = {\n            index: inputIndex,\n            node: gainNode,\n            nodeId,\n            soundContext: soundContext,\n            isUsed: true\n        }\n\n        inputs.push(connection)\n\n        const volume = isDefined(soundContext.volume)\n            ? clamp(Utils.randomizeValues(soundContext.volume), MIN_GAIN_LINEAR, MAX_GAIN_LINEAR)\n            : 1\n\n        gainNode.gain.value = volume\n\n        const caller = joinTimeoutCallers(id, soundContext.parentId)\n\n        this.#soundConnections[caller] = Utils.defaultValue(this.#soundConnections[caller], [])\n        this.#soundConnections[caller].push({\n            context: soundContext,\n            audioEffectNodes: [],\n            pannerNode: panNode,\n            gainNode: gainNode,\n            sourceNode: sourceNode,\n            nodeId\n        })\n\n        this.#soundContexts[id] = Utils.defaultValue(this.#soundContexts[id], [])\n        soundContext.parentId = Utils.defaultValue(soundContext.parentId, id)\n        // Avoid duplicating context when it comes to resume\n        if (!soundContext.isPaused) {\n            this.#soundContexts[id].push(soundContext)\n        }\n        const index = Object.keys(this.#soundContexts).length\n        soundContext.soundSource = { source: sourceNode, index }\n        cb(connection)\n    }\n\n\n    #onCompleteSound(id: string, context: ISoundContext, when: number) {\n        const combinedId = joinTimeoutCallers(context.id, context.parentId)\n\n        this.#stopSoundSource(id, context.parentId, context.soundSource, context.bussId, when)\n\n        Timer.clearTimeout(combinedId)\n\n        if (!context.isLoop) {\n            Timer.clearTimeout(joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.STOP))\n            Timer.clearTimeout(joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.DEFAULT_STOP))\n        }\n\n        this.#soundContexts[id] = this.#soundContexts[id].filter((ctx) => ctx.parentId !== context.parentId)\n\n        Timer.setTimeout(\n            () => {\n                if (context.onEnded) {\n                    this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Ended, id)\n                    callOnEnded(context.onEnded, this.#eventHandler)\n                }\n            },\n            when - this.now(),\n            joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.SOUND_COMPLETE)\n        )\n    }\n\n    /**\n     * Stop a sound source.\n     * @param {string} id Id of sound to stop.\n     * @param {string} parentId Id of sound parent (pattern or pool id).\n     * @param {string} type Type of sound (element or buffer)\n     * @param {ISoundSource} soundSource Source of sound to stop.\n     * @param {string} bussId bus ID of the sound to stop.\n     * @param {number} when Global position when sound should stop.\n     * @private\n     */\n    #stopSoundSource(id: Sound['id'], parentId: Sound['id'], soundSource: ISoundSource, bussId: BusConfig['id'], when = 0) {\n        const combinedId = joinTimeoutCallers(id, parentId)\n\n        const connections = this.#soundConnections[combinedId]\n        const node = soundSource.source as AudioBufferSourceNode\n\n        //Is this just to check if it's really the correct type? Because now it always is\n        const isSoundSourceParams = soundSource && node && node.buffer && node.stop\n\n        const checkEffectAndDisconnect = (connection: ISoundNodes) => {\n            this.#disconnectNodes(connection, id, parentId, soundSource, bussId)\n        }\n\n        //Is soundSource.source enough or do you need to check for just soundSource too?\n        if (isSoundSourceParams) {\n            try {\n                node.stop(when)\n\n                if (connections) {\n                    connections.forEach(checkEffectAndDisconnect)\n                }\n                delete this.#soundConnections[combinedId]\n            }\n\n            catch (err) {\n                logger().error(err)\n            }\n        }\n    }\n\n    #disconnectNodes (connectionNode: ISoundNodes, id: string, parentId: string, soundSource: ISoundSource, bussId: string) {\n        this.removeSound(id, parentId, soundSource, bussId)\n\n        connectionNode.pannerNode.disconnect()\n        connectionNode.gainNode.disconnect()\n        connectionNode.sourceNode.disconnect()\n\n        if (connectionNode.audioEffectNodes) {\n            connectionNode.audioEffectNodes.forEach((effect) => {\n                effect.node.disconnect()\n            })\n        }\n    }\n\n    /**\n     * Get sound contexts for a sound.\n     * @param {string} id Id of sound to find contexts for.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence).\n     * @returns {ISoundContext[]}  Array with sound contexts for found sounds.\n     * @private\n     */\n    #getSoundContexts(id: string, parentId: string): ISoundContext[] {\n        const contexts = this.#soundContexts[id]\n        if (!contexts) {\n            return null\n        }\n        return contexts.filter((context: ISoundContext) => context.parentId === parentId)\n    }\n}\n", "import { logger, type LoggerName } from \"@netent-tech/ecas-logger\"\nimport { type PartialProperties } from \"@netent-tech/ecas-utils\"\nimport { getPrefferedFileExtension } from \"../asset-handler/formats\"\nimport { AudioFileExtension, EncoderSettings, FormatPreset, ILoadrConfig, Sound } from \"@netent-tech/ecas-common\"\n\nfunction iOS14() {\n    return typeof(navigator) !== 'undefined'\n        && navigator.userAgent !== undefined\n        && navigator.userAgent.match(/like Mac OS X/) !== null\n        && navigator.userAgent.match(/OS 14/) !== null\n}\nexport class LoadrConfig implements ILoadrConfig {\n    /** @deprecated */\n    forceLegacy = false\n    forcePolyfills = {}\n    packageToUse = \"desktop\"\n    fileExtToUse: AudioFileExtension\n    initState?: string\n    /** true will load all sounds, array of strings will load those specified sounds */\n    preload: boolean | Sound['id'][] = false\n    soundData: Map<string, number> = new Map<string, number>()\n    pauseOnInvisible = true\n    muteOnInvisible = !iOS14()\n    resumeOnVisible = true\n    unmuteOnVisible = true\n    logger: LoggerName = 'none'\n    /**\n     * if these game events where triggered before AudioContext was unlocked, the will fire once it is unlocked.\n     * So if game sends a \"start-main-music\" event before AudioContext could be started (due to no user interaction)\n     * then that event will be queued and fired on the first user interaction.\n     * use true to queue all events\n     * use an array of gameEvent names to queue only those events\n     */\n    queue: true | string[] = true\n    constructor(formatPresets: FormatPreset[], props: PartialProperties<LoadrConfig> & {soundData?: Map<string, number>}= { }) {\n        Object.assign(this, props)\n        this.soundData = new Map(props.soundData)\n        const availableFileExtensions = getAvailableFileExtensions(formatPresets)\n        this.fileExtToUse = props.fileExtToUse || getPrefferedFileExtension(availableFileExtensions)\n        if (!availableFileExtensions.includes(this.fileExtToUse)) {\n            logger().error('[ecas] fileExtToUse:', this.fileExtToUse, 'is not available.')\n        }\n    }\n}\n\n/* To see what files will actually exist after encoding (depending on what the settings were in soundconfig) */\nfunction getAvailableFileExtensions(formatPresets: FormatPreset[]) {\n    const exts = formatPresets.map(\n        formatPreset => formatPreset.presets.map(\n            encoderPreset => encoderPreset.formats.map(\n                encoderSettings => encoderSettings.format))).flat().flat().flat().map(\n        fmt => encoderSettingFormatToFileExtension(fmt))\n    return [...new Set(exts)]\n}\n\nfunction encoderSettingFormatToFileExtension (fmt: EncoderSettings['format']): AudioFileExtension {\n    return `.${fmt}` as AudioFileExtension\n}\n", "import { SoundConfig, EventConfig, IEcasOptions, StateConfig } from \"@netent-tech/ecas-common\"\nimport { LoadrConfig } from \"./LoadrConfig\"\n\n/** Takes partial options and creates defaults for everything that is not defined. */\nexport class EcasOptions implements IEcasOptions {\n    soundConfig: SoundConfig\n    eventConfig: EventConfig\n    stateConfig: StateConfig\n    loadrConfig: LoadrConfig\n\n    constructor (options: IEcasOptions = { soundConfig: new SoundConfig(), loadrConfig: { packageToUse: \"desktop\" } }) {\n        this.soundConfig = new SoundConfig(options.soundConfig)\n        this.eventConfig = options.eventConfig || []\n        this.stateConfig = options.stateConfig || { genesis: { activatesOn: [], deactivatesOn: [], events: {}, children: {}, } }\n        this.loadrConfig = new LoadrConfig(this.soundConfig.settings.formatPresets, options.loadrConfig as Partial<LoadrConfig> & {soundData?: Map<string, number>})\n    }\n}\n\nexport function createEcasOptions(options?: IEcasOptions) {\n    return new EcasOptions(options)\n}\n", "import { noop } from \"@netent-tech/ecas-utils\"\nimport { IPlaySoundArgs, isMusicalPosition } from \"@netent-tech/ecas-common\"\nimport { Utils } from \"../utils\"\n\nexport class PlaySoundArgs implements Required<IPlaySoundArgs> {\n    volume = 1\n    pitch = 0\n    pan = 0\n    /** in seconds */\n    startTime = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    /** in seconds */\n    duration = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    /** in seconds */\n    startPos = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    loop = false\n    args = []\n    onended = noop\n    onplay = noop\n    /** in milliseconds */\n    fadeIn = 0\n    /** in milliseconds */\n    fadeOut = 0\n    reverse = false\n\n    constructor(options: IPlaySoundArgs) {\n        Object.assign(this, options)\n\n        // if these are random arrays we get select a random number from the array\n        this.volume = Utils.randomizeValues(options.volume) ?? 1\n        this.pitch = Utils.randomizeValues(this.pitch) ?? 0\n        this.pan = Utils.randomizeValues(this.pan) ?? 0\n\n        // bar.beat.tick strings is handled in sequencer, so only default numeric time based values..\n        if (!isMusicalPosition(this.startTime)) {\n            this.startTime = Utils.defaultNumber(this.startTime) / 1000\n        }\n        if (!isMusicalPosition(this.duration)) {\n            this.duration = Utils.defaultNumber(this.duration) / 1000\n        }\n        if (!isMusicalPosition(this.startPos)) {\n            this.startPos = Utils.defaultNumber(this.startPos) / 1000\n        }\n    }\n}\n", "import { isNumber } from '@netent-tech/ecas-utils'\nimport { IStopSoundArgs } from \"@netent-tech/ecas-common\"\n\nexport class StopSoundArgs implements Omit<Required<IStopSoundArgs>, \"onEnded\"> {\n    /** in seconds, millisec in ISoptSoundArgs  */\n    delay = 0\n    fadeOut = 1\n    onEnded?: string\n\n    constructor(options: IStopSoundArgs = {}) {\n        if (isNumber(options.fadeOut)) {\n            this.fadeOut = options.fadeOut\n        }\n        if (isNumber(options.delay)) {\n            this.delay = options.delay / 1000\n        }\n        this.fadeOut = Math.max(this.fadeOut, 1)\n        this.onEnded = options.onEnded\n    }\n\n}\n", "export class AnalyserConfig {\n    mode: string\n    minDb: number\n    maxDb: number\n    fftSize: number\n    smoothingTimeConstant: number\n\n    /**\n     * Configure analyzer.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode for more information on parameters.\n     *\n     * @param {string} mode \"frequency\" for capturing frequency domain data, and \"time\" for time domain data.\n     * @param {number} minDb Minimum power value in scaling range when in frequency mode. Value greater than maxDb throws INDEX_SIZE_ERR.\n     * @param {number} maxDb Maximum power value in scaling range when in frequency mode.\n     * @param {number} fftSize Size of the FFT when in frequency mode.\n     * @param {number} smoothingTimeConstant Smooth values over time. Must be in the range 0 to 1.\n     */\n    constructor(mode = \"time\", minDb = -100, maxDb = -30, fftSize = 2048, smoothingTimeConstant = 0.8) {\n        this.mode = mode\n        this.minDb = minDb\n        this.maxDb = maxDb\n        this.fftSize = fftSize\n        this.smoothingTimeConstant = smoothingTimeConstant\n    }\n}\n", "import { noop } from \"@netent-tech/ecas-utils\"\n\ninterface IOverInfo {\n    over: boolean,\n    lastOver: number\n}\n\ninterface IVolumeMeterCallbackData {\n    volume: {\n        left: number,\n        right: number\n    },\n    clipping: {\n        left: boolean,\n        right: boolean\n    }\n}\n\nexport class VolumeMeter {\n    private _callback: (data: IVolumeMeterCallbackData) => void\n    private _volumes: number[] = []\n    private _overInfos: IOverInfo[] = []\n    private _averaging = 0.95\n    // It is custom in audio software to show signals as over when exceeding 1, also when working with busses summed using floating point samples.\n    // However, note that in floating point a value above 1 does not mean a clipped signal, except if the signal reaches the DAC without further scaling (going through another bus like master, or in the OS).\n    private _overLevel = 0.71\n    private _overLag = 750\n    private _processor: ScriptProcessorNode | null\n\n    /**\n     * Create a volume meter.\n     *\n     * @param {number} smoothingTimeConstant Time in seconds for the value to fall back.\n     * @param {Function} callback\n     */\n    constructor(smoothingTimeConstant = 0.6, callback: (data: any) => void = noop) {\n        this._callback = callback\n        this._averaging = smoothingTimeConstant\n        this._init()\n    }\n\n    create(ctx: AudioContext) {\n        this._processor = ctx.createScriptProcessor(512)\n        this._processor.onaudioprocess = this._volumeAudioProcess.bind(this)\n        this._processor.connect(ctx.destination)\n        return this._processor\n    }\n\n    destroy() {\n        if (this._processor !== null) {\n            this._processor.disconnect()\n            this._processor.onaudioprocess = null\n            this._processor = null\n        }\n        this._volumes = []\n        this._overInfos = []\n    }\n\n    private _init() {\n        this._volumes = [0, 0]\n        this._overInfos = [{over: false, lastOver: 0}, {over: false, lastOver: 0}]\n    }\n\n    private _volumeAudioProcess(event: AudioProcessingEvent) {\n        const lastL = this._volumes[0]\n        const lastR = this._volumes[1]\n        this._volumes[0] = 0\n        this._volumes[1] = 0\n        const processChannel = (input: AudioBuffer, index: number) => {\n            const buffer: Float32Array = input.getChannelData(index)\n            const bufferLength = buffer.length\n            if ((this._overInfos[index].lastOver + this._overLag) < window.performance.now()) {\n                this._overInfos[index].over = false\n            }\n            const squaredSum = buffer.reduce((a, b) => a + b * b)\n            const frameVal = Math.sqrt(squaredSum / bufferLength)\n            if (frameVal >= this._overLevel) {\n                this._overInfos[index].over = true\n                this._overInfos[index].lastOver = window.performance.now()\n            }\n            this._volumes[index] = (this._averaging > 0) ? Math.max(frameVal, this._volumes[index] * this._averaging) : frameVal\n        }\n        processChannel(event.inputBuffer, 0)\n        processChannel(event.inputBuffer, 1)\n        const currL = this._volumes[0]\n        const currR = this._volumes[1]\n        if ((lastL !== currL || lastR !== currR) && currL >= 0 && currR >= 0) {\n            this._callback({\n                volume: {left: currL, right: currR},\n                clipping: {left: this._overInfos[0].over, right: this._overInfos[1].over},\n            })\n        }\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { defineProperty, hasOwnProperty } from \"@netent-tech/ecas-utils\"\n\ntype LegacyAudioParam = Omit<AudioParam, \"cancelAndHoldAtTime\" | \"automationRate\">\n\ntype LegacyAudioParamVar = {\n    new (): LegacyAudioParam\n    prototype: LegacyAudioParam\n}\n\n\nexport function audioParamPolyfill(global: {\n    AudioParam?: LegacyAudioParamVar,\n}) {\n    const paramPrototype = global.AudioParam.prototype\n    if (!hasOwnProperty(paramPrototype, 'cancelAndHoldAtTime') && hasOwnProperty(paramPrototype, \"cancelScheduledValues\")) {\n        logger().debug(\"[polyfill]: (AudioParam) installing cancelAndHoldAtTime\")\n        defineProperty(paramPrototype, \"cancelAndHoldAtTime\", {value: paramPrototype.cancelScheduledValues})\n    }\n\n    /** This doesnt actually make the rate anything but won't give you error when trying to set the rate */\n    if (!hasOwnProperty(paramPrototype, 'automationRate')) {\n        logger().debug(\"[polyfill]: (AudioParam) installing automationRate\")\n        defineProperty(paramPrototype, \"automationRate\", {value: \"a-rate\"}) // \"a-rate\" | \"k-rate\"\n    }\n}\n", "import { ignoreUnused } from \"@netent-tech/ecas-utils\"\nimport { defineProperty, hasOwnProperty } from '@netent-tech/ecas-utils'\n\nexport function stereoPannerNodePolyfill(global = window) {\n    const prototype = global.AudioContext.prototype\n    class StereoPannerNodeMockup {\n        _input: GainNode\n        _output: GainNode\n        context: BaseAudioContext\n        pan: AudioParam\n        channelCount = 2\n        channelCountMode: ChannelCountMode = \"clamped-max\"\n        channelInterpretation: ChannelInterpretation = \"speakers\"\n        numberOfInputs = 1\n        numberOfOutputs = 1\n        addEventListener = () => void 0\n        dispatchEvent = () => void 0\n        removeEventListener = () => void 0\n        constructor(context: AudioContext, options: StereoPannerOptions = { pan: 0 }) {\n            this.context = context\n            this._input = this.context.createGain()\n            this._output = this.context.createGain()\n            let panValue = options.pan\n            const splitter = this.context.createChannelSplitter(2)\n            const gainL1 = this.context.createGain()\n            const gainL2 = this.context.createGain()\n            const gainR1 = this.context.createGain()\n            const gainR2 = this.context.createGain()\n            const mergerL = this.context.createChannelMerger(2)\n            const mergerR = this.context.createChannelMerger(2)\n            const merger = this.context.createChannelMerger(2)\n            this._input.connect(splitter)\n            splitter.connect(gainL1, 0)\n            splitter.connect(gainL2, 0)\n            splitter.connect(gainR1, 1)\n            splitter.connect(gainR2, 1)\n            gainL1.connect(mergerL, 0, 0)\n            gainR2.connect(mergerL, 0, 0)\n            gainR1.connect(mergerR, 0, 1)\n            gainL2.connect(mergerR, 0, 1)\n            mergerL.connect(merger, 0, 0)\n            mergerR.connect(merger, 0, 1)\n            merger.connect(this._output)\n            this.pan = {\n                get value() {\n                    return panValue\n                },\n                set value(value) {\n                    gainL1.gain.value = 1 - Math.max(value, 0)\n                    gainR2.gain.value = -Math.min(value, 0)\n                    gainR1.gain.value = 1 + Math.min(value, 0)\n                    gainL2.gain.value = Math.max(value, 0)\n                    panValue = value\n                },\n                get automationRate () {\n                    return \"a-rate\" as const\n                },\n                get defaultValue() {\n                    return 0\n                },\n                get maxValue() {\n                    return 1\n                },\n                get minValue() {\n                    return 0\n                },\n                cancelAndHoldAtTime: (cancelTime: number) => {\n                    ignoreUnused(cancelTime)\n                    return this.pan\n                },\n                cancelScheduledValues: (cancelTime: number) => {\n                    ignoreUnused(cancelTime)\n                    return this.pan\n                },\n                exponentialRampToValueAtTime: (value: number, endTime: number) => {\n                    ignoreUnused(endTime)\n                    this.pan.value = value\n                    return this.pan\n                },\n                linearRampToValueAtTime: (value: number, endTime: number) => {\n                    ignoreUnused(endTime)\n                    this.pan.value = value\n                    return this.pan\n                },\n                setTargetAtTime: (target: number, startTime: number, timeConstant: number) => {\n                    ignoreUnused(startTime, timeConstant)\n                    this.pan.value = target\n                    return this.pan\n                },\n                setValueAtTime: (target: number, startTime: number) => {\n                    ignoreUnused(startTime)\n                    this.pan.value = target\n                    return this.pan\n                },\n                setValueCurveAtTime: (values: number[] | Float32Array, startTime: number, duration: number) => {\n                    ignoreUnused(startTime, duration)\n                    this.pan.value = Number(values[0])\n                    return this.pan\n                },\n            }\n            this.pan.value = panValue\n        }\n        isStereoPannerNode = true\n\n        connect(...args: any): any {\n            return this._output.connect.apply(this._output, args)\n        }\n        disconnect(...args: any): any {\n            return this._output.disconnect.apply(this._output, args)\n        }\n        toString() {\n            return \"StereoPannerNode\" as const\n        }\n\n    }\n\n    function createStereoPannerNode(ctx: AudioContext, options?: StereoPannerOptions) {\n        return new StereoPannerNodeMockup(ctx, options)\n    }\n\n    defineProperty(prototype, \"createStereoPanner\", {\n        value: function (this: AudioContext, options?: StereoPannerOptions) {\n            return createStereoPannerNode(this, options)\n        },\n        // enumerable: false, writable: false, configurable: true\n    })\n\n    const _connect = global.AudioNode.prototype.connect as Connect\n\n    defineProperty(global.AudioNode.prototype, \"connect\", {value: function (destination: AudioNode | AudioParam, output?: number, input?: number) {\n        function isStereoPannerNode (thing: object): thing is StereoPannerNodeMockup {\n            return hasOwnProperty(thing, \"isStereoPannerNode\") && thing.isStereoPannerNode === true\n        }\n        if (isStereoPannerNode(destination)) {\n            destination = destination._input\n        }\n        return _connect.call(this, destination, output || 0, input || 0)\n    }})\n\n}\ntype Connect = ((destination: AudioNode | AudioParam, output?: number, input?: number) => AudioNode | void)\n", "import { defineProperty, hasOwnProperty } from \"@netent-tech/ecas-utils\"\n/** Converted to typescript by joel */\n\n/* Copyright 2013 Chris Wilson\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n\n/*\nThis monkeypatch library is intended to be included in projects that are\nwritten to the proper AudioContext spec (instead of webkitAudioContext),\nand that use the new naming and proper bits of the Web Audio API (e.g.\nusing BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may\nhave to run on systems that only support the deprecated bits.\nThis library should be harmless to include if the browser supports\nunprefixed \"AudioContext\", and/or if it supports the new names.\nThe patches this library handles:\nif window.AudioContext is unsupported, it will be aliased to webkitAudioContext().\nif AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or\nnoteGrainOn(), depending on parameters.\nThe following aliases only take effect if the new names are not already in place:\nAudioBufferSourceNode.stop() is aliased to noteOff()\nAudioContext.createGain() is aliased to createGainNode()\nAudioContext.createDelay() is aliased to createDelayNode()\nAudioContext.createScriptProcessor() is aliased to createJavaScriptNode()\nAudioContext.createPeriodicWave() is aliased to createWaveTable()\nOscillatorNode.start() is aliased to noteOn()\nOscillatorNode.stop() is aliased to noteOff()\nOscillatorNode.setPeriodicWave() is aliased to setWaveTable()\nAudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()\nThis library does NOT patch the enumerated type changes, as it is\nrecommended in the specification that implementations support both integer\nand string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel\nBiquadFilterNode.type and OscillatorNode.type.\n*/\ntype WebkitAudioContext = Omit<AudioContext, \"createGain\" | \"createDelay\" | \"createScriptProcessor\" | \"createPeriodicWave\"> & {\n    createGainNode: typeof AudioContext.prototype.createGain,\n    createDelayNode: typeof AudioContext.prototype.createDelay,\n    createJavaScriptNode: typeof AudioContext.prototype.createScriptProcessor,\n    createWaveTable: typeof AudioContext.prototype.createPeriodicWave\n}\n\ntype WebkitAudioContextVar = {\n    new (contextOptions?: AudioContextOptions): WebkitAudioContext;\n    prototype: WebkitAudioContext\n}\n\nexport function webkitAudioContextPolyfill(global: {\n    webkitAudioContext?: WebkitAudioContextVar,\n    AudioContext?: typeof AudioContext,\n}) {\n    if (!global.webkitAudioContext) {\n        throw Error(\"[polyfill]: cannot install webkitAudioContext polyfill since webkitAudioContext does not exist on global.\")\n    }\n    function fixSetTarget(param?: AudioParam & { setTargetValueAtTime?: AudioParam['setTargetAtTime'] }) {\n        if (!param) {\n            return\n        }\n        if (!param.setTargetAtTime) {\n            defineProperty(param, \"setTargetAtTime\", { value: param.setTargetValueAtTime })\n        }\n    }\n\n    const prototype = global.webkitAudioContext.prototype\n\n    if (!hasOwnProperty(prototype, 'createScriptProcessor')) {\n        defineProperty(prototype, \"createScriptProcessor\", { value: prototype.createJavaScriptNode } as const)\n    }\n    if (!hasOwnProperty(prototype, 'createPeriodicWave')) {\n        defineProperty(prototype, \"createPeriodicWave\", { value: prototype.createWaveTable } as const)\n    }\n    if (!hasOwnProperty(prototype, 'createGain')) {\n        defineProperty(prototype, \"createGain\", { value: function(this: typeof prototype) {\n            const node = this.createGainNode()\n            fixSetTarget(node.gain)\n            return node\n        }})\n    }\n\n    if (!hasOwnProperty(prototype, 'createDelay')) {\n        defineProperty(prototype, \"createDelay\", {\n            value: function(this: typeof prototype, maxDelayTime?: number) {\n                const node = this.createDelayNode(maxDelayTime)\n                fixSetTarget(node.delayTime)\n                return node\n            }\n        })\n    }\n\n    defineProperty(prototype, \"internal_createBufferSource\", { value: prototype.createBufferSource })\n    prototype.createBufferSource = function() {\n        const node = this.internal_createBufferSource() as AudioBufferSourceNode & {\n            noteGrainOn: AudioBufferSourceNode['start']\n            noteOn: AudioBufferSourceNode['start']\n            noteOff: AudioBufferSourceNode['stop']\n        }\n        if (!node.start) {\n            node.start = function(when?, offset?, duration?) {\n                if (offset || duration)\n                    this.noteGrainOn(when || 0, offset, duration)\n                else\n                    this.noteOn(when || 0)\n            }\n        }\n        else {\n            defineProperty(node, \"internal_start\", {value: node.start})\n            node.start = function(when?, offset?, duration?) {\n                node.internal_start(when || 0, offset || 0, duration)\n            }\n        }\n        if (!node.stop) {\n            node.stop = function(when?) {\n                this.noteOff(when || 0 )\n            }\n        }\n        else {\n            defineProperty(node, \"internal_stop\", {value: node.stop})\n            node.stop = function(when?) {\n                node.internal_stop(when || 0)\n            }\n        }\n        fixSetTarget(node.playbackRate)\n        return node\n    }\n\n    defineProperty(prototype, \"internal_createDynamicsCompressor\", {value: prototype.createDynamicsCompressor})\n    prototype.createDynamicsCompressor = function() {\n        const node = this.internal_createDynamicsCompressor()\n        fixSetTarget(node.threshold)\n        fixSetTarget(node.knee)\n        fixSetTarget(node.ratio)\n        fixSetTarget(node.reduction as unknown as AudioParam) // not sure if this should be done ^^\n        fixSetTarget(node.attack)\n        fixSetTarget(node.release)\n        return node\n    }\n\n    defineProperty(prototype, \"internal_createBiquadFilter\", {value: prototype.createBiquadFilter})\n    prototype.createBiquadFilter = function() {\n        const node = this.internal_createBiquadFilter()\n        fixSetTarget(node.frequency)\n        fixSetTarget(node.detune)\n        fixSetTarget(node.Q)\n        fixSetTarget(node.gain)\n        return node\n    }\n\n    if (hasOwnProperty(prototype, 'createOscillator' )) {\n        defineProperty(prototype, \"internal_createOscillator\", {value: prototype.createOscillator})\n        prototype.createOscillator = function() {\n            const node = this.internal_createOscillator() as OscillatorNode & {\n                noteOn: OscillatorNode['start']\n                noteOff: OscillatorNode['stop']\n                setWaveTable: OscillatorNode['setPeriodicWave']\n            }\n            if (!node.start) {\n                node.start = function (when?) {\n                    this.noteOn(when || 0)\n                }\n            }\n            else {\n                defineProperty(node, \"internal_start\", {value: node.start})\n                node.start = function (when?) {\n                    node.internal_start(when || 0)\n                }\n            }\n            if (!node.stop) {\n                node.stop = function (when?) {\n                    this.noteOff(when || 0)\n                }\n            }\n            else {\n                defineProperty(node, \"internal_stop\", {value: node.stop})\n                node.stop = function(when?) {\n                    node.internal_stop(when || 0)\n                }\n            }\n            if (!node.setPeriodicWave)\n                node.setPeriodicWave = node.setWaveTable\n            fixSetTarget(node.frequency)\n            fixSetTarget(node.detune)\n            return node\n        }\n    }\n\n    // decodeAudioData is a promise nowadays\n    defineProperty(prototype, \"internal_decodeAudioData\", {value: prototype.decodeAudioData})\n    prototype.decodeAudioData = function(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback, errorCallback?: DecodeErrorCallback ) {\n        return new Promise<AudioBuffer>((resolve, reject) => {\n            this.internal_decodeAudioData(\n                audioData,\n                (decodedData) => {\n                    successCallback && successCallback(decodedData)\n                    resolve(decodedData)\n                },\n                (error) => {\n                    errorCallback && errorCallback(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    defineProperty(global, \"AudioContext\", {value: global.webkitAudioContext})\n\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { defineProperty, trySync } from \"@netent-tech/ecas-utils\"\nimport { audioParamPolyfill } from \"./audio-param-polyfill\"\nimport { stereoPannerNodePolyfill } from \"./stereo-panner-node-polyfill\"\nimport { webkitAudioContextPolyfill } from \"./webkit-audio-context-polyfill\"\n\nexport interface IForcePolyfill {\n    AudioParam?: boolean\n    webkitAudioContext?: boolean\n    webkitOfflineAudioContext?: boolean\n    createStereoPanner?: boolean\n}\n\nfunction install(Force: IForcePolyfill, global = window) {\n\n    \n    const Has = {\n        AudioParam: 'AudioParam' in global,\n        AudioContext: 'AudioContext' in global,\n        OfflineAudioContext: 'OfflineAudioContext' in global,\n        webkitAudioContext: 'webkitAudioContext' in global,\n        webkitOfflineAudioContext: 'webkitOfflineAudioContext' in global,\n        createStereoPanner: (\n            'AudioContext' in global && \"createStereoPanner\" in global.AudioContext.prototype\n        ) || 'webkitAudioContext' in global && 'createStereoPanner' in (global as any)['webkitAudioContext']\n    } as const\n\n    const ShouldInstall: IForcePolyfill = {\n        AudioParam: Force.AudioParam || Has.AudioParam,\n        webkitAudioContext: Force.webkitAudioContext || Has.webkitAudioContext && !Has.AudioContext,\n        webkitOfflineAudioContext: Force.webkitOfflineAudioContext || Has.webkitOfflineAudioContext && !Has.OfflineAudioContext,\n        createStereoPanner: Force.createStereoPanner || !Has.createStereoPanner,\n    } as const\n\n    logger().debug(\"[polyfill]:\", Has)\n\n    const tryer = (cb: (global: typeof window) => void) => {\n        const [error, ] = trySync(cb)(global)\n        if (error) {\n            logger().error(error)\n        }\n        return !error\n    }\n\n    const DidInstall: IForcePolyfill = {\n        // needs to have at least legacy AudioParam for us to be able to install\n        AudioParam: ShouldInstall.AudioParam && tryer(() => {\n            logger().debug(\"[polyfill]: installing AudioParam\")\n            audioParamPolyfill(global)\n        }),\n        webkitAudioContext: ShouldInstall.webkitAudioContext && tryer(() => {\n            logger().debug(\"[polyfill]: installing webkitAudioContext\")\n            webkitAudioContextPolyfill(global)\n        }),\n        webkitOfflineAudioContext: ShouldInstall.webkitOfflineAudioContext && tryer(() => {\n            logger().debug(\"[polyfill]: installing webkitOfflineAudioContext\")\n            defineProperty(global, \"OfflineAudioContext\", {value: global['webkitOfflineAudioContext']})\n        }),\n        createStereoPanner: ShouldInstall.createStereoPanner && tryer(() => {\n            logger().debug(\"[polyfill]: installing createStereoPanner\")\n            stereoPannerNodePolyfill(global)\n        }),\n    }\n\n    return DidInstall\n}\nexport { install }\n\n", "import { IForcePolyfill, install } from \"./install\"\n\nexport function polyfill(force: IForcePolyfill = {}) {\n    return install(force)\n}\n", "import { ISoundContext } from \"@netent-tech/ecas-common\"\nimport {isNumber} from '@netent-tech/ecas-utils'\n\nexport class AudioScheduler {\n    private _timeProvider: () => number\n    private _interval: number\n    private _intervalId: number\n    private _scheduled: IScheduled[] = []\n\n    constructor(timeProvider: () => number, interval = 0.03) {\n        this._timeProvider = timeProvider\n        this._interval = interval\n        this._intervalId = window.setInterval(this._update.bind(this), interval * 1000)\n    }\n\n    get intervalId() {\n        return this._intervalId\n    }\n\n    public scheduleSound(soundContext: ISoundContext, callback?: (id: string, context: ISoundContext) => void) {\n        this._scheduled.push({context: soundContext, callback})\n        this._update()\n    }\n\n    public cancelScheduledSound(soundContext: ISoundContext) {\n        this._scheduled = this._scheduled\n            .filter((scheduled) => !(scheduled.context.id === soundContext.id && scheduled.context.parentId === soundContext.parentId))\n    }\n\n    /** event loop, if the time until the event is less than the interval, the callback is executed */\n    private _update() {\n        const now = this._timeProvider()\n        this._scheduled = this._scheduled.filter((scheduled: IScheduled) => {\n            const ctx = scheduled.context\n            ctx.startTimeSeconds = isNumber(ctx.startTimeSeconds) ? ctx.startTimeSeconds : 0\n            const timeUntilEvent = ctx.startTimeSeconds - now\n            if (timeUntilEvent <= this._interval) {\n                scheduled.callback(ctx.id, ctx)\n                return false\n            }\n            return true\n        })\n    }\n}\n\ninterface IScheduled {\n    context: ISoundContext;\n    callback: (id: string, context: ISoundContext) => void;\n}\n", "import { ITempoConfig } from \"@netent-tech/ecas-common\"\n\nexport function calculateSecondsPerBeat(tempoConfig: ITempoConfig): number {\n    return 60 / (tempoConfig.tempo / ((1 / tempoConfig.timeSignature.unit) * 4))\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { clone, exists, isFunction, isNumber, isNumeric, isString, isUndefined, noop, Writeable } from \"@netent-tech/ecas-utils\"\nimport { AssetHandler } from \"../asset-handler\"\nimport { DEFAULT_CROSSFADE_MILLISECONDS, TIMEOUT_CALLERS, TIME_LOOKAHEAD_SECONDS } from \"../constants\"\nimport { EnvelopePreset, IPlayPatternArgs, IPlayPoolArgs, IPoolMap, ISequenceEvent, ISoundContext, ISoundsConfig, IStringMap, ITempoConfig, ITimeSignature, MusicalPositionOrNumber, Pattern, Pool, PoolItem, Sound } from \"@netent-tech/ecas-common\"\nimport { createPlayEnvelopeArgs, EnvelopeContext, isPlayEnvelopeArgs, PlayEnvelopeArgs } from \"../envelopes\"\nimport { EventHandler } from \"../event-handler\"\nimport { Mixer } from \"../mixer\"\nimport { EcasOptions } from \"../options-creator\"\nimport { PlaySoundArgs } from \"../options-creator/PlaySoundArgs\"\nimport { StopSoundArgs } from \"../options-creator/StopSoundArgs\"\nimport { AudioScheduler } from \"../scheduling/AudioScheduler\"\nimport { createTimeoutCallerForPlayEnvelope, joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Timer } from \"../scheduling/Timer\"\nimport { Utils } from \"../utils\"\nimport { createTimeSignatureFromString } from \"../utils/beats\"\nimport { calculateSecondsPerBeat as milliSecondsPerBeatFromTempoConfig } from \"./tempo\"\n\nexport class Sequencer {\n    #audioScheduler: AudioScheduler\n    #patternItemsCompleted: IStringMap<number>\n    #eventQueue: ISequenceEvent[]\n    #poolQueue: IStringMap<PoolItem[]>\n    #poolPointer: IStringMap<number>\n    #poolCounter: IStringMap<IPoolMap>\n    #playingSoundsPerGroup: IStringMap<ISoundContext[]>\n    /** A map with <Sound['id'], currently playing instances of that sound> */\n    #currentlyPlayingSoundInstancesWithThisSoundId: IStringMap<ISoundContext[]>\n    #playingSoundsPerPool: IStringMap<string[]>\n    #playingPoolItems: IStringMap<PoolItem[]>\n    #playingPatternItems: IStringMap<Pattern[]>\n    #playingPools: IStringMap<number>\n    #pausedPools: IStringMap<boolean>\n    #pausedPatterns: IStringMap<boolean>\n    #playingPatternArgs: IStringMap<IPlayPatternArgs>\n    #playingPoolArgs: IStringMap<IPlayPoolArgs>\n    #scheduledSoundContexts: IStringMap<ISoundContext>\n    #triggerLimitPerGroup: IStringMap<number>\n    #triggerLimitPerSoundSeconds: IStringMap<number>\n    //#scheduledGrouplimitFadesSeconds: IStringMap<number>\n\n    #timeOutIdCounter = new Map<string, number>()\n\n    #options: EcasOptions\n    #mixer: Mixer\n    #eventHandler: EventHandler\n    #assetHandler: AssetHandler\n\n    #tempoConfig: ITempoConfig = {timeSignature: {meter: 4, unit: 4}, triggerQuantize: 1}\n\n    /**\n     * @param {ECASContext} context Context object with configuration.\n     * @param {Function} initCallback Callback invoked when setup of mixer is complete of fails.\n     */\n    constructor (\n        options: EcasOptions,\n        mixer: Mixer,\n        eventHandler: EventHandler,\n        assetHandler: AssetHandler,\n    ) {\n        this.#mixer = mixer\n        this.#eventHandler = eventHandler\n        this.#assetHandler = assetHandler\n\n        this.#patternItemsCompleted = {}\n        this.#eventQueue = []\n        this.#playingSoundsPerGroup = {}\n        this.#currentlyPlayingSoundInstancesWithThisSoundId = {}\n        this.#playingSoundsPerPool = {}\n        this.#playingPoolItems = {}\n        this.#playingPatternItems = {}\n        this.#playingPools = {}\n        this.#pausedPools = {}\n        this.#pausedPatterns = {}\n        this.#playingPatternArgs = {}\n        this.#playingPoolArgs = {}\n        this.#triggerLimitPerGroup = {}\n        this.#scheduledSoundContexts = {}\n        this.#triggerLimitPerSoundSeconds = {}\n        //this.#scheduledGrouplimitFadesSeconds = {}\n\n        this.#options = options\n        this.#tempoConfig = {\n            triggerQuantize: options.soundConfig.settings.triggerQuantize,\n            timeSignature: {\n                meter: 4,\n                unit: 4\n            }\n        }\n        this.#audioScheduler = new AudioScheduler(this.#mixer.now.bind(this.#mixer), TIME_LOOKAHEAD_SECONDS)\n        this.#setupPools(this.#options.soundConfig.pools)\n        setInterval(this.#onUpdate.bind(this), TIME_LOOKAHEAD_SECONDS)\n    }\n\n    setTempo(newTempo: number) {\n        this.#tempoConfig.tempo = newTempo\n    }\n\n    setTimeSignature(newTimeSignature: ITimeSignature) {\n        this.#tempoConfig.timeSignature = newTimeSignature\n    }\n\n    setTriggerQuantize(newTriggerQuantize: number) {\n        this.#tempoConfig.triggerQuantize = newTriggerQuantize\n    }\n\n    /**\n     * Used to trigger a sound.\n     *\n     * @param {string} id Id of sound to trigger.\n     * @param {IPlaySoundArgs} playSoundArgs Arguments to pass when playing sound.\n     * @param {string} parentId Id of parent playing sound (pattern or pool).\n     * @param {boolean} isTimeRelative If true, startTime is not including current time.\n     * @param {boolean} isScheduled If true, treat as scheduled looped sound (will loop even if args.loop is false)\n     */\n    playSound(id: string, playSoundArgs: PlaySoundArgs, parentId = id, isTimeRelative = true, isScheduled = false) {\n        logger().debug(\n            '[ecas] play sound',\n            'id:', id,\n            'args:', playSoundArgs,\n            'parent:', parentId,\n            'relativeTime:', isTimeRelative,\n            'isScheduled:', isScheduled\n        )\n\n        const nowSeconds = this.#mixer.now()\n\n        // duration and startime is in seconds here\n        const { volume, pan, loop, pitch, reverse, duration: durationArgSeconds, startPos, startTime: startTimeSeconds, args } = playSoundArgs\n\n        const newStartTimeSeconds = isTimeRelative\n            ? startTimeSeconds + nowSeconds\n            : startTimeSeconds\n\n        const delaySeconds = Math.max(newStartTimeSeconds - nowSeconds, 0)\n        const shouldPlayLater = delaySeconds >= TIME_LOOKAHEAD_SECONDS\n\n        // Perhaps we run this method schedule this method proper at a later time if should play later.\n        if (shouldPlayLater) {\n            if (!this.#timeOutIdCounter.has(id)) {\n                this.#timeOutIdCounter.set(id, 0)\n            }\n            this.#timeOutIdCounter.set(id, this.#timeOutIdCounter.get(id) + 1)\n\n            Timer.setTimeout(\n                () => {\n                    playSoundArgs.startTime = newStartTimeSeconds\n                    const isTimeRelativeFalse = false as const\n                    this.playSound(id, playSoundArgs, parentId, isTimeRelativeFalse)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS, // we checked that delaySeconds >= TIME_LOOKAHEAD_SECONDS so will not be negative\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    this.#timeOutIdCounter.get(id).toString()\n                )\n            )\n            return\n        }\n\n        const sound = this.#assetHandler.soundHandler.getSound(id)\n        const groupId = sound.group\n        const type = sound.type\n        const bussId = this.#assetHandler.getGroup(groupId).bus\n        const playbackRate = Utils.pitchToPlaybackRate(pitch)\n        const soundFileDuration = this.#assetHandler.soundHandler.getDurationSeconds(id)\n        const soundFiledurationAdjustedForPlaybackRateSeconds = (soundFileDuration - startPos) / playbackRate\n        const stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound = joinTimeoutCallers(\n            id,\n            \"\",\n            TIMEOUT_CALLERS.STOP\n        )\n        let finalDurationSeconds = soundFiledurationAdjustedForPlaybackRateSeconds\n\n        if (durationArgSeconds > 0) {\n            finalDurationSeconds = durationArgSeconds\n        }\n\n        if(Timer.hasTimeout(stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound)) Timer.clearTimeout(stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound)\n\n        // first we clear timeout and stop sound, then we stop sound again?\n        this.#clearTimeoutAndStopSound(id, parentId)\n\n        // determine if same sound triggers more than group limit vallue defined.\n        // if same sound triggers and exceeds the groupLimit, then stop that sound and play again.\n        // Determine if same sound is playing in the background and hasnt been stopped.\n        // If so, stop previous sound and play again\n        const soundContext: ISoundContext = {\n            id,\n            bussId,\n            volume,\n            pan,\n            isPaused: false,\n            isLoop: loop,\n            type,\n            startTimeSeconds: newStartTimeSeconds,\n            durationSeconds: finalDurationSeconds,\n            startPos,\n            currentTime: 0,\n            parentId,\n            group: this.#assetHandler.getGroup(groupId),\n            onEnded: () => this.#callOnEnded(playSoundArgs.onended),\n            onSourceNodeEnded: () => {\n                const groupSoundItems = this.#playingSoundsPerGroup[groupId]\n                const index = groupSoundItems.map(item => item.id).indexOf(id)\n                    \n                groupSoundItems.splice(index, 1)\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id].shift()\n            },\n            delaySeconds,\n            pitch,\n            playbackRate,\n            reverse,\n            args: args,\n            fadeIn: playSoundArgs.fadeIn,\n            fadeOut: playSoundArgs.fadeOut,\n            isScheduled: isScheduled,\n        }\n\n        this.#handleTriggerLimits(sound, id)\n        this.#mixer.connectSound(null, id, soundContext)\n        this.#scheduledSoundContexts[id + parentId] = soundContext\n\n        this.#audioScheduler.scheduleSound(\n            soundContext,\n            () => {\n                const onplay = [playSoundArgs.onplay]\n                const shouldFadeIn = playSoundArgs.fadeIn > 0\n\n                if (shouldFadeIn) {\n                    const context = new EnvelopeContext({\n                        curveType: \"s-curve\",\n                        startTime: nowSeconds,\n                        isAFadeIn: true,\n                        param: \"volume\",\n                        type: \"sound\",\n                        envelopePoints: [\n                            { pos: 0, val: 0 },\n                            { pos: playSoundArgs.fadeIn, val: playSoundArgs.volume }\n                        ]\n                    })\n                    const fadeinCallback = () => {\n                        this.#mixer.playEnvelope(id, context)\n                    }\n\n                    onplay.push(fadeinCallback)\n                }\n\n                const shouldStop = finalDurationSeconds < soundFiledurationAdjustedForPlaybackRateSeconds && !loop\n\n                if (shouldStop) {\n                    const stopCallback = () => {\n                        const isDefaultStop = true as const\n                        this.stopSound(\n                            id,\n                            new StopSoundArgs({\n                                delay: finalDurationSeconds * 1000 - playSoundArgs.fadeOut,\n                                fadeOut: playSoundArgs.fadeOut\n                            }),\n                            parentId,\n                            isDefaultStop,\n                        )\n                    }\n\n                    // add a fadeout to be triggered with delay, after sound has started playing\n                    onplay.push(stopCallback)\n                }\n\n                this.#playScheduledContext(\n                    sound,\n                    soundContext,\n                    nowSeconds,\n                    onplay,\n                )\n            }\n        )\n    }\n\n    #clearTimeoutAndStopSound (id: string, parentId: string) {\n        const overlappingTimeoutCallers = [\n            joinTimeoutCallers(id, parentId, TIMEOUT_CALLERS.STOP),\n            joinTimeoutCallers(id, TIMEOUT_CALLERS.VOLUME, parentId, TIMEOUT_CALLERS.STOP),\n        ]\n\n        for (const caller of overlappingTimeoutCallers) {\n            if (Timer.hasTimeout(caller)) {\n                Timer.clearTimeout(caller)\n                this.stopSound(\n                    id,\n                    new StopSoundArgs(),\n                    parentId\n                )\n            }\n        }\n    }\n\n    #handleTriggerLimits (sound: Sound, id: string) {\n        const groupId = sound.group\n        const group = this.#assetHandler.getGroup(groupId)\n\n        if (group.limit > 0 && this.#playingSoundsPerGroup[groupId]) {\n            const groupSoundItems = this.#playingSoundsPerGroup[groupId]\n            const playingSoundInstances = this.#currentlyPlayingSoundInstancesWithThisSoundId[id]\n            const isCrossedLimit = groupSoundItems.length >= group.limit\n\n            if (isCrossedLimit) {\n                const first: ISoundContext = groupSoundItems[0]\n\n                if (first.soundSource.source) {\n                    groupSoundItems.shift()\n                    playingSoundInstances.shift()\n                    Timer.clearTimeout(createTimeoutCallerForPlayEnvelope({targetId: id, param: \"volume\", parentId: id, willStopSoundOnEnded: true}))\n\n                    if (first.isFadingOut) return\n\n                    else {\n                        (first.soundSource.source as AudioBufferSourceNode).onended = noop;\n                        (first.soundSource.source as AudioBufferSourceNode).stop()\n                        return\n                    }\n                }\n            }\n\n            //Does it ever reach this? Should it?\n            else if (\n                this.#currentlyPlayingSoundInstancesWithThisSoundId &&\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] &&\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id].length >= group.limit\n            ) {\n                const first = playingSoundInstances[0]\n\n                groupSoundItems.shift()\n                playingSoundInstances.shift();\n\n                (first.soundSource.source as AudioBufferSourceNode).onended = noop;\n                (first.soundSource.source as AudioBufferSourceNode).stop()\n            }\n        }\n    }\n\n    /**\n     * Adds the connected sound context to schedule list\n     *\n     * @param {ISound} sound Sound that was connected through the mixer.\n     * @param {ISoundContext} soundContext The context that the sound was connected and scheduled.\n     * @param {IConnection} connection The resulting connection reported by the mixer.\n     * @returns void\n     */\n    #playScheduledContext(sound: Sound, soundContext: ISoundContext, whenSeconds: number, onplay = [noop]) {\n        this.#scheduledSoundContexts[soundContext.id + soundContext.parentId] = null\n\n        const id = soundContext.id\n        const group = soundContext.group\n        const groupId = group.id\n        const delaySeconds = Utils.defaultNumber(soundContext.delaySeconds)\n\n        if (group.triggerLimit) {\n            const lastGroupTriggerLimitPos = this.#triggerLimitPerGroup[groupId] ? this.#triggerLimitPerGroup[groupId] : 0\n\n            const triggerLimitElapsedSeconds = this.#mixer.now() - lastGroupTriggerLimitPos\n            const triggerLimitRemainingSeconds = group.triggerLimit / 1000 - triggerLimitElapsedSeconds\n\n            if (triggerLimitElapsedSeconds < 0 || triggerLimitRemainingSeconds > 0) {\n                logger().debug(\n                    \"[ecas] group triggerLimit reached\",\n                    \"triggerLimitElapsed\", triggerLimitElapsedSeconds,\n                    \"triggerLimitRemain\", triggerLimitRemainingSeconds\n                )\n                return\n            }\n\n            this.#triggerLimitPerGroup[groupId] = whenSeconds + delaySeconds\n        }\n\n        if (sound.triggerLimit) {\n            const lastSoundTriggerLimitPos = this.#triggerLimitPerSoundSeconds[id] ? this.#triggerLimitPerSoundSeconds[id] : 0\n            const triggerLimitElapsedSeconds = whenSeconds - lastSoundTriggerLimitPos\n            const triggerLimitRemainingSeconds = sound.triggerLimit / 1000 - triggerLimitElapsedSeconds\n\n            if (triggerLimitElapsedSeconds < 0 || triggerLimitRemainingSeconds > 0) {\n                logger().debug('[ecas] sound triggerLimit reached')\n                return\n            }\n\n            this.#triggerLimitPerSoundSeconds[id] = whenSeconds + delaySeconds\n        }\n\n        if (group.limit && group.limit > 0) {\n            if (this.#currentlyPlayingSoundInstancesWithThisSoundId[id] == null) {\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] = []\n            }\n\n            if (this.#playingSoundsPerGroup[groupId] == null) {\n                this.#playingSoundsPerGroup[groupId] = []\n            }\n\n            this.#currentlyPlayingSoundInstancesWithThisSoundId[id].push(soundContext)\n            this.#playingSoundsPerGroup[groupId].push(soundContext)\n        }\n\n        if (isUndefined(group.crossfade)) {\n            group.crossfade = DEFAULT_CROSSFADE_MILLISECONDS\n        }\n\n        /* const isNumberOfSimultaneouslyPlayingSoundsInGroupOverLimit =\n            this.#playingSoundsPerGroup[groupId]\n            && this.#playingSoundsPerGroup[groupId].length > group.limit\n\n        if (isNumberOfSimultaneouslyPlayingSoundsInGroupOverLimit) {\n            this.#crossfadeSoundsInGroup(soundContext)\n            return\n        } */\n\n        // schedulePlaySound(soundContext, id, soundContext.startTimeSeconds / 1000, this.#mixer)\n        Timer.setTimeout(\n            () => {\n                this.#mixer.playSound(id, soundContext)\n                for (const cb of onplay) {\n                    cb() // used for example for fadein / fadeout envelopes\n                }\n            },\n            // note: previously was ```(startTime - mixer.now()) / 1000```\n            // but why divide mixer.now() with 1000 when mixer.now gives result in seconds?\n            soundContext.startTimeSeconds - this.#mixer.now(),\n            TIMEOUT_CALLERS.MIXER_PLAY_SOUND\n        )\n    }\n\n    /* #crossfadeSoundsInGroup(soundContext: ISoundContext) {\n        const group = soundContext.group\n        const groupId = group.id\n        const targetVolume = getTargetVolume(soundContext.volume)\n\n        function getTargetVolume(vol: ValueOrRandom) {\n            if (isArray(vol)) {\n                return Utils.randomizeValues(soundContext.volume)\n            }\n            // vol cannot become a string here but ValueOrRandom type think it might but it's not possible\n            return vol as number\n        }\n\n        const firstIn = this.#playingSoundsPerGroup[groupId].shift()\n\n        if (firstIn.id !== soundContext.id) {\n            scheduleMixerPlaySound(soundContext, soundContext.id, soundContext.startTimeSeconds, this.#mixer)\n\n            const nowSeconds = this.#mixer.now()\n            const scheduledFadesSeconds = this.#scheduledGrouplimitFadesSeconds[groupId] || nowSeconds\n            const remainingTimeSeconds = scheduledFadesSeconds - nowSeconds\n\n            this.#scheduledGrouplimitFadesSeconds[groupId] = nowSeconds + (group.crossfade / 1000)\n\n            if (remainingTimeSeconds > 0) {\n                Timer.setTimeout(\n                    () => playCrossFadeEnvelopes(),\n                    remainingTimeSeconds + 5, // I think this number might be for safety as to not remove the the caller to early but idk\n                    joinTimeoutCallers(\n                        firstIn.id,\n                        firstIn.parentId\n                    )\n                )\n                return\n            }\n\n            const playCrossFadeEnvelopes = (fadeTime: number = DEFAULT_CROSSFADE_MILLISECONDS) => {\n                // we fade in the new sound, I think\n                const fadeInEnvelopePoints: IEnvelopePoint[] = []\n                fadeInEnvelopePoints.push({pos: 0, val: 0})\n                fadeInEnvelopePoints.push({pos: fadeTime, val: targetVolume})\n                this.#mixer.playEnvelope(\n                    firstIn.id,\n                    new EnvelopeContext({\n                        parentId: firstIn.parentId,\n                        param: \"volume\",\n                        envelopePoints: [\n                            {pos: 0, val: \"current\"},\n                            {pos: fadeTime, val: 0}\n                        ],\n                        type: \"sound\"\n                    })\n                )\n\n                // we fade out the old sound, I think\n                this.#mixer.playEnvelope(\n                    soundContext.id,\n                    new EnvelopeContext({\n                        parentId: soundContext.parentId,\n                        param: \"volume\",\n                        envelopePoints: fadeInEnvelopePoints,\n                        type: \"sound\"\n                    })\n                )\n\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[firstIn.id] = []\n            }\n\n            const crossFadeNow = () => {\n                playCrossFadeEnvelopes(group.crossfade)\n                // stop the sound after the fadeout has happened\n                Timer.setTimeout(\n                    () => {\n                        this.stopSound(\n                            firstIn.id,\n                            new StopSoundArgs(),\n                            firstIn.parentId\n                        )\n                        this.#currentlyPlayingSoundInstancesWithThisSoundId[firstIn.id] = []\n                    },\n                    group.crossfade / 1000,\n                    joinTimeoutCallers(\n                        firstIn.id,\n                        firstIn.parentId,\n                        TIMEOUT_CALLERS.SOUND_STOP,\n                        TIMEOUT_CALLERS.CROSSFADE\n                    )\n                )\n            }\n\n            crossFadeNow()\n        }\n    } */\n\n    /**\n     * Used to trigger a Pool.\n     *\n     * @param {string} id Id of Pool to trigger.\n     * @param {IPlayPoolArgs} args Argument to use when playing pool.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    playPool(id: string, args: IPlayPoolArgs = {}, parentId = id): void {\n        const now = this.#mixer.now()\n        const startTime = Utils.defaultNumber(args.startTime, 0, this.#tempoConfig, now)\n        // default poolIndex is set to null if we dont set startItem\n        const poolIndex = args.startItem\n\n        if (this.#playingPools[id + parentId] === undefined) {\n            this.#playingPools[id + parentId] = 0\n        }\n\n        this.#playingPools[id + parentId]++\n\n        if (startTime > 0) {\n            Timer.setTimeout(\n                () => {\n                    args.startTime = 0\n                    this.playPool(id, args, parentId)\n                },\n                startTime,\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.POOL_PLAY,\n                    Number(this.#playingPools[id + parentId]).toString()\n                )\n            )\n\n            return\n        }\n\n        this.#poolCounter[id + parentId] = Utils.defaultValue(this.#poolCounter[id + parentId], {counter: 0, poolItems: []})\n\n        if (isNumber(poolIndex) && !this.setPoolIndex(id, poolIndex)) {\n            return\n        }\n\n        const item = this.#getItemFromPool(id, args.reset)\n\n        if (!item) {\n            logger().warn(\"[ecas] unable to play pool '\" + id + \"'.\")\n            return\n        }\n\n        item.type = Utils.defaultValue(item.type, \"sound\")\n\n        //This object sucks, fix\n        //Made it to avoid passing too many arguemnts to this._playSoundInPool\n        const commonPoolParams = {\n            startPos: Utils.defaultNumber(args.startPos, 0, this.#tempoConfig, 0),\n            argsDur: Utils.defaultNumber(args.duration, 0, this.#tempoConfig, 0),\n            itemDuration: isNumeric(item.duration) ? item.duration / 1000 : Utils.defaultNumber(item.duration, 0, this.#tempoConfig, 0),\n            itemDelay: isNumeric(item.delay) ? item.delay / 1000 : Utils.defaultNumber(item.delay, 0, this.#tempoConfig, now),\n            itemStartPos: isNumeric(item.startPos) ? item.startPos / 1000 : Utils.defaultNumber(item.startPos, 0, this.#tempoConfig, 0),\n            itemVolume: Utils.sumVolume(item.volume, Utils.defaultNumber(args.volume, 1)),\n            itemPan: Utils.sumPan(item.pan, args.pan),\n            itemPitch: Utils.sumPitch(item.pitch, args.pitch)\n        }\n\n        let duration = Math.min(commonPoolParams.argsDur || Number.MAX_VALUE, commonPoolParams.itemDuration || Number.MAX_VALUE)\n        duration = duration === Number.MAX_VALUE ? 0 : duration\n        duration += startTime\n\n        commonPoolParams.itemDelay = Utils.sumPos(commonPoolParams.itemDelay, startTime)\n        commonPoolParams.itemStartPos = Utils.sumPos(commonPoolParams.itemStartPos, commonPoolParams.startPos)\n        commonPoolParams.itemDuration = duration ? Math.min(duration, commonPoolParams.itemDuration) : commonPoolParams.itemDuration\n\n        if (duration) {\n            const timeoutId = id + parentId + TIMEOUT_CALLERS.POOL_STOP\n\n            Timer.setTimeout(\n                () => this.stopPool(id),\n                duration,\n                timeoutId\n            )\n        }\n\n        switch(item.type) {\n            case \"sound\":\n                this.#playSoundInPool(id, parentId, commonPoolParams, item, args)\n                break\n\n            case \"pool\": {\n                const playPoolArgs: IPlayPoolArgs = {\n                    volume: commonPoolParams.itemVolume,\n                    pan: commonPoolParams.itemPan,\n                    loop: item.loop || args.loop,\n                    startTime: commonPoolParams.itemDelay,\n                    startPos: commonPoolParams.itemStartPos,\n                    pitch: commonPoolParams.itemPitch,\n                    onEnded: () => this.#patternPoolOnEnded(args, item, id, parentId),\n                    duration: commonPoolParams.itemDuration,\n                }\n\n                this.playPool(item.target, playPoolArgs, id)\n                break\n            }\n            case \"pattern\": {\n                const playPatternArgs: IPlayPatternArgs = {\n                    startTime: commonPoolParams.itemDelay,\n                    startPos: commonPoolParams.itemStartPos,\n                    onEnded: () => this.#patternPoolOnEnded(args, item, id, parentId),\n                    duration: commonPoolParams.itemDuration,\n                }\n\n                this.playPattern(item.target, playPatternArgs, id)\n                break\n            }\n            default:\n                break\n        }\n\n        // TODO: Should we not accept envelopes here?\n        this.#playingPoolItems[id + parentId] = Utils.defaultValue(this.#playingPoolItems[id + parentId], [])\n        this.#playingPoolItems[id + parentId].push(item)\n        this.#playingPoolArgs[id + parentId] = args\n    }\n\n    #patternPoolOnEnded (args: IPlayPoolArgs, item: PoolItem, id: string, parentId: string) {\n        if (args.onItemEnded) {\n            this.#callOnEnded(args.onItemEnded)\n        }\n\n        this.#poolEndedCb(item.target, id, parentId)\n    }\n\n    #playSoundInPool (id: string, parentId: string, commonParams: any, item: PoolItem, playPoolArgs: IPlayPoolArgs = {}) {\n        const pool = this.#assetHandler.getPool(id)\n        const itemVolume = Utils.sumVolume(item.volume, Utils.defaultNumber(playPoolArgs.volume, 1))\n        const itemPan = Utils.sumPan(item.pan, playPoolArgs.pan)\n        const itemPitch = Utils.sumPitch(item.pitch, playPoolArgs.pitch)\n\n        const playSoundArgs = new PlaySoundArgs({\n            volume: itemVolume,\n            pan: itemPan,\n            loop: item.loop || playPoolArgs.loop,\n            pitch: itemPitch,\n            onended: () => {\n                if (this.#poolCounter[id + parentId]) {\n                    this.#poolCounter[id + parentId].counter--\n\n                    if (this.#poolCounter[id + parentId].counter === 0) {\n                        this.#poolCounter[id + parentId].poolItems.forEach((val) => {\n                            if (val.onEnded) {\n                                this.#callOnEnded(val.onEnded)\n                            }\n                        })\n                        this.#poolCounter[id + parentId].poolItems = []\n                    }\n                }\n                Timer.clearTimeout(item.target + \"_\" + id)\n\n                if (playPoolArgs.onItemEnded) {\n                    this.#callOnEnded(playPoolArgs.onItemEnded)\n                }\n\n                this.#poolEndedCb(item.target, id, parentId)\n            },\n            startTime: commonParams.itemDelay,\n            startPos: commonParams.itemStartPos,\n            duration: commonParams.itemDuration,\n        })\n\n        let poolItems = this.#playingSoundsPerPool[id]\n\n        if (!poolItems) {\n            poolItems = []\n        }\n\n        const overLimit = poolItems.length >= pool.limit\n\n        if (overLimit) {\n            const firstIn = poolItems.shift()\n            this.stopSound(firstIn, null, id)\n        }\n\n        poolItems.push(item.target)\n        this.#poolCounter[id + parentId].counter++\n        this.#poolCounter[id + parentId].poolItems.push(playPoolArgs)\n\n        this.playSound(item.target, playSoundArgs, id)\n        this.#playingSoundsPerPool[id] = poolItems\n    }\n\n    #poolEndedCb = (target: string, id: string, parentId: string) => {\n        if (this.#playingPoolItems[id + parentId]) {\n            this.#playingPoolItems[id + parentId] = this.#playingPoolItems[id + parentId].filter((val) => val.target !== target)\n        }\n\n        this.#playingPools[id + parentId]--\n    }\n\n    /**\n     * Reset the sound pool index to 0.\n     *\n     * @param id Id of a Pool to play.\n     */\n    resetPool(id: string) {\n        if (!this.#assetHandler.hasPool(id)) {\n            logger().warn(\"[ecas] unable to reset pool with id '\" + id + \"'.\")\n            return\n        }\n        this.#poolPointer[id] = 0\n    }\n\n\n\n    /**\n     * Play an envelope.\n     *\n     * @param {string} target Path to bus or effect using ids concatenated with \".\" For example \"bus1\", \"bus1.effect1\", \"bus1.aux1\".\n     * @param {IPlayEnvelopeArgs} playEnvelopeArgs Arguments to use when playing envelope.\n     * @param {string} parentId Id of pattern which triggered envelope. Omit if directly triggered.\n     */\n    playEnvelope(target: string, playEnvelopeArgs: PlayEnvelopeArgs, parentId?: string): void {\n        const nowSeconds = this.#mixer.now()\n        const scheduledTimeSeconds = Utils.defaultNumber(playEnvelopeArgs.startTime, 0, this.#tempoConfig, nowSeconds)\n        const isDelayed = scheduledTimeSeconds > (nowSeconds + TIME_LOOKAHEAD_SECONDS)\n\n        const playLater = () => {\n            const timeoutId = joinTimeoutCallers(\n                parentId,\n                TIMEOUT_CALLERS.ENVELOPE_SCHEDULED,\n                target\n            )\n            Timer.setTimeout(\n                () => {\n                    this.playEnvelope(target, playEnvelopeArgs, parentId)\n                },\n                scheduledTimeSeconds - (nowSeconds + TIME_LOOKAHEAD_SECONDS),\n                timeoutId\n            )\n        }\n\n        if (isDelayed) {\n            playLater()\n            return\n        }\n\n        const envelopeContext = new EnvelopeContext({\n            startTime: scheduledTimeSeconds,\n            param: playEnvelopeArgs.param,\n            curveType: playEnvelopeArgs.curveType,\n            type: playEnvelopeArgs.type,\n            onEnded: playEnvelopeArgs.onEnded,\n            onplay: playEnvelopeArgs.onplay,\n            willStopSoundOnEnded: playEnvelopeArgs.willStopSoundOnEnded,\n            envelopePoints: playEnvelopeArgs.envelopePoints as Writeable<typeof playEnvelopeArgs.envelopePoints>,\n            parentId: parentId,\n        })\n\n        if (playEnvelopeArgs.type === \"sound\") {\n            this.#mixer.playEnvelope(target, envelopeContext)\n        }\n        // Fixme: implement playEnvelope for inserts / effects\n    }\n\n    /**\n     * Stop a sound.\n     *\n     * @param {string} id Id of sound to stop.\n     * @param {IStopSoundArgs} stopSoundArgs Arguments to pass when playing sound.\n     * @param {string} parentId Id of parent pattern or pool. Omit if directly triggered.\n     */\n    stopSound(id: string, stopSoundArgs: StopSoundArgs, parentId?: string, isDefaultStop?: boolean): void {\n        logger().debug(\"[ecas] stopping sound: \", id)\n        this.#assetHandler.soundHandler.getSound(id)\n\n        if(stopSoundArgs.delay) {\n            const playing = this.#playingSoundsPerGroup[this.#assetHandler.soundHandler.getSound(id).group]\n            playing?.forEach((sound: ISoundContext) => {\n                sound.isStoppingSoon = true\n            })\n        }\n\n        else if(stopSoundArgs.fadeOut) {\n            const playing = this.#playingSoundsPerGroup[this.#assetHandler.soundHandler.getSound(id).group]\n            playing?.forEach((sound: ISoundContext) => {\n                sound.isFadingOut = true\n            })\n        }\n\n        const delaySeconds =  Utils.defaultNumber(stopSoundArgs.delay, 0, this.#tempoConfig, this.#mixer.now())\n        const whenSeconds = this.#mixer.now() + delaySeconds\n\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                const caller = joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    i.toString()\n                )\n                Timer.clearTimeout(caller)\n\n                // dont understand how it could exist since we just cleared it\n                if (Timer.hasTimeout(caller) && !delaySeconds) {\n                    Timer.resume(caller)\n                }\n            }\n\n            this.#timeOutIdCounter.set(id, 0)\n        }\n\n        if (delaySeconds > 0) {\n            this.#stopSoundWithFadeOrRenameTimeout(delaySeconds, stopSoundArgs, id, parentId, isDefaultStop, whenSeconds)\n        }\n\n        else {\n            this.#cancelOrStopSound(stopSoundArgs, id, parentId, whenSeconds)\n        }\n\n        this.#purgePlayingSound(id, parentId)\n    }\n\n    #stopSoundWithFadeOut (stopSoundArgs: StopSoundArgs, id: string, parentId: string, whenSeconds: number) {\n        const envelopeArgs = createPlayEnvelopeArgs({\n            type: \"sound\",\n            param: \"volume\",\n            startTime: 0,\n            envelopePoints: [\n                {pos: 0, val: \"current\"},\n                {pos: stopSoundArgs.fadeOut, val: 0}\n            ],\n            curveType: \"logarithmic\",\n            onEnded: () => {\n                const sound = this.#assetHandler.soundHandler.getSound(id)\n\n                this.#mixer.stopSound(\n                    id,\n                    parentId,\n                    whenSeconds + stopSoundArgs.fadeOut / 1000,\n                    stopSoundArgs.onEnded\n                )\n\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] = []\n                this.#playingSoundsPerGroup[sound.group] = this.#playingSoundsPerGroup[sound.group].filter(item => item.id !== sound.id)\n            },\n            willStopSoundOnEnded: true\n        })\n\n        this.playEnvelope(id, envelopeArgs, parentId)\n    }\n\n    #stopSoundWithFadeOrRenameTimeout (delaySeconds: number, stopSoundArgs: StopSoundArgs, id: string, parentId: string, isDefaultStop: boolean, whenSeconds: number) {\n        const timeoutId = joinTimeoutCallers(\n            id,\n            parentId,\n            TIMEOUT_CALLERS.STOP\n        )\n\n        const timeoutDelaySeconds = delaySeconds - TIME_LOOKAHEAD_SECONDS\n\n        let caller = joinTimeoutCallers(\n            id,\n            parentId,\n            TIMEOUT_CALLERS.DEFAULT_STOP\n        )\n\n        if (!isDefaultStop) {\n            if (Timer.hasTimeout(caller)) {\n                Timer.clearTimeout(caller)\n            }\n            else {\n                caller = timeoutId\n            }\n        }\n\n        Timer.setTimeout(\n            () => this.#stopSoundWithFadeOut(\n                stopSoundArgs,\n                id,\n                parentId,\n                whenSeconds\n            ),\n            timeoutDelaySeconds,\n            caller\n        )\n    }\n\n    #cancelOrStopSound(args: StopSoundArgs, id: string, parentId: string, whenSeconds: number) {\n        const ctx = this.#scheduledSoundContexts[id + parentId]\n        \n        if (exists(ctx)) {\n            this.#audioScheduler.cancelScheduledSound(ctx)\n            return\n        }\n        this.#stopSoundWithFadeOut(args, id, parentId, whenSeconds)\n    }\n\n    /**\n     * Stop a Pool.\n     *\n     * @param {string} id Id of Pool to stop.\n     * @param {MusicalPositionOrNumber} delay If number, ms to wait until stopping,\n     * if string \"bar.beat.tick\" for quantized trigger. Use \"0.0.0\" to trigger on next quantize event.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    stopPool(id: string, delay: MusicalPositionOrNumber = 0, parentId: string = id): void {\n        const nowSeconds = this.#mixer.now()\n        const pool = this.#playingPoolItems[id + parentId]\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds - elapsed\n                    this.stopPool(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.POOL_STOP\n                )\n            )\n            return\n        }\n\n        delete this.#poolCounter[id + parentId]\n        \n        if (pool === undefined) {\n            return\n        }\n        if (delaySeconds) {\n            Timer.setTimeout(\n                () => this._stopAndDeletePoolItems(\n                    pool,\n                    id,\n                    parentId\n                ),\n                delaySeconds\n            )\n            return\n        }\n\n        this._stopAndDeletePoolItems(pool, id, parentId)\n    }\n\n    //Fix description\n    private _stopAndDeletePoolItems (pool: Array<PoolItem>, id: string, parentId: string): void {\n        for (const poolItem of pool) {\n            if (poolItem.type === \"sound\" || !poolItem.type) {\n                this.stopSound(\n                    poolItem.target,\n                    new StopSoundArgs(),\n                    id\n                )\n            }\n            else if (poolItem.type === \"pool\") {\n                this.stopPool(poolItem.target, 0, id)\n            }\n            else if (poolItem.type === \"pattern\") {\n                this.stopPattern(poolItem.target, 0, id)\n            }\n        }\n\n        delete this.#playingPoolItems[id + parentId]\n        delete this.#playingPoolArgs[id + parentId]\n        const playing = this.#playingPools[id + parentId]\n\n        const caller = joinTimeoutCallers(id, TIMEOUT_CALLERS.POOL_PLAY)\n\n        for (let i = 0; i < playing; i++) {\n            Timer.clearTimeout(joinTimeoutCallers(caller, i.toString()))\n        }\n\n        this.#playingPools[id + parentId] = 0\n        Timer.clearTimeout(caller)\n    }\n\n    /**\n     * Pause a sound.\n     *\n     * @param {string} id Id of the sound to pause.\n     * @param {MusicalPositionOrNumber} delaySeconds Delay before pausing. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of envelope parent, for example pattern id. Optional.\n     */\n    pauseSound(id: string, delaySeconds: MusicalPositionOrNumber, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        delaySeconds = Utils.defaultNumber(delaySeconds, 0, this.#tempoConfig, nowSeconds)\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                Timer.pause(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SOUND_START,\n                        i.toString()\n                    )\n                )\n            }\n            this.#timeOutIdCounter.set(id, 0)\n        }\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds as number - elapsed\n                    this.pauseSound(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(id, TIMEOUT_CALLERS.SOUND_PAUSE)\n            )\n            return\n        }\n\n        this.#eventQueue = this.#eventQueue.filter((item) => {\n            return item.id !== id && item.parentId !== parentId\n        })\n\n        if (delaySeconds) {\n            Timer.setTimeout(() => {\n                this.#mixer.pauseSound(id, parentId)\n            }, delaySeconds, id)\n        }\n\n        else {\n            this.#mixer.pauseSound(id, parentId)\n        }\n    }\n\n    /**\n     * Pause a pool.\n     *\n     * @param {string} id Id of the pool to pause.\n     * @param {MusicalPositionOrNumber} delaySeconds Delay before pausing pool. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    pausePool(id: string, delaySeconds?: MusicalPositionOrNumber, parentId?: string): void {\n        parentId = parentId || id\n\n        const pool = this.#playingPoolItems[id + parentId]\n\n        if (!pool) {\n            logger().warn(\"[ecas] unable to pause pool:\", id)\n            return\n        }\n\n        const nowSeconds = this.#mixer.now()\n\n        delaySeconds = Utils.defaultNumber(delaySeconds, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds as number - elapsed\n                    this.pausePool(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                id + TIMEOUT_CALLERS.POOL_PAUSE\n            )\n            return\n        }\n\n        const pause = (item: PoolItem) => {\n            switch (item.type) {\n                case \"pattern\":\n                    this.pausePattern(item.target, 0, parentId)\n                    break\n                case \"pool\":\n                    this.pausePool(item.target, 0, parentId)\n                    break\n                case \"sound\":\n                    this.pauseSound(item.target, 0, id)\n                    break\n                default:\n                    logger().warn(\"[ecas] Sequencer.pausePool; item.type not set\")\n                    break\n            }\n        }\n\n        const playing = this.#playingPools[id + parentId]\n\n        for (let i = 0; i < playing; i++) {\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.POOL_PLAY,\n                    i.toString()\n                )\n            )\n        }\n\n        if (delaySeconds) {\n            Timer.setTimeout(\n                () => {\n                    pool.forEach(pause)\n                    this.#pausedPools[id + parentId] = true\n                },\n                delaySeconds\n            )\n        }\n\n        else {\n            pool.forEach(pause)\n            this.#pausedPools[id + parentId] = true\n        }\n    }\n\n    /**\n     * Resume a paused sound.\n     *\n     * @param {string} id Id of the sound to resume.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming sound. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of sound parent, for example pool or pattern id. Optional.\n     */\n    resumeSound(id: string, delay: MusicalPositionOrNumber, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remainingSeconds = delaySeconds - elapsedSeconds\n                    this.resumeSound(id, remainingSeconds, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_RESUME\n                )\n            )\n            return\n        }\n\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                const caller = joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    i.toString()\n                )\n                if (Timer.hasTimeout(caller) && !delaySeconds) {\n                    Timer.resume(caller)\n                }\n            }\n            this.#timeOutIdCounter[id] = 0\n        }\n\n        if (delaySeconds > 0) {\n            Timer.setTimeout(\n                () => this.#mixer.resumeSound(id, parentId),\n                delaySeconds\n            )\n            return\n        }\n\n        this.#mixer.resumeSound(id, parentId)\n    }\n\n    /**\n     * Resume a paused pool.\n     *\n     * @param {string} id Id of the pool to resume.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming pool. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    resumePool(id: string, delay: MusicalPositionOrNumber = 0, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remainingSeconds = delaySeconds - elapsedSeconds\n                    this.resumePool(id, remainingSeconds, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(id, TIMEOUT_CALLERS.POOL_RESUME)\n            )\n            return\n        }\n\n        const pool = Utils.filterUnique(this.#playingPoolItems[id + parentId], [\"target\", \"type\"])\n\n        if (delaySeconds > 0) {\n            Timer.setTimeout(\n                () => this.#resumePausedPoolItems(pool, id, parentId),\n                delaySeconds\n            )\n            return\n        }\n\n        this.#resumePausedPoolItems(pool, id, parentId)\n    }\n\n    #resumePausedPoolItems (pool: Array<PoolItem>, id: string, parentId: string) {\n        if (this.#pausedPools[id + parentId]) {\n            pool.forEach((item: PoolItem) => {\n                switch (item.type) {\n                    case \"pattern\":\n                        this.resumePattern(item.target, 0, id)\n                        break\n                    case \"pool\":\n                        this.resumePool(item.target, 0 , id)\n                        break\n                    case \"sound\":\n                        this.resumeSound(item.target, 0, id)\n                        break\n                    default:\n                        logger().warn(\"[ecas] Sequencer._resumePausePoolItems; item.type not set\")\n                        break\n                }\n            })\n            delete this.#pausedPools[id + parentId]\n            const playing = this.#playingPools[id + parentId]\n            for (let i = 0; i < playing; i++) {\n                Timer.resume(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.POOL_PLAY,\n                        i.toString()\n                    )\n                )\n            }\n            return\n        }\n        this.stopPool(id)\n        this.playPool(id, this.#playingPoolArgs[id + parentId])\n    }\n\n\n    /**\n     * Play a pattern.\n     * @param {string} id Id of pattern to play.\n     * @param {IPlayPatternArgs} playPatternArgs Arguments to pass when playing pattern.\n     * @param {string} parentId Id of parent pool or pattern.\n     * @param {boolean} isRelative If true, startTime is not including current time.\n     */\n    playPattern(id: string, playPatternArgs: IPlayPatternArgs = {}, parentId?: string, isRelative = true): void {\n        parentId = parentId || id\n        playPatternArgs = Utils.defaultValue(playPatternArgs, {})\n\n        const nowSeconds = this.#mixer.now()\n        const tempoConfig = clone(this.#tempoConfig)\n        const pattern = this.#options.soundConfig.patterns.filter((val) => val.id === id)[0]\n\n        this.#patternItemsCompleted[id + parentId] = 0\n\n        if (!pattern) {\n            logger().warn(\"[ecas] unable to play pattern with id '\" + id + \"'.\")\n            return null\n        }\n\n        tempoConfig.tempo = pattern.tempo || tempoConfig.tempo\n        if (isUndefined(tempoConfig.triggerQuantize)) {\n            tempoConfig.triggerQuantize = 1\n        }\n        tempoConfig.timeSignature = createTimeSignatureFromString(pattern.timeSignature) || tempoConfig.timeSignature\n\n        const secondsPerBeat = milliSecondsPerBeatFromTempoConfig(tempoConfig)\n        let startTimeSeconds = Utils.defaultNumber(playPatternArgs.startTime, 0, tempoConfig, nowSeconds)\n\n        if (isRelative) {\n            startTimeSeconds += nowSeconds\n        }\n\n        const patternDelay = startTimeSeconds - nowSeconds\n        const latencyTimeSeconds = nowSeconds + TIME_LOOKAHEAD_SECONDS\n\n        if (startTimeSeconds >= latencyTimeSeconds) {\n            Timer.setTimeout(\n                () => {\n                    playPatternArgs.startTime = startTimeSeconds\n                    this.playPattern(id, playPatternArgs, parentId, false)\n                },\n                startTimeSeconds - latencyTimeSeconds,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n\n            return\n        }\n\n        const startPosSeconds = Utils.defaultNumber(playPatternArgs.startPos, 0, tempoConfig, 0) / 1000\n        const durationSeconds = Math.max(\n            Utils.defaultNumber(playPatternArgs.duration, 0, tempoConfig, 0) / 1000,\n            0\n        )\n\n        const numItems = pattern.pattern.length\n        const quantizeValue = tempoConfig.triggerQuantize * (tempoConfig.triggerQuantize >= 1 ? tempoConfig.timeSignature.meter : 1)\n        const quantizeSize = secondsPerBeat * quantizeValue\n\n        let endTimeSeconds = nowSeconds\n\n        pattern.pattern.sort((val) => val.sound ? -1 : 1)\n        const sorted = pattern.pattern\n\n        const cb = () => {\n            let completed = this.#patternItemsCompleted[id + parentId]\n\n            if (!completed) {\n                completed = 0\n            }\n\n            completed++\n            this.#patternItemsCompleted[id + parentId] = completed\n\n            if (completed === numItems) {\n                if (playPatternArgs.onEnded) {\n                    this.#callOnEnded(playPatternArgs.onEnded)\n                }\n            }\n        }\n\n        let maxItemDuration = 0\n        let maxLoopDurationSeconds = 0\n        let isLoop = false\n        let shouldSchedule = true\n\n        for (const item of sorted) {\n            item.parentId = parentId\n\n            this.#playingPatternItems[id + parentId] = Utils.defaultValue(this.#playingPatternItems[id + parentId], [])\n            this.#playingPatternItems[id + parentId].push(item)\n\n            const confStartPosSeconds = isNumeric(item.startPos) ? item.startPos / 1000 : item.startPos\n            const confDurationSeconds = isNumeric(item.duration) ? item.duration / 1000 : item.duration\n            const confDelaySeconds = isNumeric(item.delay) ? item.delay / 1000 : item.delay\n\n            const soundDurationSeconds = this.#assetHandler.soundHandler.getDurationSeconds(item.sound)\n            let itemDuration = Utils.defaultNumber(confDurationSeconds, 0, tempoConfig, 0)\n\n            let actualItemDuration = itemDuration\n            if (actualItemDuration === 0 && item.sound) {\n                actualItemDuration = soundDurationSeconds\n            }\n\n            const quantizeSteps = Math.round(Math.max(actualItemDuration / quantizeSize, 1))\n            const loopDurationSeconds = item.loop && pattern.sync ? quantizeSteps * quantizeSize : soundDurationSeconds\n\n            maxLoopDurationSeconds = Math.max(maxLoopDurationSeconds, item.loop && pattern.sync ? loopDurationSeconds : 0)\n\n            let itemStartPos = Utils.sumPos(Utils.defaultNumber(confStartPosSeconds, 0, tempoConfig, 0), startPosSeconds)\n\n            if (itemStartPos === loopDurationSeconds) {\n                itemStartPos = 0\n            }\n\n            if (itemStartPos >= soundDurationSeconds && loopDurationSeconds && item.loop) {\n                itemStartPos = itemStartPos % loopDurationSeconds\n            }\n\n            const itemDelay = Utils.sumPos(Utils.defaultNumber(confDelaySeconds, 0, tempoConfig, nowSeconds), patternDelay)\n\n            itemDuration = Math.max(itemDuration, 0)\n            actualItemDuration = item.loop && !pattern.sync ? itemDuration : actualItemDuration + itemDelay - itemStartPos\n            maxItemDuration = Math.max(maxItemDuration, actualItemDuration)\n\n            if (item.sound) {\n                if (item.loop) {\n                    isLoop = true\n                }\n\n                else {\n                    shouldSchedule = false\n                }\n\n                if (pattern.sync) {\n                    const playSoundArgs = new PlaySoundArgs({\n                        startTime: itemDelay + nowSeconds,\n                        volume: item.volume,\n                        pan: item.pan,\n                        loop: false,\n                        startPos: itemStartPos,\n                        duration: itemDuration,\n                        pitch: item.pitch,\n                        args: item.args,\n                        onended: actualItemDuration === Number.MAX_VALUE || item.loop ? null : cb,\n                    })\n\n                    this.#scheduleItem(item, id, playSoundArgs, loopDurationSeconds)\n                }\n\n                else {\n                    const playSoundArgs = new PlaySoundArgs({\n                        startTime: itemDelay + nowSeconds,\n                        volume: item.volume,\n                        pan: item.pan,\n                        loop: item.loop,\n                        startPos: itemStartPos,\n                        duration: itemDuration,\n                        pitch: item.pitch,\n                        args: item.args,\n                        onended: actualItemDuration === Number.MAX_VALUE || item.loop ? null : cb,\n                    })\n\n                    if (playSoundArgs.startTime <= nowSeconds) {\n                        this.playSound(item.sound, playSoundArgs, id, false)\n                    }\n                    else {\n                        this.#scheduleItem(item, id, playSoundArgs)\n                    }\n                }\n            }\n            else {\n                if (item.envelope) {\n                    const envelope = item.envelope as EnvelopePreset\n\n                    const envelopeArgs: PlayEnvelopeArgs = createPlayEnvelopeArgs({\n                        startTime: itemDelay + nowSeconds,\n                        param: envelope.param,\n                        envelopePoints: envelope.data,\n                        onEnded: cb,\n                    })\n\n                    envelopeArgs.type = item.soundId ? \"sound\" : \"bus\"\n\n                    const envTarget = item.bussId || item.soundId\n\n                    if (envTarget) {\n                        if (envelopeArgs.startTime <= nowSeconds) {\n                            const target = item.bussId || item.soundId\n\n                            this.playEnvelope(target, envelopeArgs)\n                        }\n                        else {\n                            this.#scheduleItem(item, id, envelopeArgs)\n                        }\n                    }\n\n                    else {\n                        let isCallbackAdded = false\n\n                        pattern.pattern.forEach((val) => {\n                            if (val.sound) {\n                                const envArgs = clone(envelopeArgs)\n                                envArgs.onEnded = !isCallbackAdded ? cb : null\n                                envArgs.type = \"sound\"\n                                item.soundId = val.sound\n                                this.#scheduleItem(item, id, envArgs)\n                                isCallbackAdded = true\n                            }\n                        })\n                    }\n                }\n\n                else if (item.pattern) {\n                    const patternArgs = {startTime: itemDelay, onEnded: cb, startPos: itemStartPos, duration: itemDuration}\n                    this.#scheduleItem(item, id, patternArgs)\n                }\n\n                else if (item.pool) {\n                    const poolDurationSeconds = Utils.defaultNumber(item.duration) / 1000\n                    const { volume, pan, loop } = item\n                    const poolArgs = { volume, pan, loop, startTime: itemDelay, duration: poolDurationSeconds, startPos: itemStartPos, onEnded: cb }\n\n                    this.#scheduleItem(item, id, poolArgs)\n                }\n            }\n        }\n\n        let actualDuration = Math.min(\n            maxItemDuration > 0 ?  maxItemDuration : Number.MAX_VALUE,\n            durationSeconds ? durationSeconds : Number.MAX_VALUE,\n        )\n\n        if (!shouldSchedule && isLoop) {\n            actualDuration = durationSeconds > 0 ? durationSeconds : 0\n        }\n\n        if ((isLoop && durationSeconds > maxItemDuration)) {\n            actualDuration = durationSeconds\n        }\n\n        if (maxLoopDurationSeconds === 0 || durationSeconds > 0) {\n            endTimeSeconds += actualDuration + patternDelay\n\n            this.#assetHandler.setPatternContext(id + parentId, { pattern, endTime: endTimeSeconds, onEnded: playPatternArgs.onEnded })\n            this.#playingPatternArgs[id + parentId] = playPatternArgs\n\n            if (actualDuration > 0 && actualDuration !== Number.MAX_VALUE) {\n\n                Timer.setTimeout(\n                    () => this.stopPattern(id, 0, parentId),\n                    actualDuration + patternDelay,\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED,\n                        parentId,\n                        TIMEOUT_CALLERS.PATTERN\n                    )\n                )\n            }\n        }\n    }\n\n    /**\n     * Pause a pattern.\n     * @param {string} id Id of pattern to pause.\n     * @param {MusicalPositionOrNumber} delay Delay before pausing pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of pattern parent, for example pool id. Optional.\n     */\n    pausePattern(id: string, delay: MusicalPositionOrNumber = 0, parentId: string = null): void {\n        parentId = parentId || id\n        const now = this.#mixer.now()\n        delay = Utils.defaultNumber(delay, 0, this.#tempoConfig, now)\n        if (delay >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - now\n                    const remainingSeconds = delay as number - elapsedSeconds\n                    this.pausePattern(id, remainingSeconds, parentId)\n                },\n                delay - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PAUSE\n                )\n            )\n            return\n        }\n        const pause = () => {\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n            if (!this.#playingPatternItems[id + parentId]) {\n                logger().warn(\"[ecas] unable to pause pattern with id '\" + id + \"' and parentId '\" + parentId + \"'.\")\n                return null\n            }\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN\n                )\n            )\n            Timer.pauseMatching(\n                new RegExp(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED_REGEX\n                    )\n                )\n            )\n            this.#playingPatternItems[id + parentId].forEach((item) => {\n                if (item.sound) {\n                    this.pauseSound(item.sound, 0, id)\n                }\n                else if (item.pattern) {\n                    this.pausePattern(item.pattern, 0, id)\n                }\n                else if (item.pool) {\n                    this.pausePool(item.pool, 0 , id)\n                }\n                else if (item.envelope) {\n                    // Pausing of envelopes not currently possible in WebAudio API\n                    // The genius responsible for the spec obviously think that fire and forget animation of parameters\n                    // is good enough, and that it is inconceivable that anyone would ever have the need to inspect the current\n                    // value of an animated parameter, or stopping an animation in progress.\n                    // This might be doable eventually when AudioParam.cancelAndHoldAtTime() is supported in browsers.\n                }\n            })\n            this.#pausedPatterns[id + parentId] = true\n        }\n        delay = Utils.randomizeValues(delay)\n        if (delay) {\n            Timer.setTimeout(\n                pause,\n                delay,\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN_PAUSE\n                )\n            )\n        }\n        else {\n            pause()\n        }\n    }\n\n    /**\n     * Resume a paused pattern.\n     * @param {string} id Id of pattern to pause.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    resumePattern(id: string, delay: MusicalPositionOrNumber = 0, parentId = id): void {\n        const now = this.#mixer.now()\n        const delayValue = Utils.defaultNumber(delay, 0, this.#tempoConfig, now)\n\n        if (delayValue >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - now\n                    const remain = delayValue as number - elapsed\n                    this.resumePattern(id, remain, parentId)\n                },\n                delayValue - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_RESUME\n                )\n            )\n            return\n        }\n        const failMsg = \"[ecas] unable to resume pattern with id '\" + id + \"'.\"\n        if (this.#pausedPatterns[id + parentId]) {\n            const patternContext = this.#assetHandler.getPatternContext(id + parentId)\n            if (!patternContext || !patternContext.pattern || !this.#playingPatternItems[id + parentId]) {\n                logger().warn(failMsg)\n                return null\n            }\n            Timer.resume(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN\n                )\n            )\n            Timer.resume(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n            Timer.resumeMatching(\n                new RegExp(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED_REGEX\n                    )\n                )\n            )\n            this.#playingPatternItems[id + parentId].forEach((item) => {\n                if (item.sound) {\n                    this.resumeSound(item.sound, delayValue, id)\n                }\n                else if (item.pool) {\n                    this.resumePool(item.pool, delayValue, id)\n                }\n                else if (item.pattern) {\n                    this.resumePattern(item.pattern, delayValue, id)\n                }\n            })\n            delete this.#pausedPatterns[id + parentId]\n            return\n        }\n        else if (this.#assetHandler.getPatternContext(id + parentId)) {\n            const args = this.#playingPatternArgs[id + parentId]\n            this.stopPattern(id)\n            args.startTime = delayValue\n            this.playPattern(id, args)\n            return\n        }\n        logger().warn(failMsg)\n\n    }\n\n    /**\n     * Stop a pattern.\n     * @param {string} id Id of pattern to stop.\n     * @param {MusicalPositionOrNumber} delay Delay before stopping pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    stopPattern(id: string, delay: MusicalPositionOrNumber = 0, parentId?: string): void {\n        parentId = parentId || id\n\n        const nowSeconds = this.#mixer.now()\n        delay = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delay >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remain = delay as number - elapsedSeconds\n                    this.stopPattern(id, remain, parentId)\n                },\n                delay - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_STOP\n                )\n            )\n\n            return\n        }\n\n        const patternContext = this.#assetHandler.getPatternContext(id + parentId)\n        const playingItems = this.#playingPatternItems[id + parentId]\n\n        if (!playingItems) {\n            logger().warn(\"[ecas] unable to stop pattern with id '\" + id + \"' and parentId '\" + parentId + \"'.\")\n            return null\n        }\n\n        Timer.clearTimeout(\n            joinTimeoutCallers(\n                id,\n                parentId,\n                TIMEOUT_CALLERS.PATTERN\n            )\n        )\n        Timer.clearTimeout(\n            joinTimeoutCallers(\n                id,\n                TIMEOUT_CALLERS.PATTERN_PLAY\n            )\n        )\n        Timer.clearMatching(\n            new RegExp(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SCHEDULED_REGEX\n                )\n            )\n        )\n\n        playingItems.forEach((item) => {\n            let itemId: string\n\n            if (item.sound) {\n                itemId = item.sound\n                this.stopSound(item.sound, new StopSoundArgs({delay}), id)\n            }\n\n            else if (item.pattern) {\n                itemId = item.pattern\n                this.stopPattern(item.pattern, delay, id)\n            }\n\n            else if (item.pool) {\n                itemId = item.pool\n                this.stopPool(item.pool, delay, id)\n            }\n\n            this.#eventQueue = this.#eventQueue.filter((itm) => itm.parentId !== id && itm.id !== itemId)\n        })\n\n        const onEnded = patternContext ? patternContext.onEnded : null\n\n        if (onEnded) {\n            this.#callOnEnded(onEnded)\n        }\n\n        this.#assetHandler.setPatternContext(id + parentId, null)\n        delete this.#playingPatternItems[id + parentId]\n        delete this.#playingPatternArgs[id + parentId]\n    }\n\n    /**\n     * Stop all sounds.\n     */\n    stopAll(options: {onEnded?: string} = {}) {\n        this.#mixer.stopAll(options)\n    }\n\n    /**\n     * Set the pool Index\n     *\n     * @param {string} id Id of the pool\n     * @param {number} index pool item's position\n     * @return {boolean} true or false\n     */\n    setPoolIndex(id: string, index: number): boolean {\n        // convert position number to array index\n        const arrayIndex = index - 1\n        const len = this.#poolQueue[id].length\n        if (index > len || index < 1) {\n            logger().warn(`[ecas] sound item outbound exception with pool id '${id}'`)\n            return false\n        }\n        this.#poolPointer[id] = arrayIndex\n        return true\n    }\n\n    #callOnEnded(val: string | (() => void)) {\n        if (isFunction(val)) {\n            val()\n            return\n        }\n\n        if (isString(val)) {\n            this.#eventHandler.triggerOnEndedEvent(val)\n            return\n        }\n\n        logger().debug(\"[ecas] invalid parameter type specified in onEnded.\")\n    }\n\n    #purgePlayingSound(id: string, parentId: string) {\n        logger().debug(\"[ecas] purge sound\", id, parentId)\n        const sound = this.#assetHandler.soundHandler.getSound(id)\n        const playing = this.#playingSoundsPerGroup[sound.group]\n\n        if (playing) {\n            const filteredPlaying = playing.filter((val: ISoundContext) => !(val.id === id && val.parentId === parentId))\n            this.#playingSoundsPerGroup[sound.group] = filteredPlaying\n\n            const pool = this.#playingSoundsPerPool[parentId]\n\n            if (pool) {\n                this.#playingSoundsPerPool[parentId].pop()\n            }\n        }\n    }\n\n    /**\n     * Get the sound name from the sound pool based on priority configuration\n     *\n     * @param {string} id passing POOL id\n     * @return {IPoolItem} Pool item\n     */\n    #getItemFromPool(id: string, reset: boolean): ISoundsConfig['pools'][number]['items'][number] {\n        if (!this.#assetHandler.hasPool(id)) {\n            logger().warn(\"[ecas] unable to play pool with id '\" + id + \"'.\")\n            return null\n        }\n        const len = this.#poolQueue[id].length\n        const type = this.#assetHandler.getPool(id).type\n        if (reset || this.#poolPointer[id] >= len) {\n            this.#poolPointer[id] = 0\n            // if the random pool ends the Q, then reshuffle it\n            if (type === \"random\") {\n                this.#poolQueue[id] = Utils.randomShuffle(this.#poolQueue[id])\n            }\n        }\n        const item: PoolItem = this.#poolQueue[id][this.#poolPointer[id]]\n        this.#poolPointer[id]++\n        item.pan = item.pan || 0\n        return item\n    }\n\n    /**\n     * Get sounds from config and set them up\n     *\n     * @param {IPool[]} pools List of IPool objects to setup\n     * @private\n     */\n    #setupPools(pools: Pool[]): void {\n        this.#poolQueue = {}\n        this.#poolPointer = {}\n        this.#poolCounter = {}\n\n        for (const pool of pools) {\n            const tempArr: PoolItem[] = []\n            pool.items.forEach((item, index) => {\n                if (pool.priority) {\n                    const priority = pool.priority[index]\n                    for (let i = 0; i < priority; i++) {\n                        tempArr.push(item)\n                    }\n                }\n                else {\n                    tempArr.push(item)\n                }\n            })\n\n            this.#poolQueue[pool.id] = (pool.type === \"random\") ? Utils.randomShuffle(tempArr) : tempArr\n            this.#poolPointer[pool.id] = 0\n        }\n    }\n\n    /**\n     * Schedule pattern item with delay so it can be cancelled/paused.\n     *\n     * @param {IPatternItem} item Pattern item to schedule.\n     * @param {string} parentId Id of pattern item belongs to.\n     * @param {number} index Index of item, used if multiple items with the same parentId.\n     * @param {IPlaySoundArgs|IPlayPoolArgs|IPlayPatternArgs|IPlayEnvelopeArgs} args Arguments\n     * to use when invoking the aappropriate method for the item type.\n     * @param {number} loopLength If specified, item will loop at specified length.\n     * @private\n     */\n    #scheduleItem(\n        item: Pattern,\n        parentId: string,\n        args: PlaySoundArgs | IPlayPoolArgs | IPlayPatternArgs | PlayEnvelopeArgs,\n        loopLength = 0\n    ) {\n        let id = null\n        let eventMethod = null\n        const now = this.#mixer.now()\n        parentId = parentId ? parentId : item.parentId\n        if (item.sound) {\n            id = item.sound\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playSound(id, args as PlaySoundArgs, parentId, false, loopLength > 0)\n            }\n        }\n        else if (item.pattern) {\n            id = item.pattern\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playPattern(id, args as IPlayPatternArgs, item.parentId)\n            }\n        }\n        else if (item.pool) {\n            id = item.pool\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playPool(id, args as IPlayPoolArgs, item.parentId)\n            }\n        }\n        else if (item.envelope && isPlayEnvelopeArgs(args)) {\n            id = item.envelope\n            const envTarget = item.bussId || item.soundId\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playEnvelope(envTarget, args, parentId)\n            }\n        }\n        else {\n            logger().warn(\"[ecas] attempting to schedule unknown pattern item type. Item: \", item)\n            return\n        }\n        const startTime = Utils.defaultNumber(args.startTime, 0, this.#tempoConfig, now)\n        if (startTime === 0) {\n            eventMethod(startTime)\n        }\n        else {\n            const event: ISequenceEvent = {\n                eventMethod,\n                loopLength,\n                startTime,\n                id,\n                parentId,\n            }\n            this.#eventQueue.push(event)\n        }\n    }\n\n    #onUpdate() {\n        const currentTime = this.#mixer.now()\n        const calls = []\n        this.#eventQueue = this.#eventQueue.filter((item) => {\n            const isLooped = item.loopLength > 0\n            const eventHorizon = currentTime + TIME_LOOKAHEAD_SECONDS\n            if (item.startTime <= eventHorizon) {\n                calls.push({method: item.eventMethod, startTime: item.startTime})\n                if (isLooped) {\n                    item.startTime += item.loopLength\n                }\n                return isLooped\n            }\n            return true\n        })\n        calls.forEach((conf) => conf.method(conf.startTime))\n    }\n}\n", "import { AutomatableParameters, Automator, CurveCreator } from \"@netent-tech/ecas-automator\"\nimport { isSearchParamUsed, loadFromName, loadUsingSearchParam, logger, setLogger, type EcasLogger, type LoggerName } from \"@netent-tech/ecas-logger\"\nimport { isArray, isNonEmptyArray, isNumeric, isString, isTrue, noop } from '@netent-tech/ecas-utils'\nimport { logEcasVersion } from \"@netent-tech/ecas-version-display\"\nimport { AssetHandler } from \"./asset-handler\"\nimport { MASTER_BUS_ID, OUTPUT_BUS_ID, TIME_LOOKAHEAD_SECONDS } from \"./constants\"\nimport { ApplyEnvelopeOptions, BusConfig, CancelEnvelopeOptions, IAnalyseBusArgs, IApplyEnvelopeOptions, IBusApplyEnvelopeOptions, IBusApplyEnvelopeToInsertOptions, IBusIdArg, IEcasOptions, IPausePatternArgs, IPausePoolArgs, IPauseSoundArgs, IPlayEnvelopeArgs, IPlayPatternArgs, IPlayPoolArgs, IPlaySoundArgs, IResumePatternArgs, IResumePoolArgs, IResumeSoundArgs, isMusicalPosition, IStopPatternArgs, IStopPoolArgs, IStopSoundArgs, IStringMap, PreloadOnprogressType, Sound, TimeSignature } from \"@netent-tech/ecas-common\"\nimport { createPlayEnvelopeArgs, EnvelopeHandler } from \"./envelopes\"\nimport { EcasEvents, EventHandler } from \"./event-handler\"\nimport { Mixer } from \"./mixer\"\nimport { Bus } from \"./mixer/buses/Bus\"\nimport { AlgorithmicReverbInsert, AlgorithmicReverbInsertOptions, BiquadFilterInsert, BiquadFilterInsertOptions, ConvolverReverbInsert, ConvolverReverbInsertOptions, DelayInsert, DelayInsertOptions, DynamicsCompressorInsert, DynamicsCompressorInsertOptions, InsertClass, InsertClassAutomator, InsertOptions, InsertTypenames, is, PingPongDelayInsert, PingPongInsertOptions } from \"@netent-tech/ecas-inserts\"\nimport { createEcasOptions, EcasOptions } from \"./options-creator\"\nimport { IEcasApi } from \"./ecas-common\"\nimport { PlaySoundArgs } from \"./options-creator/PlaySoundArgs\"\nimport { StopSoundArgs } from \"./options-creator/StopSoundArgs\"\nimport { AnalyserConfig } from \"./other/AnalyserConfig\"\nimport { VolumeMeter } from \"./other/VolumeMeter\"\nimport { polyfill } from \"./polyfills\"\nimport { Timer } from \"./scheduling/Timer\"\nimport { Sequencer } from \"./sequencer/Sequencer\"\nimport { createTimeSignatureFromString, Utils } from \"./utils\"\n\nconst MATCH_EVERYTHING = /.*/\n\n/** Resolves when the time provided has passed using the AudioContext time\n * If the time is in the past, it will resolve immediately\n */\nfunction whenPromise(context: Readonly<Pick<AudioContext, 'createConstantSource'>>, when?: Readonly<number>) {\n    return new Promise<void>(resolve => {\n        const source = context.createConstantSource()\n        source.onended = () => resolve()\n        source.start(0)\n        source.stop(when)\n    })\n}\n\n/**\n * ECAS Works as a facade to make the methods in the ecas api accesible to games,\n * and to the eventHandler so it can interpret the eventConfig created by the sound designer\n * and trigger the public methods by applying the arguments supplied.\n **/\nexport class ECAS implements IEcasApi {\n    eventHandler: EventHandler\n    assetHandler: AssetHandler\n    ready: Promise<void> // resolves when all sounds that are set to be preloaded have been so\n\n    #mixer: Mixer\n    #audioContext: AudioContext\n    #envelopeHandler: EnvelopeHandler\n    #sequencer: Sequencer\n    #busMeters: IStringMap<VolumeMeter>\n    #options: EcasOptions\n\n    isMuted = false\n\n    constructor (config: IEcasOptions, audioContext?: AudioContext) {\n        logEcasVersion(logger().log)\n        this.#options = createEcasOptions(config)\n        const { soundConfig, eventConfig, stateConfig, loadrConfig } = this.#options\n        logger().debug('[ecas] config:', config)\n        logger().debug('[ecas] options:', this.#options)\n        logger().info('[ecas] file extension:', loadrConfig.fileExtToUse)\n\n        this.#audioContext = audioContext ?? new AudioContext()\n        // emit events whenever the AudioContext state changes\n        this.audioContext.addEventListener('statechange',  () => {\n            type PossibleStates = AudioContextState | 'interrupted'\n            const state = this.audioContext.state as PossibleStates\n            switch(state) {\n                case('running'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Running)\n                    break\n                case('closed'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Closed)\n                    break\n                case('suspended'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Suspended)\n                    break\n                // happens for example when iphone user locks screen\n                case('interrupted'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Interrupted)\n                    break\n                default:\n                    logger().error('[ecas] AudioContext statechange event triggered with unknown state:', state)\n                    break\n            }\n        })\n\n        this.eventHandler = new EventHandler(eventConfig, stateConfig, loadrConfig, this)\n        this.assetHandler = new AssetHandler({\n            ecasOptions: this.#options,\n            audioContext: this.#audioContext,\n            eventHandler: this.eventHandler\n        })\n        this.#envelopeHandler = new EnvelopeHandler()\n        this.#mixer = new Mixer(\n            this.#audioContext,\n            this.#options,\n            this.eventHandler,\n            this.assetHandler,\n            this.#envelopeHandler\n        )\n        Timer.dateProvider = () => this.#mixer.now.bind(this.#mixer)\n\n        this.#sequencer = new Sequencer(\n            this.#options,\n            this.#mixer,\n            this.eventHandler,\n            this.assetHandler,\n        )\n\n        this.setTempo(soundConfig.settings.tempo)\n        this.setTriggerQuantize(soundConfig.settings.triggerQuantize)\n        this.setTimeSignature(soundConfig.settings.timeSignature)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Ready)\n\n        this.shouldPauseOnInvisible = loadrConfig.pauseOnInvisible\n        this.shouldMuteOnInvisible = loadrConfig.muteOnInvisible\n        this.shouldResumeOnVisible = loadrConfig.resumeOnVisible\n    }\n\n    set shouldMuteOnInvisible(shouldMute: boolean) {\n        // if ecas is already muted before becoming invisible, we should not unmute it when the tab is visible again\n        let shouldBeUnmutedWhenVisible = !this.isMuted\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            if (state === \"hidden\") {\n                shouldBeUnmutedWhenVisible = !this.isMuted\n                this.mute()\n            }\n            else if (state === \"visible\" && shouldBeUnmutedWhenVisible) {\n                this.unmute()\n            }\n        }\n        if (shouldMute) {\n            addEventListener('visibilitychange', listener)\n        }\n        else {\n            removeEventListener('visibilitychange', listener)\n        }\n    }\n\n    // ECAS-1167: https://jira.evolution.com/browse/ECAS-1167\n    // this is here to fix ios playing sound when another tab is focused\n    set shouldPauseOnInvisible(shouldPause: boolean) {\n        let timeout: number | null = null\n\n        const isVisibilityPaused = {\n            is: false,\n            get: () => isVisibilityPaused.is,\n            set: (value: boolean) => {\n                isVisibilityPaused.is = value\n            }\n        }\n\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            logger().debug(\"[ecas] visibility\", state)\n\n            if (state === \"hidden\") {\n                isVisibilityPaused.set(true)\n                // not using the timer here because the timer is usually paused when going invisible\n                timeout = window.setTimeout(\n                    () => {\n                        // we check again here if it should indeed be paused\n                        // in case it changed during the timeout\n                        // maybe the user opened the tab again within a short time period\n                        if(isVisibilityPaused.get()) {\n                            this.pause().catch(logger().error)\n                        }\n                    },\n                    1000 // 500ms for fadeout, 500ms for leeway\n                )\n            }\n            else if (state === \"visible\") {\n                isVisibilityPaused.set(false)\n                window.clearTimeout(timeout)\n                timeout = null\n            }\n        }\n        shouldPause\n            ? addEventListener('visibilitychange', listener)\n            : removeEventListener('visibilitychange', listener)\n    }\n\n    set shouldResumeOnVisible(shouldResume: boolean) {\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            if (state === \"visible\") {\n                const resume = async () => {\n                    const isResumed = await this.resume().catch(() => false)\n                    if (!isResumed) {\n                        logger().debug(\"[ecas] failed to resume audio context using resume on visible\")\n                    }\n\n                }\n                resume().catch(logger().error)\n            }\n        }\n        shouldResume\n            ? addEventListener('visibilitychange', listener)\n            : removeEventListener('visibilitychange', listener)\n    }\n\n    get options() {\n        return this.#options\n    }\n\n    /**\n     * It's really important that audio context has been allowed to start\n     * before we initialize ecas\n     * so better to use this async static method that makes sure the audioContext has been started\n     * instead of the normal constructor\n     **/\n    static async create (ecasConfig: IEcasOptions) {\n        isSearchParamUsed() ?  loadUsingSearchParam() : loadFromName(ecasConfig.loadrConfig.logger)\n\n        logger().debug(\"[ecas] create\", ecasConfig)\n        polyfill(ecasConfig.loadrConfig.forcePolyfills)\n\n        const audioContext = new AudioContext()\n\n        return new Promise<ECAS>((resolve) => {\n            if (audioContext?.state === \"running\") {\n                resolve(new ECAS(ecasConfig, audioContext))\n                return\n            }\n            logger().log(\"[ecas] waiting for user interaction so we can start audio context...\")\n            const oninteraction = () => {\n                const audioContext = new AudioContext()\n                resolve(new ECAS(ecasConfig, audioContext))\n                removeEventListener('click', oninteraction)\n                removeEventListener(\"keypress\", oninteraction)\n                removeEventListener(\"touchstart\", oninteraction)\n            }\n\n            window.addEventListener(\"click\", oninteraction, {once: true})\n            window.addEventListener(\"keypress\", oninteraction, {once: true})\n            window.addEventListener(\"touchstart\", oninteraction, {once: true})\n        })\n    }\n\n    /**\n     * Use to set logger as either \"console\" or \"timestamp\". Defaults to \"none\"\n     * @param name \"none\" | \"console\" | \"timestamp\"\n     */\n    setLogger(name: LoggerName): void {\n        loadFromName(name)\n    }\n\n    /**\n     * Use to provide a custom logger\n     *\n     * A custom logger can look loke this:\n     * @example\n     * ```\n     * const logger = new class {\n     *   format = (...args: any[]) => [`Custom-logger:`, ...args]\n     *\n     *   debug = (...args: any[]) => console.debug(...this.format(...args))\n     *   log = (...args: any[]) => console.log(...this.format(...args))\n     *   info = (...args: any[]) => console.log(...this.format(...args))\n     *   warn = (...args: any[]) => console.warn(...this.format(...args))\n     *   error = (...args: any[]) => console.error(...this.format(...args))\n     *   table = (...args: any[]) => console.table(...this.format(...args))\n     *   trace = (...args: any[]) => console.trace(...this.format(...args))\n     * }()\n     * ```\n     */\n    setCustomLogger (logger: EcasLogger ): void {\n        setLogger(logger)\n    }\n\n    get soundHandler () {\n        return this.#mixer.assetHandler.soundHandler\n    }\n\n    #preloadOnprogressDefault = (sucess: boolean, count: number, numberOfSoundsToPreload: number) => {\n        logger().debug(\"[ecas] preload onprogress\", {sucess, count, numberOfSoundsToPreload})\n    }\n\n    async preload(onprogress: PreloadOnprogressType = this.#preloadOnprogressDefault) {\n        logger().debug(\"[ecas] preload\")\n        const shouldPreload =\n            isTrue(this.#options.loadrConfig.preload)\n            || isNonEmptyArray(this.#options.loadrConfig.preload)\n\n        if (!shouldPreload) {\n            return\n        }\n\n        const soundsToPreload = isArray(this.#options.loadrConfig.preload)\n            ? this.#options.loadrConfig.preload\n            : this.assetHandler.soundHandler.getAllSoundIds()\n\n        const numberOfSoundsToPreload = soundsToPreload.length\n\n        this.eventHandler.on(EcasEvents.Preload.Progress, onprogress)\n\n        let count = 0\n        const listener = () => {\n            count += 1\n            const success = true\n            this.eventHandler.triggerAudioEvent(\n                EcasEvents.Preload.Progress,\n                success,\n                count,\n                numberOfSoundsToPreload\n            )\n        }\n\n        this.eventHandler.on(\n            EcasEvents.Sound.LoadDone,\n            listener\n        )\n        this.eventHandler.triggerAudioEvent(EcasEvents.Preload.Start)\n\n        logger().debug(\"[ecas] preloading these sounds:\", soundsToPreload)\n        await this.assetHandler.soundHandler.load(soundsToPreload)\n\n        this.eventHandler.triggerAudioEvent(EcasEvents.Preload.Done)\n        this.eventHandler.off(\n            EcasEvents.Sound.LoadDone,\n            listener\n        )\n    }\n\n    get audioContext () {\n        return this.#audioContext\n    }\n\n    /** pauses the audio context and the timeouts set with Timer.setTimeout */\n    async pause() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Pause)\n        await this.pauseContext().catch(logger().error)\n        // pause all timeouts set with Timer.setTimeout\n        this.eventHandler.triggerAudioEvent(EcasEvents.Timer.Pause)\n        Timer.pauseMatching(MATCH_EVERYTHING)\n    }\n\n    /** returns true if context was resumed, false if there was an error */\n    async resume() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Resume)\n        return this.resumeContext().then(() => {\n            // resume all timeouts set with Timer.setTimeout after the context has been resumed\n            this.eventHandler.triggerAudioEvent(EcasEvents.Timer.Resume)\n            Timer.resumeMatching(MATCH_EVERYTHING)\n            return true\n        }).catch(() => false)\n    }\n\n    async pauseContext () {\n        logger().debug('[ecas] pause - before:', this.#audioContext.state)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Context.Pause)\n        if (this.#audioContext.state === \"running\") {\n            await this.#audioContext.suspend().catch(logger().error)\n            logger().debug('[ecas] pause - after:', this.#audioContext.state)\n        }\n    }\n\n    async resumeContext () {\n        logger().debug('[ecas] resume - before:', this.#audioContext.state)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Context.Resume)\n        if (this.#audioContext.state === \"running\") {\n            logger().debug('[ecas] audio context is already running')\n            return true\n        }\n        if (this.#audioContext.state === \"closed\") {\n            logger().warn(\"[ecas] audio context is closed, cannot resume.\")\n            return false\n        }\n        const promise = new Promise<AudioContextState>((resolve) => {\n            const listener = () => this.#audioContext.resume()\n            const remover = () => {\n                removeEventListener(\"onclick\", listener)\n                removeEventListener(\"keypress\", listener)\n                removeEventListener(\"touchstart\", listener)\n                resolve(this.#audioContext.state)\n            }\n            window.addEventListener(\"onclick\", listener)\n            window.addEventListener(\"keypress\", listener)\n            window.addEventListener(\"touchstart\", listener)\n            listener()\n                .then(remover)\n                .catch((reason) => {\n                    logger().warn(\"[ecas] failed to resume audio context\", reason)\n                    resolve(this.#audioContext.state)\n                })\n        })\n        const state = await promise.catch(logger().error)\n        logger().debug('[ecas] resume - after:', state)\n        return state === \"running\"\n    }\n\n    setMasterVolume(gain: number) {\n        logger().debug('[ecas] setMasterVolume', gain)\n        if (!this.isMuted) {\n            this.busSetGain({busId: MASTER_BUS_ID, gain})\n            return\n        }\n        logger().debug(\"[ecas] tried to set gain while muted.\")\n    }\n\n    getMasterVolume() {\n        return this.#mixer.buses.get(MASTER_BUS_ID).gain.value\n    }\n\n    get mixer (): Readonly<Mixer> {\n        return this.#mixer\n    }\n\n    muteUnmute() {\n        this.isMuted\n            ? this.unmute()\n            : this.mute()\n    }\n\n    unmute() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Unmute)\n        if (!this.isMuted) {\n            return\n        }\n        this.isMuted = false\n\n        this.busApplyEnvelope({\n            busId: OUTPUT_BUS_ID,\n            paramId: \"gain\",\n            points: [\n                {pos: 0, val: \"current\"},\n                {pos: 500, val: 1}\n            ]\n        })\n    }\n\n    mute() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Mute)\n        if (this.isMuted) {\n            return\n        }\n\n        this.busApplyEnvelope({\n            busId: OUTPUT_BUS_ID,\n            paramId: \"gain\",\n            points: [\n                {pos: 0, val: \"current\"},\n                {pos: 500, val: 0}\n            ]\n        })\n        this.isMuted = true\n    }\n\n    getAudioContext() {\n        return this.#audioContext\n    }\n\n    /**\n     * Convenience function to get target target time from now from a provided duration\n     * @returns current time + your duration + lookahead\n     */\n    #chrono(durationSeconds = 0) {\n        return this.#audioContext.currentTime\n            + TIME_LOOKAHEAD_SECONDS\n            + Math.max(durationSeconds, 0)\n    }\n\n    /**\n     * Get current global playback position.\n     * @return {number} Current position since engine started in seconds.\n     */\n    now(): number {\n        return this.#mixer.now()\n    }\n\n    /**\n     * Gets a list of all of the currently playing sounds.\n     */\n    getActiveSounds(): string[] {\n        return this.#mixer.getActiveSounds()\n    }\n\n    /* * * * * * * * * * * * *  MainApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Trigger an audio event by forwarding the event to the adapter.\n     * @param event The event string.\n     * @param args An arbitrary array of arguments.\n     */\n    async triggerGameEvent(event: string, ...args: unknown[]) {\n        this.eventHandler.triggerGameEvent(event, ...args)\n    }\n\n    async dispose() {\n        logger().debug('[ecas] dispose')\n        this.stopAll()\n        if (this.#busMeters) {\n            Object.keys(this.#busMeters).forEach(this.busRemoveAnalyser)\n        }\n        this.#mixer.dispose()\n        this.eventHandler.dispose()\n        this.assetHandler.dispose()\n        this.#envelopeHandler.dispose()\n        await this.pauseContext()\n        await this.#audioContext.close()\n        // Todo: implement dispose for sequencer\n        this.eventHandler = null\n        this.assetHandler = null\n        this.#mixer = null\n        this.isMuted = true\n        this.#options = null\n    }\n\n\n    /* * * * * * * * * * * * *  TempoApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Set global tempo.\n     * Note that there is no timestretching or pitching of sounds, so use this with caution!\n     * Instead configure patterns with sounds in specific tempo, and set tempo property of pattern.\n     * Simply modifying this value on an existing sound will mean that looping will become off.\n     *\n     * If you have a pattern with delayed synced items (i.e. delay specified using \"bar.beat.tick\")\n     * and is only triggering individual hits, you could modify this value to speed up or slow the sequence.\n     *\n     * @param {number} tempo\n     */\n    setTempo(tempo: number) {\n        logger().debug('[ecas] setTempo', tempo)\n        this.#sequencer.setTempo(tempo)\n    }\n\n    /**\n     * Update trigger quantize setting.\n     *\n     * @param {number|string} input Trigger quantize value to use. Should be 8,4,2 0r 1 whole bars,\n     * or franction of whole note - 0.5, 0.25, 0.125, 0.0625 (alternatively 1/2, 1/4, 1/8, 1/16)\n     */\n    setTriggerQuantize(input: number | string) {\n        logger().debug('[ecas] setTriggerQuantize', input)\n        this.#sequencer.setTriggerQuantize(Utils.defaultNumber(input))\n    }\n\n    /**\n     * Update time signature setting.\n     *\n     * @param {string} timeSignature Meter to use, string such as '4/4', '3/4' or '6/8'.\n     */\n    setTimeSignature(timeSignature: TimeSignature) {\n        logger().debug('[ecas] setTimeSignature', timeSignature)\n        this.#sequencer.setTimeSignature(\n            createTimeSignatureFromString(timeSignature) || { meter: 4, unit: 4 }\n        )\n    }\n\n    /* * * * * * * * * * * * *  AssetLoadingApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    async loadAllSounds() {\n        logger().debug(\"[ecas] loadAllSounds\")\n        await this.assetHandler.soundHandler.loadAll()\n    }\n\n    async loadTheseSounds(ids: Sound['id'][]) {\n        logger().debug(\"[ecas] loadTheseSounds\", ids)\n        await this.assetHandler.soundHandler.load(ids)\n    }\n\n    async loadTheseEvents(ids: string[]) {\n        logger().debug(\"[ecas] loadTheseEvents\", ids)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Events.LoadStart)\n        await this.assetHandler.loadAssetsRelatedToEvents(ids)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Events.LoadDone)\n    }\n\n\n    /* * * * * * * * * * * * *  EnvelopeApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play envelope immediately\n     *\n     * @param {string} id Id of bus or sound to modulate. Use 'type' property\n     * in IPlayEnvelopeArgs to define type of target, e.g. \"bus\" or \"sound\".\n     * @param {IPlayEnvelopeArgs} args Play envelope configuration object\n     */\n    playEnvelope(id: BusConfig['id'] | Sound['id'], args: IPlayEnvelopeArgs = {}) {\n        logger().debug('[ecas] playEnvelope', id)\n        const initializedArgs = createPlayEnvelopeArgs(args)\n        this.#sequencer.playEnvelope(id, initializedArgs, id)\n    }\n\n    applyEnvelope<T extends readonly string[]>({automator, paramId, curve, points, delay}: {automator: Automator<T>} & IApplyEnvelopeOptions<T>) {\n        const when = this.audioContext.currentTime + (delay || 0)\n        /**\n         * note: getting current won't wait for delay supplied,\n         * to do that we would have to wait to calculate the points and curves until just before scheduling them\n         * which is not great for performance and accurate timing.\n         **/\n        const getRealValues = ({val}: {val: \"current\" | \"default\" | number}) => {\n            if(val === \"default\") {\n                return automator.getDefault(paramId)\n            }\n            if(val === \"current\") {\n                return automator.current(paramId)\n            }\n            return val\n        }\n        const values = points.map(getRealValues)\n        const positions = points.map(({pos}) => pos)\n        const [valueCurve, duration] = CurveCreator[curve || \"linear\"]([values, positions])\n        automator.automate({paramId, valueCurve, when, duration})\n        return whenPromise(this.#audioContext, when)\n    }\n\n    /** Will cancel all scheduled values for the provided parameter */\n    cancelEnvelope<T extends readonly string[]>({automator, paramId, delay}: {automator: Automator<T>, paramId: T[number], delay?: number}) {\n        const when = this.audioContext.currentTime + (delay || 0)\n        automator.cancel({paramId, when})\n        return whenPromise(this.#audioContext, when)\n    }\n\n\n    /* * * * * * * * * * * * *  PatternApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play pattern immediately\n     *\n     * @param {string} id Id of pattern to play.\n     * @param {IPlayPatternArgs} args Play pattern configuration object\n     */\n    playPattern(id: string, args?: IPlayPatternArgs) {\n        logger().debug('[ecas] playPattern', id)\n        args = Utils.defaultValue(args, {})\n\n        args.onEnded = Utils.defaultValue(args.onEnded, noop)\n\n        if (args.startTime && !isMusicalPosition(args.startTime)) {\n            args.startTime = Utils.defaultNumber(args.startTime) / 1000\n        }\n\n        if (args.duration && !isMusicalPosition(args.duration)) {\n            args.duration = Utils.defaultNumber(args.duration) / 1000\n        }\n\n        if (args.startPos && !isMusicalPosition(args.startPos)) {\n            args.startPos = Utils.defaultNumber(args.startPos) / 1000\n        }\n\n        const pattern = this.#options.soundConfig.patterns.reduce((acc, curr) => (curr.id === id ? curr : acc))\n\n        if (pattern.timeSignature) {\n            this.setTimeSignature(pattern.timeSignature)\n        }\n\n        if (pattern.tempo) {\n            this.setTempo(pattern.tempo)\n        }\n\n        this.#sequencer.playPattern(id, args)\n    }\n\n    /**\n     * Pause pattern.\n     *\n     * @param {string} id Id of pattern to pause\n     * @param {IPausePatternArgs} args Pause pattern configuration object. Optional.\n     */\n    pausePattern(id: string, args?: IPausePatternArgs) {\n        logger().debug('[ecas] pausePattern', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pausePattern(id, args.delay)\n    }\n\n    /**\n     * Resume paused pattern.\n     *\n     * @param {string} id Id of pattern to resume\n     * @param {IResumePatternArgs} args Resume pattern configuration object. Optional.\n     */\n    resumePattern(id: string, args?: IResumePatternArgs) {\n        logger().debug('[ecas] resumePattern', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumePattern(id, args.delay, id)\n    }\n\n\n    /**\n     * Stop pattern.\n     *\n     * @param {string} id Id of pattern to stop.\n     * @param {IStopPatternArgs} args Stop pattern configuration object. Optional.\n     */\n    stopPattern(id: string, args: IStopPatternArgs = {}) {\n        logger().debug('[ecas] stopPattern')\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.stopPattern(id, args.delay)\n    }\n\n    /* * * * * * * * * * * * *  PoolApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play Pool immediately.\n     *\n     * @param {string} id Id of Pool to play\n     * @param {IPlayPoolArgs} args Play pool configuration object\n     */\n    playPool(id: string, args?: IPlayPoolArgs) {\n        logger().debug('[ecas] playPool;', id)\n        args = Utils.defaultValue(args, {})\n\n        args.volume = Utils.defaultNumber(args.volume, 1)\n        args.pan = Utils.defaultNumber(args.pan)\n        args.loop = Utils.defaultValue(args.loop, false)\n        args.pitch = Utils.defaultNumber(args.pitch)\n        args.startItem = Utils.defaultNumber(args.startItem, null)\n        args.onEnded = Utils.defaultValue(args.onEnded, null)\n        args.onItemEnded = Utils.defaultValue<string | (() => void)>(args.onItemEnded, noop)\n\n        if (args.startTime && !isMusicalPosition(args.startTime)) {\n            args.startTime = Utils.defaultNumber(args.startTime) / 1000\n        }\n\n        if (args.duration && !isMusicalPosition(args.duration)) {\n            args.duration = Utils.defaultNumber(args.duration) / 1000\n        }\n\n        if (args.startPos && !isMusicalPosition(args.startPos)) {\n            args.startPos = Utils.defaultNumber(args.startPos) / 1000\n        }\n\n        this.#sequencer.playPool(id, args)\n    }\n\n    /**\n     * Reset pool to index 0.\n     *\n     * @param {string} id Id of Pool to play.\n     */\n    resetPool(id: string) {\n        logger().debug('[ecas] resetPool', id)\n        this.#sequencer.resetPool(id)\n    }\n    /**\n     * Pause Pool.\n     *\n     * @param {string} id Id of Pool to pause\n     * @param {IPausePoolArgs} args Pause pool configuration object\n     */\n    pausePool(id: string, args: IPausePoolArgs = {}) {\n        logger().debug('[ecas] pausePool', id)\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pausePool(id, args.delay)\n    }\n\n    /**\n     * Resume paused Pool.\n     *\n     * @param {string} id Id of pool to resume\n     * @param {IResumePoolArgs} args Resume pool configuration object\n     */\n    resumePool(id: string, args?: IResumePoolArgs) {\n        logger().debug('[ecas] resumePool', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumePool(id, args.delay)\n    }\n    /**\n     * Stop Pool.\n     *\n     * @param {string} id Id of sequence to stop.\n     * @param {IStopPoolArgs} args Stop pool configuration object. Optional.\n     */\n    stopPool(id: string, args: IStopPoolArgs = {}) {\n        logger().debug('[ecas] stopPool')\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.stopPool(id, args.delay)\n    }\n\n    /* * * * * * * * * * * * *  SoundApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play sound immediately.\n     *\n     * @param {string} id Id of sound to play.\n     * @param {IPlaySoundArgs} args Play sound configuration object. Optional.\n     */\n    async playSound(id: Sound['id'], args: IPlaySoundArgs = {}) {\n        logger().debug('[ecas] playSound', id)\n\n        if (args.loop) {\n            if (args.duration) {\n                logger().warn(\"[ecas] playSound:\", id, \"duration argument will not work when loop is true\")\n            }\n            if (args.fadeOut) {\n                logger().warn(\"[ecas] playSound:\", id, \"fadeout argument will not work when loop is true\")\n            }\n        }\n\n        const sound = this.assetHandler.soundHandler.getSound(id)\n        const initializedArgs = new PlaySoundArgs(args)\n        const play = () => this.#sequencer.playSound(sound.id, initializedArgs)\n\n        // if we can load the sound synchronously, do it\n        const details = this.assetHandler.soundHandler.details.get(id)\n        if (details !== undefined && details.isLoaded) {\n            return play()\n        }\n\n        // otherwise, load the sound asynchronously and play it when it's ready\n        // can't play sound before buffer exists\n        // if buffer has already been loaded soundHandler will return already existing buffer\n        const loadPromise = this.assetHandler.soundHandler.load([id])\n        return loadPromise.then(play).catch(logger().error)\n    }\n\n\n    /**\n     * Stop sound.\n     *\n     * @param {string} id Id of sequence to stop.\n     * @param {IStopSoundArgs} args Stop sound configuration object. Optional.\n     */\n    stopSound(id: string, args: IStopSoundArgs = {}) {\n        logger().debug('[ecas] stopSound', id, {args})\n        const initializedArgs = new StopSoundArgs(args)\n        this.#sequencer.stopSound(id, initializedArgs)\n    }\n\n    /**\n     * Resume paused sound.\n     *\n     * @param {string} id Id of sound to resume\n     * @param {IResumeSoundArgs} args Resume sound configuration object\n     */\n    resumeSound(id: string, args?: IResumeSoundArgs) {\n        logger().debug('[ecas] resumeSound', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumeSound(id, args.delay)\n    }\n\n    /**\n     * Pause sound.\n     *\n     * @param {string} id Id of sound to pause\n     * @param {IPauseSoundArgs} args Pause sound configuration object\n     */\n    pauseSound(id: string, args: IPauseSoundArgs = {}) {\n        logger().debug('[ecas] pauseSound', id)\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pauseSound(id, args.delay)\n    }\n\n    /**\n     * Stop all playing sounds.\n     */\n    stopAll(options: {onEnded?: string} = {}) {\n        logger().debug('[ecas] stopAll')\n        this.#sequencer.stopAll(options)\n    }\n\n    /* * * * * * * * * * * * *  BusApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Should typically not need to be accessed publicly, but can be useful for testing\n     * purposes.\n     */\n    busGet({busId}: {busId: string}): Bus {\n        logger().debug('[ecas] busGet', busId)\n        return this.#mixer.buses.get(busId)\n    }\n\n    busSetGain({busId, gain}: {busId: string, gain: number}) {\n        this.#mixer\n            .buses.get(busId)\n            .automator.get(\"gain\")\n            .value = gain\n    }\n\n    busAddInsert<T extends InsertTypenames>({busId, typename, ...options}: IBusIdArg & {typename: T} & InsertOptions<T>) {\n        if (isString(busId)) busId = [busId]\n        return busId.map((busId: string) => this.#mixer\n            .buses.get(busId)\n            .inserts.create(typename, options)\n        )\n    }\n\n    /**\n     * All and any insert with this id will be removed from the insert graph\n     * So make sure you use unique id's when you create the inserts please thank you.\n     */\n    busRemoveInsert({busId, insertId}: IBusIdArg & {insertId: string}) {\n        if (isString(busId)) busId = [busId]\n        return busId.map((busId: string) => this.mixer.buses.get(busId).inserts.remove(insertId))\n    }\n\n    /**\n     * @param options\n     *  - busId:\n     *      target bus(es) that insert will live on\n     *  - id:\n     *      unique name of the filter\n     *  - Q:\n     *      filter steepness, 0.0001 to 1000\n     *  - frequency:\n     *      crossover frequency in hZ: 10, to nyquist\n     *  - gain:\n     *      in decibels\n     *  - detune:\n     *      basically the same as frequency...\n     */\n    busAddFilter(options: IBusIdArg & BiquadFilterInsertOptions) {\n        return this.busAddInsert({typename: BiquadFilterInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     *  - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     */\n    busAddCompressor(options: IBusIdArg & DynamicsCompressorInsertOptions) {\n        return this.busAddInsert({typename: DynamicsCompressorInsert.typename, ...options})\n    }\n\n    /**\n     * @param busId target bus that insert to be modified lives on\n     * @param options\n     */\n    busAddAlgorithmicReverb(options: IBusIdArg & AlgorithmicReverbInsertOptions) {\n        return this.busAddInsert({typename: AlgorithmicReverbInsert.typename, ...options})\n    }\n    /**\n    * @param options -\n    *  - busId:\n    *      target bus(es) that insert will live on\n    * - id:\n    *       the name of the insert\n    * - mix:\n    *       The amount of effect to be applied to the signal. Defaults to 1 (100%).\n    * - impulseResponse:\n    *       the id of the sound to use for impulse\n    * - mix:\n    *       wetness 0 - 1, default 1\n    * - normalize:\n    *       should the impulse response file be peak normalized\n    * - reverse:\n    *       should the impulse signal be reversed\n    */\n    busAddConvolverReverb(options: IBusIdArg & ConvolverReverbInsertOptions) {\n        return this.busAddInsert({typename: ConvolverReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     *  - busId:\n     *      target bus(es) that insert will live on\n     * - id: The name of the insert\n     * - maxDelayTime:\n     *     The maximum delay time for the node, in seconds. Defaults to 1.\n     * - delayTime:\n     *      The initial delay time for the node, in seconds. The default is 0.\n     * - feedback:\n     *      The amount of feedback, between 0, 1. Default 0.2\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     */\n    busAddDelay(options: IBusIdArg & DelayInsertOptions) {\n        return this.busAddInsert({typename: DelayInsert.typename, ...options})\n    }\n\n    busAddPingPongDelay(options: IBusIdArg & PingPongInsertOptions) {\n        return this.busAddInsert({typename: PingPongDelayInsert.typename, ...options})\n    }\n\n    busModifyInsert<T extends InsertTypenames>({busId, typename, duration, ...options}: IBusApplyEnvelopeOptions & {typename: T} & InsertClass<T>[\"getOptions\"]) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => {\n            const insert = this.#mixer.buses.get(busId).inserts.get(options.id)\n            if (is(insert, typename)) {\n                const endTime = this.#chrono(duration)\n                insert.modify(options, endTime, this.#audioContext.sampleRate)\n            }\n        }\n        return Promise.all(busId.map(applier))\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     *      min: 0, max: 1, default: 1 (100%)\n     * - time:\n     *      in seconds, min: 0.001, max: 10, default: 0.2\n     * - decay:\n     *      in seconds,min: 0.001, max: 10, default: 0.2\n     * - reverse:\n     *      is it a good idea to reverse time?\n     * - duration: - the amount of time, in seconds, to reach target options\n     */\n    busModifyAlgorithmicReverb(options: IBusApplyEnvelopeOptions & AlgorithmicReverbInsertOptions) {\n        return this.busModifyInsert({typename: AlgorithmicReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     * - impulseResponse:\n     *      the id of the sound to use for impulse\n     * - mix:\n     *      wetness 0 - 1, default 1\n     * - normalize:\n     *      should the impulse response file be peak normalized\n     * - reverse:\n     *      should the impulse signal be reversed\n     * - duration - the amount of time, in seconds, to reach target options\n     */\n    busModifyConvolverReverb(options: IBusApplyEnvelopeOptions & ConvolverReverbInsertOptions) {\n        return this.busModifyInsert({typename: ConvolverReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the delay\n     * - maxDelayTime:\n     *     The maximum delay time for the node, in seconds. Defaults to 1.\n     * - delayTime:\n     *      The initial delay time for the node, in seconds. The default is 0.\n     * - feedback:\n     *      The amount of feedback, between 0, 1. Default 0.2\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     * - duration - the amount of time, in seconds, to reach target options\n     */\n    busModifyDelay(options: IBusApplyEnvelopeOptions & DelayInsertOptions) {\n        return this.busModifyInsert({typename: DelayInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     *  - id: name of your insert\n     *  - Q:\n     *      filter steepness, 0.0001 to 1000\n     *  - frequency:\n     *      crossover frequency in hZ: 10, to nyquist\n     *  - gain:\n     *      in decibels\n     *  - detune:\n     *      basically the same as frequency...\n     * - duration\n     */\n    busModifyFilter(options: IBusApplyEnvelopeOptions & BiquadFilterInsertOptions) {\n        return this.busModifyInsert({typename: BiquadFilterInsert.typename, ...options})\n    }\n\n    /**\n     * @param options\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      id use the same id as when you did addFilterToBus\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * - duration\n     */\n    busModifyCompressor (options: IBusApplyEnvelopeOptions & DynamicsCompressorInsertOptions) {\n        return this.busModifyInsert({typename: DynamicsCompressorInsert.typename, ...options})\n    }\n\n    /**\n     * Analyse bus.\n     *\n     * @param {IAnalyseBusArgs} args Analyse bus configuration object. Optional.\n     */\n    busAnalyse(args: IAnalyseBusArgs = {}) {\n        args.callback = Utils.defaultValue(args.callback, noop)\n        args.bus = Utils.defaultValue(args.bus, \"master\")\n        args.config = Utils.defaultValue(args.config, new AnalyserConfig())\n\n        // TODO: Temporarily we just set up a VU meter here, useful in e2e tests.\n        // Post MVP the analyzer spec will be defined, and API as well as features will change\n        const smoothingTime = args.config ? args.config.smoothingTimeConstant : 0.95\n        if (!this.#busMeters) {\n            this.#busMeters = {}\n        }\n        const meter: VolumeMeter = new VolumeMeter(smoothingTime, (data) => {\n            args.callback(args.bus, data)\n        })\n        this.#busMeters[args.bus] = meter\n        const analyser = meter.create(this.#audioContext)\n        this.#mixer.buses.get(args.bus).output.connect(analyser)\n    }\n\n\n    /**\n     * Remove an analyser from a bus. If not removed analyser will keep running, eating precious CPU cycles.\n     *\n     * @param {string} busId ID of bus to remove analyser from.\n     */\n    busRemoveAnalyser(busId: string) {\n        busId = Utils.defaultValue(busId, MASTER_BUS_ID)\n        this.#busMeters[busId].destroy()\n    }\n\n    busApplyEnvelope({busId, ...options}: IBusIdArg & ApplyEnvelopeOptions<Bus>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.applyEnvelope({automator: this.mixer.buses.get(busId).automator, ...options})\n        return Promise.all(busId.map(applier))\n    }\n\n    busCancelEnvelope({busId, ...options}: IBusIdArg & CancelEnvelopeOptions<Bus>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.cancelEnvelope({automator: this.mixer.buses.get(busId).automator, ...options})\n        return Promise.all(busId.map(applier))\n    }\n\n    busCancelEnvelopeOnInsert({busId, insertId, ...options}: IBusApplyEnvelopeToInsertOptions & CancelEnvelopeOptions<Bus>): Promise<void[]> {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.cancelEnvelope({\n            automator: this.mixer\n                .buses.get(busId)\n                .inserts.get(insertId)\n                .automator as any,\n            ...options\n        })\n        return Promise.all(busId.map(applier))\n    }\n\n\n    /** Chose to put all args in object for these functions becasuse argument list was becoming long, not sure how we should do with the api methods with less arguments\n     * Also these aren't strictly necessary since you can use busApplyEnvelopeToInsert and all you need to do extra is specify typename for the insert\n     */\n    // busApplyEnvelopeToCompressor(options: {busId: string, insertId: string} & ApplyEnvelopeOptions<DynamicsCompressorInsert>) {\n    busApplyEnvelopeToCompressor(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<DynamicsCompressorInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: DynamicsCompressorInsert.typename})\n    }\n\n    busApplyEnvelopeToAlgorithmicReverb(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<AlgorithmicReverbInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: AlgorithmicReverbInsert.typename})\n    }\n\n    busApplyEnvelopeToFilter(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<BiquadFilterInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: BiquadFilterInsert.typename})\n    }\n\n    busApplyEnvelopeToDelay(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<DelayInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: DelayInsert.typename})\n    }\n\n    busApplyEnvelopeToPingPongDelay(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<PingPongDelayInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: PingPongDelayInsert.typename})\n    }\n\n    busApplyEnvelopeToConvolverReverb(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<ConvolverReverbInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: ConvolverReverbInsert.typename})\n    }\n\n    /** We need the typename strictly for making sure we're not trying to configure the wrong type of insert */\n    busApplyEnvelopeToInsert<T extends InsertTypenames>({busId, insertId, typename, ...options}: IBusApplyEnvelopeToInsertOptions & {typename: T} & IApplyEnvelopeOptions<AutomatableParameters<InsertClass<T>>>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => {\n            const insert = this.#mixer.buses.get(busId).inserts.get(insertId)\n            if (is(insert, typename)) {\n                // we assume that the automator has the correct type since we have checked that the insert is the specified type.\n                const automator = insert.automator as InsertClassAutomator<T>\n                return this.applyEnvelope({automator, ...options})\n            }\n            return Promise.reject(`no insert with id: ${insertId} found on bus: ${busId}`)\n        }\n        return Promise.all(busId.map(applier)) //forEach? do we use the returned values anywhere?\n    }\n    /** BusApi End */\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "export const version = '2.1.2'\n", "import { version } from './version'\n\nconst navigatorExists = (): boolean => {\n  return typeof navigator !== 'undefined'\n}\n\nconst hasFancyConsole = (hasNavigator?: boolean): boolean => {\n  return (hasNavigator ?? navigatorExists()) && /chrome|firefox/i.test(navigator?.userAgent.toLowerCase())\n}\n\nconst createMessage = (version: string, fancy: boolean): string[] => {\n  const text = `\uD83C\uDFB5 ECAS: v${version} \uD83C\uDFB5`\n  if (fancy) {\n    const message = `\\n%c${text}%c\\n\\n`\n    const style = 'color: #FFFFFF; background: #ff7373; padding:10px'\n    const padding = 'padding:0'\n    return [message, style, padding]\n  } else {\n    const dottedLone = text.split('').map(() => '.').join('')\n    const message = `${dottedLone}\\n${text}\\n${dottedLone}`\n    return [message]\n  }\n}\n\n/**\n * @example\n * Pass in the ecas-logger to be able to turn on or off version display with the logger option\n * ```ts\n * logEcasVersion(logger().log)\n * ```\n */\nexport const logEcasVersion = (logger: Console['log']): void => {\n  logger(...createMessage(version, hasFancyConsole()))\n}\n\nexport const Test = {\n  navigatorExists,\n  hasFancyConsole,\n  createMessage\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { StrictMap } from \"@netent-tech/ecas-utils\"\r\n\r\ntype CallbackType = (...args: any[]) => any\r\n\r\nexport class Observable {\r\n    #record = new StrictMap<string, Array<CallbackType>>()\r\n\r\n    /**\r\n     * Adds the event listener.\r\n     *\r\n     * @param {string} event - The event to listen to.\r\n     * @param {CallbackType} listener - The listener that is called when the event is emitted.\r\n     * @throws {Error} If the parameters are not provided correctly.\r\n     * @returns {void}\r\n     */\r\n    on(event: string, listener: CallbackType): void {\r\n        if (this.#record.has(event)) {\r\n            this.#record.get(event).push(listener)\r\n        }\r\n        else {\r\n            this.#record.set(event, [listener])\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the event listener.\r\n     *\r\n     * @param {string} event - The event to remove.\r\n     * @param {Function} listener - The listener that is called when the event is emitted.\r\n     * @throws {Error} If the parameters are not provided correctly.\r\n     * @returns {boolean} Wether or not the event listener was removed.\r\n     */\r\n    off(event: string, listener: CallbackType): boolean {\r\n        if (!this.#record.has(event)) {\r\n            logger().error(`[ecas] cannot remove event: ${event} since it does not exist`)\r\n            return false\r\n        }\r\n\r\n        const callbacks = this.#record.get(event)\r\n        const callbacksFiltered = callbacks.filter((callback: CallbackType) => callback !== listener)\r\n\r\n        if (callbacksFiltered.length !== callbacks.length) {\r\n            this.#record.set(event, callbacksFiltered)\r\n            return true\r\n        }\r\n\r\n        return false\r\n    }\r\n\r\n    /**\r\n     * Emits the event along with the provided arguments.\r\n     *\r\n     * @param {string} event - The event to emit.\r\n     * @param {Array<any>} eventArguments - The event arguments\r\n     * @returns {void}\r\n     */\r\n    emit(event: string, ...args: Array<any>): void {\r\n        if (this.#record.has(event)) {\r\n            for (const callback of this.#record.get(event)) {\r\n                callback(...args)\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { Assert, AssertExists, AssertObjectNotEmpty, Disposable, Exists, isObject } from '@netent-tech/ecas-utils'\r\nimport { IAudioState, ILoadrConfig, StateConfig } from \"@netent-tech/ecas-common\"\r\n\r\ninterface IAudioStateWithParent extends IAudioState {\r\n    parent: string\r\n}\r\n\r\nconst GENESIS = 'genesis' as const\r\n\r\ntype StateName = string\r\n\r\nexport class StateMachine implements Disposable {\r\n    private _activeStateName: StateName\r\n    private _activeState: IAudioStateWithParent\r\n    private _states = new Map<string, IAudioStateWithParent> ()\r\n\r\n    dispose() {\r\n        this.states.clear()\r\n    }\r\n\r\n    constructor(audioStates: StateConfig, loaderConfig: Readonly<ILoadrConfig>) {\r\n        this._activeStateName = this.getInitialStateName(loaderConfig)\r\n\r\n        // Create State Map\r\n        let full: string = GENESIS\r\n        const iter = (state: IAudioState, name = '', parent = '', sep = '::') => {\r\n            const children = state.children\r\n            full = name ? `${full}${sep}${name}` : full\r\n            this.addState(full, state, parent)\r\n\r\n            for (const child_name in children) {\r\n                const childState = Exists(\r\n                    children[child_name], \r\n                    `StateHandler.constructor.iter(); child state with name ${child_name} does not exist in children.`\r\n                )\r\n                iter(childState, child_name, full)\r\n            }\r\n            full = full.slice(0, full.length - name.length - sep.length)\r\n        }\r\n\r\n        const genesisState = Exists(audioStates[GENESIS], \r\n            `StateHandler.constructor(); state_config[${GENESIS}] does not exist in audio-states.`\r\n        )\r\n\r\n        iter(genesisState)\r\n\r\n        this._activeState = Exists(this._states.get(this._activeStateName), \r\n            `activeStateName: ${this._activeStateName} does not exist in strarr([...this._states.keys()])}`\r\n        )\r\n\r\n        this.saveStateToLocalStorage(this._activeStateName)\r\n        logger().table('[ecas] states:'); logger().table([...this._states.keys()])\r\n    }\r\n\r\n    get states() {\r\n        return this._states\r\n    }\r\n\r\n    getInitialStateName (loaderConfig: ILoadrConfig): string {\r\n        const name = this.readStateNameFromLocalStorage()\r\n        if (name !== null && this._states.has(name)) {\r\n            return name\r\n        }\r\n        if(loaderConfig.initState) {\r\n            return loaderConfig.initState\r\n        }\r\n        return GENESIS\r\n    }\r\n\r\n    readStateNameFromLocalStorage (): string | null {\r\n        const localStorageState = localStorage.getItem(\"ECAS_AUDIO_STATE\")\r\n        logger().debug(`[ecas] read state ${localStorageState} from localStorage`)\r\n\r\n        return localStorageState\r\n    }\r\n\r\n    saveStateToLocalStorage (name: string): void {\r\n        logger().debug(\"[ecas] save state to localstorate\", name)\r\n        const localStorageName = 'ECAS_AUDIO_STATE'\r\n        localStorage.setItem(localStorageName, name)\r\n    }\r\n\r\n    addState(name: string, state: IAudioState, parent = '') {\r\n        const stateWithParent: IAudioStateWithParent = {\r\n            ...state,\r\n            parent: parent\r\n        }\r\n\r\n        Assert(!this._states.has(name), \r\n            \"[ecas] cannot add the state since it already exist on the same level.. E.g Another state with the same name and iheritance was already added.\")\r\n\r\n        if (parent) {\r\n            const parent_state = Exists(this._states.get(parent), \r\n                `[ecas] state.parent = ${parent} does not exist on name: ${name}. Existing states are: ${[...this._states.keys()]}}`)\r\n\r\n            AssertExists(parent_state.children, \r\n                `[ecas] parent_state.children does not exist in: ${parent_state}`)\r\n\r\n            AssertObjectNotEmpty(parent_state.children, \r\n                `[ecas] parent_state.children is empty in ${parent_state}`)\r\n\r\n            // Add all the parent events to the child\r\n            stateWithParent.events = {\r\n                ...this.getState(parent).events,\r\n                ...stateWithParent.events\r\n            }\r\n\r\n        }\r\n\r\n        this._states.set(name, stateWithParent)\r\n    }\r\n\r\n    /**\r\n     * Triggers a state change if the event is mapped to a connected state.\r\n     */\r\n    triggerStateChange(gameEvent: string, ...args: readonly unknown []): void {\r\n        logger().debug('[ecas] trigger state change', gameEvent, ...args)\r\n\r\n        const shouldMoveToParentState = this._shouldChangeState(this._activeState.deactivatesOn, gameEvent, args)\r\n        // need to loop through here and see if any parent state activates / deactivates on\r\n\r\n        if (shouldMoveToParentState) {\r\n            this.changeState(this._activeState.parent)\r\n        }\r\n\r\n        for (const child_name in this._activeState.children) {\r\n            const child = Exists(this._activeState.children[child_name], \r\n                `[ecas] child: ${child_name} does not exist in states.`\r\n            )\r\n            const shouldMoveToChildState = this._shouldChangeState(child.activatesOn, gameEvent, args)\r\n\r\n            if (shouldMoveToChildState) {\r\n                this.changeState(`${this._activeStateName}::${child_name}`)\r\n                break\r\n            }\r\n        }\r\n    }\r\n\r\n    changeState (stateName: string): void | never {\r\n        logger().info(`[ecas] moving from state: ${this._activeStateName} to ${stateName}`)\r\n        this._activeState = Exists(this._states.get(stateName), \r\n            `[ecas] could not find state: ${stateName}`)\r\n        this._activeStateName = stateName\r\n\r\n        this.saveStateToLocalStorage(this._activeStateName)\r\n    }\r\n\r\n    get activeStateName (): string {\r\n        return this._activeStateName\r\n    }\r\n\r\n    /**\r\n     * Checks if the state is changed by the game event and the arguments.\r\n     */\r\n    private _shouldChangeState(activation: StateConfig[keyof StateConfig]['activatesOn' | 'deactivatesOn'], eventName: string, eventArguments: readonly unknown [] = []): boolean {\r\n        const matches = activation.filter((act) => {\r\n            if (isObject(act)) {\r\n                const eventNamesCorrespond = act.event === eventName\r\n                const everyEntry = act.values.every((entry) => {\r\n                    return eventArguments.includes(entry)\r\n                })\r\n                return eventNamesCorrespond && everyEntry\r\n            }\r\n            return act === eventName\r\n        })\r\n        const anyMatches = matches.length > 0\r\n        return anyMatches\r\n    }\r\n\r\n    get activeState () {\r\n        return Exists(this._states.get(this._activeStateName),\r\n            `[ecas] supposedly active state: ${this._activeStateName} not found in states.`)\r\n    }\r\n\r\n    getState (name: string) {\r\n        return Exists(this._states.get(name), \r\n            `[ecas] state ${name} does not exist`)\r\n    }\r\n\r\n    get state () {\r\n        return this._activeStateName\r\n    }\r\n}\r\n", "import { type ValueOrRandom } from '../../ecas-engine-api/RandomNotation'\n\nexport const TranslationProps = {\n  min: 'min',\n  max: 'max',\n  in: 'in',\n  out: 'out',\n  param: 'param'\n} as const\ninterface IParam {\n  [TranslationProps.param]: number\n}\n\nexport interface IBasicTranslation {\n  [TranslationProps.in]: number\n  [TranslationProps.out]: ValueOrRandom\n}\nexport interface IMinMaxTranslation extends IParam {\n  [TranslationProps.min]: IBasicTranslation\n  [TranslationProps.max]: IBasicTranslation\n}\n\nexport type Translation = IBasicTranslation & IParam | IMinMaxTranslation\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "import { type Identifiable, type ITypeNamed } from '@netent-tech/ecas-utils'\nimport { type Automator, type AutomatableParameters } from '@netent-tech/ecas-automator'\nimport { type AlgorithmicReverbInsert, type BiquadFilterInsert, type DynamicsCompressorInsert, type ConvolverReverbInsert, type DelayInsert, type PingPongDelayInsert } from '@netent-tech/ecas-inserts'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type Sound } from '..'\n\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nexport interface ConvolverReverbInsertOptions extends Identifiable {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: Sound['id']\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { type LoggerName } from '@netent-tech/ecas-logger'\nimport type { IForcePolyfill, Sound } from '../..'\n\nexport enum AudioFileExtension {\n  CAF = '.caf',\n  WEBM = '.webm',\n  MP4 = '.mp4',\n  OGG = '.ogg',\n  MP3 = '.mp3',\n  WAV = '.wav'\n}\n\nexport interface ILoadrConfig {\n  /** Force ecas to use a package with the same id for example to force load mobile package on desktop. */\n  packageToUse?: string\n  forcePolyfills?: IForcePolyfill\n  /** For testing purposes - force Ecas to load a specified file extension such as \".mp3\", \".webm\"  */\n  fileExtToUse?: AudioFileExtension\n  /** Force Ecas StateHandler to load a specified state on initialization, otherwise will load genesis state. */\n  initState?: string\n  /** true will load all sounds, array of strings will load those specified sounds */\n  preload?: boolean | Array<Sound['id']>\n  /** The data generated by ecas-encoder which contains the sound id and its duration */\n  soundData?: Map<string, number> | Array<[string, number]>\n  /** Should audio context automatically be paused when invisible and unpaused when visible */\n  pauseOnInvisible?: boolean\n  /** Should audio context automatically be resumed when visible and unpaused when visible */\n  resumeOnVisible?: boolean\n  /** Should audio output be muted when window is invisible */\n  muteOnInvisible?: boolean\n  /** Should audio output be unmuted when window is visible */\n  unmuteOnVisible?: boolean\n  /** Use logger for debugging. Defaults to 'none'\n     * @param logger \"none\" | \"console\" | \"timestamp\"\n     */\n  logger?: LoggerName\n  /**\n     * if these game events where triggered before AudioContext was unlocked, the will fire once it is unlocked.\n     * So if game sends a \"start-main-music\" event before AudioContext could be started (due to no user interaction)\n     * then that event will be queued and fired on the first user interaction.\n     * use true to queue all events\n     * use an array of gameEvent names to queue only those events\n     */\n  queue?: true | string[]\n}\n", "import { type ITypeNamed, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { MASTER_BUS_ID } from '../..'\nimport { type MinusOneToOneNumber } from './MinusOneToOne'\nimport { type ZeroToOneNumber } from './ZeroToOne'\n\nconst typename = 'BusConfig' as const\n\n/** Settings for Summing-Buses. */\nexport class BusConfig implements ITypeNamed<typeof typename> {\n  static typename: typeof typename = typename\n  typename: typeof typename = BusConfig.typename\n\n  /** Bus id */\n  id = 'mainBus'\n\n  /** Starting bus volume. */\n  volume: ZeroToOneNumber = 1\n\n  /** Starting bus pan. */\n  pan: MinusOneToOneNumber = 0\n\n  /** Id of bus to send post-fader output to. Optional, defaults to 'master' */\n  destination: string = MASTER_BUS_ID\n\n  constructor (busProps: PartialProperties<BusConfig> = {}) {\n    Object.assign(this, busProps)\n  }\n\n  // Effects?\n}\nexport default BusConfig\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\nexport class Group {\n  /** Group id. */\n  id = 'mainGroup'\n\n  /** Encoding format preset to use for the group. */\n  format = 'mainFormat'\n\n  /** Target bus. Defaults to 'master' */\n  bus = 'master'\n\n  /** Limit number of sounds that can play simultaneously on the bus.\n     * If limit is exceeded last triggered sound will take over from oldest triggered.\n     * Todo: Should be renamed to maxNumberOfSimultaneusSounds?\n     **/\n  limit = Number.MAX_SAFE_INTEGER\n\n  /**\n     * Crossfade time in milliseconds when group limit is active and a sound takes over from another.\n     **/\n  crossfade = 10\n\n  /**\n     * Duration in milliseconds in which triggering of sounds in the group should be blocked after previous trigger.\n     * Todo: should be renamed stealTime\n     **/\n  triggerLimit = 0\n\n  constructor (props: PartialProperties<Group> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default Group\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\n/** List of envelope points. */\nexport class EnvelopeData {\n  /**\n     * Envelope point position, in 'bar.beat.tick' or millisecond format.\n     * The size of a tick is 32 per beat.\n     * So with a time signature where each beat is a quarter (4/4 or 3/4), 8 ticks would be a 16th note and 16 ticks an 8th.\n     **/\n  pos = 0 // Position = \"0.0.0\"\n\n  /**\n     * Value to set property to.\n     * Available range will very depending on what you are modulating, for example volume is between 0-1 and pan between -1 to 1.\n     * Use 'current' to indicate value should be original value before envelope started.\n     * Maybe this can also hold randomized values? I don't know if it should be able to but I will make it so for now.\n     **/\n  // val: \"current\" | number | DefaultParameterType<number> = \"current\"\n  val: 'current' | 'default' | number = 'current'\n\n  constructor (props: PartialProperties<EnvelopeData> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default EnvelopeData\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EnvelopeData } from './EnvelopeData'\nimport { type EnvelopePresetParams } from './Types'\n\nexport class EnvelopePreset {\n  /** Envelope ID. */\n  id = ''\n\n  /** Parameter to modulate, for example 'volume' or 'pan'. */\n  param: EnvelopePresetParams = 'volume'\n  data: EnvelopeData[] = []\n\n  /** Todo: added when mergin soundconfigs */\n  busId?: string\n\n  constructor (props: DeepPartialProperties<EnvelopePreset | Readonly<EnvelopePreset>> = {}) {\n    Object.assign(this, props)\n    if (props.data != null) {\n      this.data = props.data.map((d) => new EnvelopeData(d))\n    }\n  }\n}\n\nexport default EnvelopePreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EnvelopePreset } from './EnvelopePreset'\nimport { type DelayType, type PanType, type PitchType, type TimeSignature, type VolumeType } from './Types'\n\n/**\n * A pattern allows playing back multiple sounds at the same time, but can also put an individual sound in a context which allows for modifying volume and pan.\n **/\nexport class Pattern {\n  /**\n     * If pattern item should be a sound, specify sound id here. Optional.\n     **/\n  sound?: string\n\n  /** Todo: added when merging soundConfig Types */\n  sequence?: string\n\n  /** Todo: added when merging soundConfig Types */\n  parentId?: string\n\n  /**\n     * If true, item will keep looping until pattern is stopped.\n     * Only applicable if 'sound' is specified for the pattern item.\n     **/\n  loop = false\n\n  /**\n     * Volume to play sound at. Only applicable if 'sound' is specified for the pattern item.\n     **/\n  volume: VolumeType = 1\n\n  /**\n     * Used to send arguments to synthesized sounds.\n     * Although I don't think this is actually implemented?\n     **/\n  args: object[] = []\n\n  /**\n     * Pan to play sound with. Only applicable if 'sound' is specified for the pattern item.\n     * */\n  // Validate sound is specified if this is specified\n  pan: PanType = 0\n\n  /** Pitch offset for sounds in cents. */\n  pitch: PitchType = 0\n\n  /**\n     * Start position value in milliseconds.\n     * Only applicable if 'sound' is specified for the pattern item.\n     **/\n  startPos: DelayType = 0\n\n  /** Delay value in milliseconds */\n  delay: DelayType = 0\n\n  /** Duration value in milliseconds.  Only applicable if 'sound' is specified for the pattern item. */\n  duration?: DelayType\n\n  /**\n     * If pattern item should be a envelope, specify envelope preset id or envelope data here. Optional.\n     **/\n  envelope?: EnvelopePreset\n\n  /**\n     * bus to apply envelope to. Only applicable if 'envelope' is specified for the pattern item.\n     * You can provide either soundId or bussId.\n     * If you do not provide either, envelope will apply to all sounds in pattern.\n     **/\n  // Validate envelope is specified and soundId is not\n  bussId?: string\n\n  /**\n     * Sound to apply envelope to. Only applicable if 'envelope' is specified for the pattern item.\n     * You can provide either soundId OR bussId.If you do not provide either, envelope will apply to all sounds in pattern.\n     **/\n  soundId?: string\n\n  /**\n     * If pattern item should be another pattern, specify pattern id here. Optional.\n     **/\n  pattern?: string\n\n  /**\n     * If pattern item should be a pool, specify pool id here. Optional.\n     **/\n  // Validate pool id exists\n  pool?: string\n\n  constructor (props: DeepPartialProperties<Pattern> = {}) {\n    Object.assign(this, props)\n    function isEnvelopePreset (thing: typeof props.envelope): thing is EnvelopePreset {\n      return thing !== undefined && typeof thing !== 'string'\n    }\n    if (isEnvelopePreset(props.envelope)) {\n      this.envelope = new EnvelopePreset(props.envelope)\n    }\n  }\n}\n\n/**\n * Patterns allows playing back multiple sounds at the same time, but can also put an individual sound in a context which allows for modifying volume and pan.\n **/\nexport class PatternWrapper {\n  /** Pattern id. */\n  id = ''\n\n  sync?: boolean\n\n  /** Pattern definition */\n  pattern: Pattern[] = []\n\n  /** Pattern tempo. Will override global tempo when pattern is played. */\n  tempo?: number\n\n  /**\n     * Resolution used for quantized events.\n     * Can either be whole number for bars, or fraction for quarter note, eight or 16th.\n     * Will override global trigger quantize when specified.\n     * */\n  triggerQuantize?: number = 1 // 4/4\n\n  /** Time signature. For example \"4/4\" or \"3/4\". Will override global time signature when specified. */\n  timeSignature?: TimeSignature\n\n  constructor (props: DeepPartialProperties<PatternWrapper> = {}) {\n    Object.assign(this, props)\n    if (props.pattern !== undefined && props.pattern !== null) {\n      this.pattern = props.pattern.map((pattern) => new Pattern(pattern))\n    }\n  }\n}\n\nexport default PatternWrapper\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { type DelayType, type PanType, type PitchType, type PoolItemTypes, type VolumeType } from './Types'\n\n/**\n * Pool item. Use target to set target sound, pattern or pool and set type accordingly. type defaults to 'sound',\n **/\nexport class PoolItem {\n  /**\n     * Use target to set target sound id, pattern id or pool id.\n     **/\n  target = ''\n\n  /**\n     * Defaults to sound, but should be set according to target id: 'sound' | 'pattern' | 'pool'\n     * */\n  type: PoolItemTypes = 'sound'\n\n  /** If pool item should loop */\n  loop = false\n  volume: VolumeType = 1\n  pan: PanType = 0\n  pitch: PitchType = 0\n  delay: DelayType = 0\n  startPos: DelayType = 0\n  duration?: DelayType\n\n  constructor (props: DeepPartialProperties<PoolItem> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default PoolItem\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { PoolItem } from './PoolItem'\nimport { type PoolTypes } from './Types'\n\n/**\n * A sound pool will play a different sound on each trigger.\n **/\nexport class Pool {\n  /**\n     * Pool Id\n     */\n  id = ''\n\n  /**\n     * Array of pool items.\n     */\n  items: PoolItem[] = []\n\n  /**\n     * Type of pool, Can be either 'random' or 'sequential'.\n     * A random pool with play back according a random shuffle, and sequential will play back in the order sounds are listed.\n     **/\n  type: PoolTypes = 'sequential'\n\n  /**\n     * Weighting determining how often each sound will play.\n     * An array, where index of each number should be the same as the list of sounds for the pool.\n     * For random pools a higher number means higher chance of a sound being selected,\n     * and if sequential: sound will be duplicated in the sequence corresponding number of times.\n     * Optional and defaults to even weight for each sound.\n     **/\n  priority?: number[]\n\n  /**\n     * Max number of simultaneus sounds this pool can play. Set 1 for monophonic.\n     */\n  limit?: number = 100\n\n  constructor (props: DeepPartialProperties<Pool> = {}) {\n    Object.assign(this, props)\n    if (props.items != null) {\n      this.items = props.items.map((item) => new PoolItem(item))\n    }\n  }\n}\n\nexport default Pool\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type AcceptedExtensions, type Channels } from './Types'\n\n/** List of encoder formats and their settings. */\nexport class EncoderSettings {\n  /**\n     * Specifies encoded sounds extensions \"wav\" | \"mp3\" | \"ogg\" | \"mp4\" |  \"webm\" | \"opus\"\n     * */\n  format: AcceptedExtensions = 'webm'\n\n  /**\n     * Bitrate to use for specified format in kbps.\n     */\n  bitrate = 128\n\n  /**\n     * Channels to use in encoded file. 1 = mono, 2 = stereo. Will be upmixed/downmixed if source channels does not match.\n     */\n  channels: Channels = 2\n\n  constructor (props: PartialProperties<EncoderSettings> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default EncoderSettings\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EncoderSettings } from './EncoderSettings'\n\n/** Presets for encoder representing how to encode the sound files. */\nexport class EncoderPreset {\n  /** Presets formats ID */\n  id = ''\n\n  /**\n     * List of encoder formats and their settings\n     * */\n  formats: EncoderSettings[] = []\n\n  constructor (props: DeepPartialProperties<EncoderPreset> = {}) {\n    Object.assign(this, props)\n    if (props.formats != null) {\n      this.formats = props.formats.map((format) => new EncoderSettings(format))\n    }\n  }\n}\n\nexport default EncoderPreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { EncoderPreset } from './EncoderPreset'\n\n/** Stores encoder formats and their settings. */\nexport class FormatPreset {\n  /** Package Identifier */\n  package = 'default'\n\n  /** Encoder presets */\n  presets: EncoderPreset[] = []\n\n  constructor (props: DeepPartialProperties<FormatPreset> = {}) {\n    Object.assign(this, props)\n    if (props.presets != null) {\n      this.presets = props.presets.map((preset) => new EncoderPreset(preset))\n    }\n  }\n}\n\nexport default FormatPreset\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport { FormatPreset } from './FormatPreset'\nimport { type QuantizeType, type TimeSignature } from './Types'\n\nexport class Settings {\n  /**\n     * Path to directories where to find the source audio files for encoding.\n     * */\n  sourcePaths: string[] = []\n\n  /**\n     * Path to directory in which to write encoded files.\n     * */\n  targetPath = 'sounds'\n\n  /**\n     * Path to directory from which to load encoded files from during runtime.\n     */\n  loadPath = 'sounds'\n\n  /**\n     * Presets for Encoder.\n     */\n  formatPresets: FormatPreset[]\n\n  /**\n     * Global tempo used for tempo sync. Will be overridden if specified in pattern.\n     */\n  tempo = 120\n\n  /** Global resolution used for quantized events.\n     * Can either be whole number for bars, or fraction for quarter note, eigth or 16th.\n     * Default if not specified is 1 bar.\n     * Will be overridden if specified in pattern.\n     * */\n  triggerQuantize: QuantizeType = 1\n\n  /** Is not actually implemented in ECAS so does absolutely nothing. */\n  patternQuantize: QuantizeType = 1\n\n  /** Global time signature.\n     * For example \"4/4\" or \"3/4\".\n     * Default if not specified is \"4/4\".\n     * Will be overridden if specified in pattern.\n     */\n  timeSignature: TimeSignature = '4/4'\n\n  constructor (props: DeepPartialProperties<Settings> = {}) {\n    Object.assign(this, props)\n    if (props.formatPresets != null) {\n      this.formatPresets = props.formatPresets.map((preset) => new FormatPreset(preset))\n    } else {\n      this.formatPresets = createDefaultFormatPresets()\n    }\n  }\n}\n\nfunction createDefaultFormatPresets (): FormatPreset[] {\n  return [\n    new FormatPreset({\n      package: 'desktop',\n      presets: [{\n        id: 'mainFormat',\n        formats: [\n          { format: 'webm', bitrate: 112, channels: 2 },\n          { format: 'mp4', bitrate: 112, channels: 2 }\n        ]\n      }, {\n        id: 'effectsFormat',\n        formats: [\n          { format: 'webm', bitrate: 112, channels: 2 },\n          { format: 'mp4', bitrate: 112, channels: 2 }\n        ]\n      }\n      ]\n    }),\n    new FormatPreset({\n      package: 'mobile',\n      presets: [\n        {\n          id: 'mainFormat',\n          formats: [\n            { format: 'webm', bitrate: 64, channels: 1 },\n            { format: 'mp4', bitrate: 64, channels: 1 }\n          ]\n        },\n        {\n          id: 'effectsFormat',\n          formats: [\n            { format: 'webm', bitrate: 64, channels: 1 },\n            { format: 'mp4', bitrate: 64, channels: 1 }\n          ]\n        }\n      ]\n    })\n  ]\n}\n\nexport default Settings\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\n/**\n * Sound Specific Encoding settings.\n * Probably mostly usefull if you want to automatically speed up sound in encoding.\n **/\nexport class SoundEncoding {\n  /**\n     * Ratio at which to speed up / down the sound, 1 will be no change, 0.5 half, 2 double etc...\n     **/\n  speed = 1\n\n  /**\n     * If you want to pitch the sound during encoding\n     **/\n  pitch = 1\n\n  /**\n     * You can specify target sample rate, otherwise will use same as sound input sample rate\n     **/\n  //     sampleRate = 48000\n\n  constructor (props: PartialProperties<SoundEncoding> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default SoundEncoding\n", "import { type DeepPartialProperties, type ITypeNamed } from '@netent-tech/ecas-utils'\nimport SoundEncoding from './SoundEncoding'\nimport { type BufferOrElementOrSynthesizedType, type PanType, type PitchType, type VolumeType } from './Types'\n\nconst TYPENAME = 'sound' as const\n/** Configured sound for encoding and playback. */\nexport class Sound implements ITypeNamed<typeof TYPENAME> {\n  static typename = TYPENAME\n  typename = TYPENAME\n\n  /** Sound ID.\n     * Should correspond to filename of source file, minus extension.\n     **/\n  id = ''\n\n  /**\n     * ID of the group that this sound should be associated with.\n     * Will determine encoding settings and what bus sound is routed through.\n     **/\n  group = 'mainGroup'\n\n  /**\n     * Type can be either 'buffer' or 'element' and defaults to buffer.\n     * A buffer sound will loop without a gap and trigger with minimal latency, but will be decoded to 32bit PCM in advanced resulting in high memory consumption.\n     * Use 'element' where applicable to preserve memory.\n     **/\n  type: BufferOrElementOrSynthesizedType = 'buffer'\n\n  /**\n     * Duration in milliseconds in which triggering of sound should be blocked after previous trigger.\n     **/\n  triggerLimit = 0\n\n  /**\n     * Requested\n     * limit:\n     * crossfade:\n     */\n\n  /**\n     * Pitch offset for sounds in cents.\n     * Affects the AudioBufferSource Detune Parameter which is a k-rate AudioParam representing detuning of playback in cents.\n     * This value is compounded with playbackRate to determine the speed at which the sound is played.\n     * Its default value is 0 (meaning no detuning), and its nominal range is -\u221E to \u221E.\n     **/\n  pitch: PitchType = 0\n\n  /**\n     * Panning with a range of -1 to 1.\n     * The pan property of the StereoPannerNode interface is an a-rate AudioParam representing the amount of panning to apply.\n     * The value can range between -1 (full left pan) and 1 (full right pan).\n     **/\n  pan: PanType = 0\n\n  /**\n     * Sound Playback Volume from 0 to 1. Todo: make it possible to set in dBFS.\n     **/\n  volume: VolumeType = 1\n\n  /**\n     * Sound Specific Encoding settings.\n     * Probably mostly usefull if you want to automatically speed sound in encoding.\n     **/\n  encoding: SoundEncoding = new SoundEncoding()\n\n  constructor (props: DeepPartialProperties<Sound> = {}) {\n    Object.assign(this, props)\n    if (props.encoding != null) {\n      this.encoding = new SoundEncoding(props.encoding)\n    }\n  }\n}\n\nexport default Sound\n", "import { type DeepPartialProperties } from '@netent-tech/ecas-utils'\nimport BusConfig from './BusConfig'\nimport Group from './Group'\nimport PatternWrapper from './Patterns'\nimport Pool from './Pool'\nimport Settings from './Settings'\nimport Sound from './Sound'\n\nexport class SoundConfig {\n  /** Global Settings */\n  settings: Settings = new Settings()\n  buses: BusConfig[] = []\n\n  /** List of configured groups. */\n  groups: Group[] = []\n  sounds: Sound[] = []\n  patterns: PatternWrapper[] = []\n\n  /**\n    * List of configured pools. A sound pool will play different sound on each trigger.\n    **/\n  pools: Pool[] = []\n\n  constructor (props: DeepPartialProperties<SoundConfig> = {}) {\n    this.settings = new Settings(props.settings)\n    this.buses = props.buses?.map((bus) => new BusConfig(bus)) ?? []\n    this.groups = props.groups?.map((group) => new Group(group)) ?? []\n    this.sounds = props.sounds?.map((sound) => new Sound(sound)) ?? []\n    this.patterns = props.patterns?.map((pattern) => new PatternWrapper(pattern)) ?? []\n    this.pools = props.pools?.map((pool) => new Pool(pool)) ?? []\n  }\n}\nexport default SoundConfig\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isNumeric } from '@netent-tech/ecas-utils'\n\nexport interface ITypeNamed<T extends string> {\n  typename: T\n}\n\nexport function getWetMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix >= 0.5) {\n    return 1\n  }\n  return 1 - ((0.5 - mix) * 2)\n}\n\nexport function getDryMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix <= 0.5) {\n    return 1\n  }\n  return 1 - ((mix - 0.5) * 2)\n}\n\nexport function lastElement<T> (arr: T[]): T | undefined {\n  return arr.at(-1)\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\n\nexport interface SoundHandler {\n  dispose: () => void\n  details: Map<string, any>\n  getSound: (id: string) => any\n  getDurationSeconds: (id: string) => number\n  getAudioBuffer: (id: string) => Promise<AudioBuffer>\n  getAudioBufferSync: (id: string) => AudioBuffer\n  getAudioBufferReversed: (id: string) => Promise<AudioBuffer>\n  // eslint-disable-next-line\n    load: (ids: string[]) => Promise<void[]>\n  loadAll: () => Promise<void>\n  getAllSoundIds: () => string[]\n  isLoaded: (id: string) => boolean\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable { // implements ConvolverNode {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'AlgorithmicReverbInsert' as const\n/**\n * AlgorithmicReverb class is responsible to generate reverb nodes based on configuration given\n */\nexport class AlgorithmicReverbInsert implements InsertApi<AlgorithmicReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): AlgorithmicReverbInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options for algorithmic reverb\n     */\n  private readonly options: Required<AlgorithmicReverbInsertOptions>\n  /**\n     * Input node for algorithmic reverb\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node for algorithmic reverb\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node for algorithmic reverb\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node for algorithmic reverb\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Convolver node for algorithmic reverb\n     */\n  private reverbNode: ConvolverNode\n  /**\n     * Audio context for algorithmic reverb\n     */\n  private readonly audioContext: AudioContext\n\n  /**\n   * Creates an instance of algorithmic reverb.\n   * @param audioContext\n   * @param options\n   */\n  constructor (audioContext: AudioContext, options: AlgorithmicReverbInsertOptions = { id: TYPENAME }) {\n    this.options = {\n      id: options.id,\n      mix: 1,\n      time: 0.2,\n      decay: 0.2,\n      reverse: false\n    }\n\n    this.audioContext = audioContext\n\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.reverbNode = audioContext.createConvolver()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.dryGainNode)\n    this.dryGainNode.connect(this.outputGainNode)\n    this.inputGainNode.connect(this.reverbNode)\n    this.reverbNode.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.modify({ ...this.options, ...options }).catch(logger().error)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain, options.mix)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  async modify (options: PartialProperties<AlgorithmicReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let smoothingTimeSeconds = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      smoothingTimeSeconds = true\n    }\n\n    if (options.time !== undefined && this.options.time !== options.time) {\n      const MAX_TIME = 10 as const\n      // large impulses are costly\n      this.options.time = clamp(options.time, MIN, MAX_TIME)\n      smoothingTimeSeconds = true\n    }\n    // no need to rebuild if no change since previous update\n    if (options.decay !== undefined && this.options.decay !== options.decay) {\n      smoothingTimeSeconds = true\n      this.options.decay = Math.min(\n        Math.max(options.decay, MIN),\n        this.options.time\n      )\n    }\n\n    if (smoothingTimeSeconds) {\n      this.buildImpulse()\n    }\n  }\n\n  buildImpulse (): void {\n    const length = this.audioContext.sampleRate * this.options.time\n    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate)\n    const impulseL = impulse.getChannelData(0)\n    const impulseR = impulse.getChannelData(1)\n\n    let n: number\n    let i: number\n\n    for (i = 0; i < length; i++) {\n      n = this.options.reverse ? length - i : i\n      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n    }\n\n    if (this.reverbNode.buffer != null) {\n      this.inputGainNode.disconnect(this.reverbNode)\n      this.reverbNode.disconnect(this.wetGainNode)\n\n      this.reverbNode = this.audioContext.createConvolver()\n      this.inputGainNode.connect(this.reverbNode)\n      this.reverbNode.connect(this.wetGainNode)\n    }\n\n    this.reverbNode.buffer = impulse\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { FILTER_TYPES } from '../utils'\nimport { type InsertApi } from './types'\n\n/**\n * Uses BiquadFilterNode\n * see https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n **/\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport default BiquadFilterInsertOptions\n\n/** Converted to not extend BiquadFilterNode cause doesn't work on old browsers */\nconst TYPENAME = 'BiquadFilterInsert' as const\nexport class BiquadFilterInsert implements InsertApi<BiquadFilterInsert> {\n  static typename = TYPENAME\n  typename = BiquadFilterInsert.typename\n  id: string = TYPENAME\n  automator = new Automator(['frequency', 'detune', 'Q', 'gain'] as const)\n\n  private readonly options: BiquadFilterInsertOptions\n\n  node: BiquadFilterNode\n\n  constructor (context: BaseAudioContext, options: BiquadFilterInsertOptions) {\n    // will set the parameters to any options provided so no need to run modify in constructor\n    this.node = context.createBiquadFilter()\n    this.id = options.id\n    // any options provided overrides default\n    this.options = Object.assign({\n      id: options.id,\n      detune: 0,\n      frequency: context.sampleRate / 2,\n      gain: 0,\n      Q: 1,\n      type: 'lowpass'\n    }, options)\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.Q.value = this.options.Q!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.detune.value = this.options.detune!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.frequency.value = this.options.frequency!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.gain.value = this.options.gain!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.type = this.options.type!\n\n    this.automator.add('Q', this.node.Q)\n    this.automator.add('detune', this.node.detune)\n    this.automator.add('frequency', this.node.frequency)\n    this.automator.add('gain', this.node.gain)\n  }\n\n  get input (): BiquadFilterNode {\n    return this.node\n  }\n\n  get output (): BiquadFilterNode {\n    return this.node\n  }\n\n  get getOptions (): BiquadFilterInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the filter options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     */\n  async modify (\n    options: BiquadFilterInsertOptions,\n    endTimeSeconds: number,\n    sampleRate: number\n  ): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/Q\n         *\n         * The Q property of the BiquadFilterNode interface is an a-rate AudioParam, a double representing a Q factor, or quality factor.\n         * It is a dimensionless value with a default value of 1 and a nominal range of 0.0001 to 1000.\n         */\n    if (typeof options.Q === 'number') {\n      const MIN_Q = 0.0001 as const\n      const MAX_Q = 1000 as const\n      this.options.Q = clamp(options.Q, MIN_Q, MAX_Q)\n      this.node.Q.cancelScheduledValues(0)\n      this.node.Q.linearRampToValueAtTime(this.options.Q, endTimeSeconds)\n    }\n\n    /**\n         * Detune is basically the same as using frequency\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/detune\n         * https://webaudio.github.io/web-audio-api/dom-audiobuffersourcenode-detune\n         *\n         * The detune property of the BiquadFilterNode interface is an a-rate AudioParam representing detuning of the frequency in cents.\n         * For many AudioParams the minValue and maxValue is intended to be set to the maximum possible range.\n         * In this case, maxValue should be set to the most-positive-single-float value, which is 3.4028235e38.\n         * (However, in JavaScript which only supports IEEE-754 double precision float values,\n         * this must be written as 3.4028234663852886e38.)\n         * Similarly, minValue should be set to the most-negative-single-float value,\n         * which is the negative of the most-positive-single-float: -3.4028235e38.\n         * (Similarly, this must be written in JavaScript as -3.4028234663852886e38.)\n         */\n    if (typeof options.detune === 'number') {\n      const MOST_POSITIVE_SINGLE_FLOAT_VALUE = 3.4028234663852886e38 as const\n      const MOST_NEGATIVE_SINGLE_FLOAT_VALUE = -3.4028234663852886e38 as const\n      this.options.detune = clamp(\n        options.detune,\n        MOST_NEGATIVE_SINGLE_FLOAT_VALUE,\n        MOST_POSITIVE_SINGLE_FLOAT_VALUE\n      )\n      this.node.detune.cancelScheduledValues(0)\n      this.node.detune.linearRampToValueAtTime(\n        this.options.detune,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The frequency property of the BiquadFilterNode interface is an a-rate AudioParam\n         *  \u2014 a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n         * Its default value is 350, with a nominal range of 10 to the Nyquist frequency \u2014 that is, half of the sample rate.\n         */\n    if (typeof options.frequency === 'number') {\n      const minFrequency = 10 as const\n      const maxFrequency = sampleRate / 2\n      this.options.frequency = clamp(options.frequency, minFrequency, maxFrequency)\n      this.node.frequency.cancelScheduledValues(0)\n      this.node.frequency.exponentialRampToValueAtTime(\n        this.options.frequency,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The gain property of the BiquadFilterNode interface is an a-rate AudioParam\n         *    \u2014 a double representing the gain used in the current filtering algorithm.\n         * When its value is positive, it represents a real gain; when negative, it represents an attenuation.\n         *  It is expressed in dB, has a default value of 0, and can take a value in a nominal range of -40 to 40.\n         */\n    if (typeof options.gain === 'number') {\n      const maxGainDecibel = 40 as const\n      const minGainDecibel = -40 as const\n      this.options.gain = clamp(\n        options.gain,\n        minGainDecibel,\n        maxGainDecibel\n      )\n      this.node.gain.cancelScheduledValues(0)\n      this.node.gain.linearRampToValueAtTime(\n        this.options.gain,\n        endTimeSeconds\n      )\n    }\n\n    if (options.type !== undefined && options.type !== null && FILTER_TYPES.includes(options.type)) {\n      this.node.type = this.options.type = options.type\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.node.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, Exists, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type SoundHandler } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface ConvolverReverbInsertOptions extends Identifiable { //, Omit<ConvolverOptions, keyof AudioNode> {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: string\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'ReverbConvolverInsert' as const\n/**\n * ReverbConvolver class is responsible to generate a reverb node based on configuration given\n */\nexport class ConvolverReverbInsert implements InsertApi<ConvolverReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): ConvolverReverbInsertOptions {\n    return this.options\n  }\n\n  get audioParams (): { dryGain: AudioParam, wetGain: AudioParam } {\n    return { dryGain: this.dryGainNode.gain, wetGain: this.wetGainNode.gain }\n  }\n\n  private readonly soundHandler: SoundHandler // to fetch buffers for the impulses\n\n  /**\n     * Options of ConvolverNode\n     */\n  private readonly options: Required<ConvolverReverbInsertOptions> = {\n    id: TYPENAME,\n    normalize: false,\n    reverse: false,\n    impulseResponse: 'none', // updated in .modify\n    mix: 1\n  } as const\n\n  /**\n     * Input node of ConvolverNode\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ConvolverNode\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ConvolverNode\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ConvolverNode\n     */\n  private readonly wetGainNode: GainNode\n\n  /**\n     * convolver node of ConvolverNode\n     */\n  private readonly convolverNode: ConvolverNode\n\n  /**\n     * Creates an instance of Reverb Convolver node.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: ConvolverReverbInsertOptions, soundHandler: SoundHandler) {\n    this.soundHandler = soundHandler\n    this.inputGainNode = audioContext.createGain()\n    this.convolverNode = audioContext.createConvolver()\n    this.outputGainNode = audioContext.createGain()\n\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.convolverNode)\n\n    this.convolverNode.connect(this.wetGainNode)\n    this.inputGainNode.connect(this.dryGainNode)\n\n    this.dryGainNode.connect(this.outputGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n\n    this.id = options.id\n    if (options.impulseResponse === undefined) {\n      logger().warn('[ecas] convolver reverb impulse file should be specified.')\n      return\n    }\n    this.modify(options).catch(logger().error)\n  }\n\n  async modify (options: PartialProperties<ConvolverReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let shouldUpdateBuffer = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n\n    if (options.normalize !== undefined && this.options.normalize !== options.normalize) {\n      this.options.normalize = options.normalize\n      this.convolverNode.normalize = this.options.normalize\n      shouldUpdateBuffer = true\n    }\n\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      shouldUpdateBuffer = true\n    }\n\n    // no need to rebuild if no change since previous update\n    if (options.impulseResponse !== undefined && this.options.impulseResponse !== options.impulseResponse) {\n      shouldUpdateBuffer = true\n      this.options.impulseResponse = options.impulseResponse\n    }\n\n    if (shouldUpdateBuffer) {\n      await this.updateBuffer()\n    }\n  }\n\n  async updateBuffer (): Promise<void> {\n    const bufferPromise = this.options.reverse\n      ? this.soundHandler.getAudioBufferReversed(this.options.impulseResponse)\n      : this.soundHandler.getAudioBuffer(this.options.impulseResponse)\n\n    this.convolverNode.buffer = Exists(await bufferPromise)\n  }\n}\n", "\nimport { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, max, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nconst TYPENAME = 'DelayInsert' as const\n/**\n * Delay class is responsible to generate a delay node based on configuration given\n */\nexport class DelayInsert implements InsertApi<DelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  automator = new Automator(['delayTime', 'feedback', 'dry-gain', 'wet-gain', 'cutoff'] as const)\n\n  get id (): string {\n    return this.options.id\n  }\n\n  set id (newId: string) {\n    this.options.id = newId\n  }\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): DelayInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of delay\n     */\n  private readonly options: Required<DelayInsertOptions>\n  /**\n     * Input node of delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of delay\n     */\n  private readonly delayNode: DelayNode\n\n  private readonly filterNode: BiquadFilterNode\n\n  /**\n     * Creates an instance of delay.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: DelayInsertOptions = { id: 'delay' }) {\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n    this.feedbackGainNode = audioContext.createGain()\n    this.filterNode = audioContext.createBiquadFilter()\n    this.filterNode.type = 'lowpass'\n    this.delayNode = audioContext.createDelay(options.maxDelayTime !== undefined ? options.maxDelayTime : 1)\n\n    // final graph\n    // input->dry->output\n    // input->delay->feedback\n    //        feedback->delay\n    //        delay->wet->output\n    this.inputGainNode\n      .connect(this.dryGainNode)\n      .connect(this.outputGainNode)\n\n    this.inputGainNode\n      .connect(this.delayNode)\n      .connect(this.wetGainNode)\n      .connect(this.outputGainNode)\n\n    this.delayNode\n      .connect(this.feedbackGainNode)\n      .connect(this.filterNode)\n      .connect(this.delayNode)\n\n    this.options = {\n      id: options.id,\n      feedback: 0.1,\n      mix: 1,\n      delayTime: 0.3,\n      maxDelayTime: 1,\n      cutoff: 20000\n    }\n\n    this.modify(Object.assign(this.options, options)).catch(logger().error)\n\n    this.automator.add('cutoff', this.filterNode.frequency)\n    this.automator.add('delayTime', this.delayNode.delayTime)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  public async modify (options: PartialProperties<DelayInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const GAIN_MIN = 0.0001 as const\n\n    if (options.delayTime !== undefined) {\n      this.options.delayTime = clamp(options.delayTime, 0, this.options.maxDelayTime)\n\n      this.delayNode.delayTime.cancelScheduledValues(0)\n      this.delayNode.delayTime.linearRampToValueAtTime(this.options.delayTime, endTimeSeconds)\n    }\n    if (options.feedback !== undefined) {\n      this.options.feedback = clamp(options.feedback, GAIN_MIN, 1)\n\n      this.feedbackGainNode.gain.cancelScheduledValues(0)\n      this.feedbackGainNode.gain.exponentialRampToValueAtTime(this.options.feedback, endTimeSeconds)\n    }\n    if ((options.maxDelayTime !== undefined)) {\n      this.options.maxDelayTime = clamp(options.maxDelayTime, 0, 10)\n    }\n    if ((options.mix !== undefined)) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, GAIN_MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(clamp(1 - this.options.mix, GAIN_MIN, MIX_MAX), endTimeSeconds)\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(this.options.mix, endTimeSeconds)\n    }\n    if ((options.id !== undefined)) {\n      this.options.id = options.id\n    }\n\n    if ((options.cutoff !== undefined)) {\n      this.options.cutoff = clamp(options.cutoff, 10, 20000)\n      this.filterNode.frequency.exponentialRampToValueAtTime(this.options.cutoff, endTimeSeconds)\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.outputGainNode.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nconst TYPENAME = 'DynamicsCompressorInsert' as const\nexport class DynamicsCompressorInsert implements InsertApi<DynamicsCompressorInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  private readonly options: DynamicsCompressorInsertOptions\n  automator = new Automator(['threshold', 'ratio', 'attack', 'release', 'knee'] as const)\n  node: DynamicsCompressorNode\n  context: BaseAudioContext\n\n  constructor (context: BaseAudioContext, options: DynamicsCompressorInsertOptions) {\n    this.context = context\n    this.id = options.id\n    this.options = { ...options }\n    this.node = context.createDynamicsCompressor()\n    this.automator.add('threshold', this.threshold)\n    this.automator.add('ratio', this.ratio)\n    this.automator.add('attack', this.attack)\n    this.automator.add('release', this.release)\n    this.automator.add('knee', this.knee)\n    void this.modify(options, 0)\n  }\n\n  get attack (): AudioParam {\n    return this.node.attack\n  }\n\n  get knee (): AudioParam {\n    return this.node.knee\n  }\n\n  get ratio (): AudioParam {\n    return this.node.ratio\n  }\n\n  get release (): AudioParam {\n    return this.node.release\n  }\n\n  get threshold (): AudioParam {\n    return this.node.threshold\n  }\n\n  get input (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get output (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get getOptions (): DynamicsCompressorInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the compressor options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     * @param node\n     * @param options -\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * @param endTime\n     * @param sampleRate\n     */\n  async modify (options: DynamicsCompressorInsertOptions, endTime: number): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode/attack\n         * The attack property's default value is 0.003 and it can be set between 0 and 1\n         */\n    if (typeof options.attack === 'number') {\n      const MIN_ATTACK = 0 as const\n      const MAX_ATTACK = 1 as const\n      this.attack.cancelScheduledValues(0)\n      this.attack.linearRampToValueAtTime(\n        clamp(\n          options.attack,\n          MIN_ATTACK,\n          MAX_ATTACK\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The knee property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam containing a decibel value\n         * representing the range above the threshold where\n         * the curve smoothly transitions to the compressed portion\n         * The knee property's default value is 30 and it can be set between 0 and 40\n         */\n    if (typeof options.knee === 'number') {\n      const MIN_KNEE = 0 as const\n      const MAX_KNEE = 40 as const\n      this.knee.cancelScheduledValues(0)\n      this.knee.linearRampToValueAtTime(\n        clamp(\n          options.knee,\n          MIN_KNEE,\n          MAX_KNEE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The ratio property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n         * The ratio property's default value is 12 and it can be set between 1 and 20.\n         */\n    if (typeof options.ratio === 'number') {\n      const MIN_RATIO = 1 as const\n      const MAX_RATIO = 20 as const\n      this.ratio.cancelScheduledValues(0)\n      this.ratio.linearRampToValueAtTime(\n        clamp(\n          options.ratio,\n          MIN_RATIO,\n          MAX_RATIO\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The release property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of time, in seconds,\n         * required to increase the gain by 10 dB.\n         * It defines how quick the signal is adapted when its volume is reduced.\n         * The release property's default value is 0.25 and it can be set between 0 and 1.\n         */\n    if (typeof options.release === 'number') {\n      const MAX_RELEASE = 1 as const\n      const MIN_RELEASE = 0 as const\n      this.release.cancelScheduledValues(0)\n      this.release.exponentialRampToValueAtTime(\n        clamp(\n          options.release,\n          MIN_RELEASE,\n          MAX_RELEASE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The threshold property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n         * The threshold property's default value is -24 and it can be set between -100 and 0.\n         */\n    if (typeof options.threshold === 'number') {\n      const MIN_THRESHOLD = -100 as const\n      const MAX_THRESHOLD = 0 as const\n      this.threshold.cancelScheduledValues(0)\n      this.threshold.linearRampToValueAtTime(\n        clamp(\n          options.threshold,\n          MIN_THRESHOLD,\n          MAX_THRESHOLD\n        ),\n        endTime\n      )\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTime - this.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { type Identifiable } from '@netent-tech/ecas-utils'\nimport { getDryMixValue, getWetMixValue } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport default PingPongInsertOptions\n\nconst TYPENAME = 'PingPongDelayInsert' as const\n/**\n * PingPongDelay class is responsible to generate a ping pong delay nodes based on configuration given\n */\nexport class PingPongDelayInsert implements InsertApi<PingPongDelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain', 'delay-time-left', 'delay-time-right', 'feedback'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  /** Todo: implement */\n  async modify (): Promise<void> {\n    await Promise.resolve<undefined>(undefined)\n  }\n\n  get getOptions (): PingPongInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of ping pong delay\n     */\n  private readonly options: Required<PingPongInsertOptions>\n  /**\n     * Input node of ping pong  delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ping pong  delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ping pong delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ping pong delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of ping pong delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of ping pong delay\n     */\n  private readonly delayNodeLeft: DelayNode\n  /**\n     * Delay node right of ping pong delay\n     */\n  private readonly delayNodeRight: DelayNode\n  /**\n     * Channel merger of ping pong delay\n     */\n  private readonly channelMerger: ChannelMergerNode\n\n  /**\n     * Creates an instance of ping pong delay.\n     * @param ecasContext\n     * @param options\n     */\n  constructor (ecasContext: AudioContext, options: PingPongInsertOptions = { id: TYPENAME }) {\n    this.options = Object.assign({\n      feedback: 0.5,\n      mix: 0.5,\n      delayTime: 0.3,\n      maxDelayTime: 1\n    }, options)\n\n    this.maxDelayTime = options.maxDelayTime !== undefined ? options.maxDelayTime : 1\n\n    this.inputGainNode = ecasContext.createGain()\n    this.outputGainNode = ecasContext.createGain()\n    this.dryGainNode = ecasContext.createGain()\n    this.wetGainNode = ecasContext.createGain()\n    this.feedbackGainNode = ecasContext.createGain()\n    this.delayNodeLeft = ecasContext.createDelay(this.maxDelayTime)\n    this.delayNodeRight = ecasContext.createDelay(this.maxDelayTime)\n    this.channelMerger = ecasContext.createChannelMerger(2)\n\n    // dry mix\n    this.inputGainNode.connect(this.dryGainNode)\n    // dry out\n    this.dryGainNode.connect(this.outputGainNode)\n\n    // feedback loop\n    this.delayNodeLeft.connect(this.channelMerger, 0, 0)\n    this.delayNodeRight.connect(this.channelMerger, 0, 1)\n    this.delayNodeLeft.connect(this.delayNodeRight)\n    this.feedbackGainNode.connect(this.delayNodeLeft)\n    this.delayNodeRight.connect(this.feedbackGainNode)\n\n    // wet mix\n    this.inputGainNode.connect(this.feedbackGainNode)\n    // wet out\n    this.channelMerger.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.id = options.id\n\n    this.automator.add('delay-time-left', this.delayNodeLeft.delayTime)\n    this.automator.add('delay-time-right', this.delayNodeRight.delayTime)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n  }\n\n  public get mix (): number {\n    return this.options.mix\n  }\n\n  public set mix (mix: number) {\n    this.options.mix = mix\n    this.dryGainNode.gain.value = getDryMixValue(this.mix)\n    this.wetGainNode.gain.value = getWetMixValue(this.mix)\n  }\n\n  public get feedback (): number {\n    return this.options.feedback\n  }\n\n  public set feedback (feedback: number) {\n    if (feedback < 0 || feedback > 1) {\n      return\n    }\n    this.options.feedback = feedback\n    this.feedbackGainNode.gain.value = this.feedback\n  }\n\n  public get delayTime (): number {\n    return this.options.delayTime\n  }\n\n  public set delayTime (time: number) {\n    if (time < 0 || time > this.maxDelayTime) {\n      return\n    }\n    this.options.delayTime = time\n    this.delayNodeLeft.delayTime.value = this.delayTime\n    this.delayNodeRight.delayTime.value = this.delayTime\n  }\n\n  public get maxDelayTime (): number {\n    return this.options.maxDelayTime\n  }\n\n  public set maxDelayTime (maxDelay) {\n    this.options.maxDelayTime = maxDelay\n  }\n\n  public getPingPongDelayNodes (param: string): GainNode | DelayNode[] {\n    if (param === 'feedback') {\n      return this.feedbackGainNode\n    }\n    return [\n      this.delayNodeLeft,\n      this.delayNodeRight\n    ]\n  }\n\n  public getGeneratedGraph (): { leftNode: GainNode, rightNode: GainNode } {\n    return {\n      leftNode: this.inputGainNode,\n      rightNode: this.outputGainNode\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { InsertHandlerError, type SoundHandler } from '../utils'\nimport { AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { BiquadFilterInsert } from './BiquadFilterInsert'\nimport { ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { DelayInsert } from './DelayInsert'\nimport { DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { PingPongDelayInsert } from './PingPongDelayInsert'\nimport { type InsertClass, type InsertOptions, type InsertTypenames } from './types'\n\nexport function createInsert<T extends InsertTypenames> (\n  audioContext: AudioContext,\n  soundHandler: SoundHandler,\n  typename: T,\n  options: InsertOptions<T>\n): InsertClass<T> {\n  logger().debug('createInsert;', typename)\n  switch (typename) {\n    case BiquadFilterInsert.typename: {\n      return new BiquadFilterInsert(audioContext, options as BiquadFilterInsert['options']) as InsertClass<T>\n    }\n    case DynamicsCompressorInsert.typename: {\n      return new DynamicsCompressorInsert(audioContext, options as DynamicsCompressorInsert['options']) as InsertClass<T>\n    }\n    case DelayInsert.typename: {\n      return new DelayInsert(audioContext, options as DelayInsert['options']) as InsertClass<T>\n    }\n    case AlgorithmicReverbInsert.typename: {\n      return new AlgorithmicReverbInsert(audioContext, options as AlgorithmicReverbInsert['options']) as InsertClass<T>\n    }\n    case ConvolverReverbInsert.typename: {\n      return new ConvolverReverbInsert(audioContext, options as ConvolverReverbInsert['options'], soundHandler) as InsertClass<T>\n    }\n    case PingPongDelayInsert.typename: {\n      return new PingPongDelayInsert(audioContext, options as PingPongDelayInsert['options']) as InsertClass<T>\n    }\n    default: {\n      throw new InsertHandlerError(`create insert failed to create any insert for, ${typename as string}`)\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { createInsert, type InsertAny, type InsertClass, type InsertOptions, type InsertTypenames } from '.'\nimport { InsertHandlerError, lastElement, type SoundHandler } from '../utils'\n\nexport class InsertHandler implements Disposable {\n  private readonly insertMap = new Map<InsertAny['id'], Readonly<InsertAny>>()\n  private inserts: Array<Readonly<InsertAny>>\n  private readonly audioContext: AudioContext\n  private readonly soundHandler: SoundHandler\n  private readonly source: AudioNode\n  private readonly destination: AudioNode\n\n  constructor (audioContext: AudioContext, soundHandler: SoundHandler, source: AudioNode, destination: AudioNode) {\n    this.audioContext = audioContext\n    this.soundHandler = soundHandler\n    this.source = source\n    this.destination = destination\n    this.inserts = []\n  }\n\n  create<T extends InsertTypenames>(typename: T, options: InsertOptions<T>): void {\n    logger().debug('[ecas] insert.create', typename)\n    const insert = createInsert(\n      this.audioContext,\n      this.soundHandler,\n      typename,\n      options\n    )\n    this.add(insert)\n  }\n\n  add<T extends InsertTypenames>(insert: Readonly<InsertClass<T>>): void {\n    logger().debug('[ecas] insert.add')\n    const last = lastElement(this.inserts)\n\n    if (last != null) {\n      last.output.disconnect(this.destination)\n      last.output.connect(insert.input)\n    } else {\n      this.source.disconnect(this.destination)\n      this.source.connect(insert.input)\n    }\n\n    insert.output.connect(this.destination)\n\n    this.inserts.push(insert)\n    this.insertMap.set(insert.id, insert)\n  }\n\n  remove (id: string): void {\n    logger().debug('[ecas] insert.remove', id)\n    const newInserts: Array<Readonly<InsertAny>> = []\n    for (const [index, insert] of this.inserts.entries()) {\n      if (insert.id === id) {\n        const next = this.inserts[index + 1]?.input ?? this.destination\n        const prev = this.inserts[index - 1]?.output ?? this.source\n        prev.disconnect()\n        insert.output.disconnect()\n        prev.connect(next)\n      } else {\n        newInserts.push(insert)\n      }\n    }\n    this.inserts = newInserts\n    this.insertMap.delete(id)\n  }\n\n  get<T extends InsertTypenames>(id: string): InsertClass<T> {\n    if (!this.insertMap.has(id)) {\n      throw new InsertHandlerError(`[ecas] cannot get insert: ${id} since it does not exist`)\n    }\n    return this.insertMap.get(id) as InsertClass<T>\n  }\n\n  logInserts (): void {\n    logger().log(this.inserts)\n  }\n\n  has (id?: string): boolean {\n    return typeof id === 'string'\n      ? this.insertMap.has(id)\n      : isArrayEmpty(this.inserts)\n  }\n\n  dispose (): void {\n    for (const id of this.insertMap.keys()) {\n      this.insertMap.delete(id)\n    }\n\n    while (this.inserts.length > 0) {\n      const insert = this.inserts.pop()\n      insert?.input.disconnect()\n      insert?.output.disconnect()\n    }\n  }\n}\n", "import { type AutomatableParameters, type Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type ITypeNamed } from '../utils'\nimport { type AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { type BiquadFilterInsert } from './BiquadFilterInsert'\nimport { type ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { type DelayInsert } from './DelayInsert'\nimport { type DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { type PingPongDelayInsert } from './PingPongDelayInsert'\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { BiquadFilterInsert, DynamicsCompressorInsert, AlgorithmicReverbInsert, DelayInsert, PingPongDelayInsert, ConvolverReverbInsert } from '@netent-tech/ecas-inserts'\nimport { type Values } from '@netent-tech/ecas-utils'\n\n/** What codecs to choose when setting file extension. */\nexport const codecs = {\n  wav: 'pcm_s16le', /** 16 bit litle endian */\n  mp3: 'libmp3lame',\n  mp4: 'aac',\n  ogg: 'libopus', /** Changed from libvorbis october 2021. */\n  webm: 'libopus', /** Changed from libvorbis october 2021. Ffmpeg default audio encoder for WebM is libopus */\n  opus: 'libopus',\n  caf: 'libopus' /** Opus for safari, for some files this doesn't work unfortunately dont know why yet  */\n} as const\n\nexport const CHANNELS = [1, 2] as const\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\nexport const POOL_ITEM_TYPES = ['sound', 'pattern', 'pool'] as const\nexport const POOL_TYPES = ['random', 'sequential'] as const\nexport const ENVELOPE_PRESET_PARAM = ['volume', 'pan', 'pitch'] as const\nexport const BUFFER_ELEMENT_SYNTHESIZED = ['buffer', 'element', 'synthesized'] as const\nexport const TARGET_SAMPLE_RATE = 48000 as const\n\nexport const EFFECT_TYPES: ReadonlyArray<Values<typeof EffectTypes>> = ['reverbAlgorithmic', 'reverbConvolver', 'compressor', 'delay', 'pingPongDelay', 'filter'] as const\nexport const BUSS_SOUND = ['bus', 'sound'] as const\nexport const TARGET_TYPES = ['sound', 'bus'] as const\nexport const ENVELOPE_CURVES = ['linear', 'exponential', 'logarithmic', 's-curve'] as const\nexport const ENVELOPE_PARAMETER_TYPES = ['volume', 'pan', 'pitch', 'gain'] as const\n\nexport const EffectTypes = {\n  [AlgorithmicReverbInsert.typename]: 'reverbAlgorithmic',\n  [ConvolverReverbInsert.typename]: 'reverbConvolver',\n  [DynamicsCompressorInsert.typename]: 'compressor',\n  [DelayInsert.typename]: 'delay',\n  [PingPongDelayInsert.typename]: 'pingPongDelay',\n  [BiquadFilterInsert.typename]: 'filter'\n} as const\n\nexport type EffectIdentifiers = typeof EFFECT_TYPES[number]\nexport type EffectIdentifier<T extends EffectIdentifiers> = T // Omit<string, T>\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\n\nexport class PingPongDelayConfig {\n  /** The maximum amount of time, in seconds, that the audio signal can be delayed by. Must be less than 180 seconds, and defaults to 1 second if not specified. */\n  maxDelayTime = 1\n\n  /** Is an a-rate AudioParam representing the amount of delay to apply. The default delayTime is 0 seconds. */\n  delayTime = 0\n\n  /** The intensity with which the input will echo back. A larger value will result in more echo repetitions. (min: 0, max: 1, defaults to 0.5) */\n  feedback = 0.5\n\n  /** Volume balance between the original audio and the effected output (the delayed sound). (min: 0, max: 1, defaults to 0.5) */\n  mix = 0.5\n\n  constructor (props: PartialProperties<PingPongDelayConfig> = {}) {\n    Object.assign(this, props)\n  }\n}\n\nexport default PingPongDelayConfig\n", "import { type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type ZeroToOneNumber } from './ZeroToOne'\n\nexport class ConvolverReverbConfig {\n  /** Impulse sound id to generate reverb effect */\n  impulseResponse = 'default'\n\n  /** Volume balance between the original audio and the effected output. (min: 0, max: 1, defaults to 0.5) */\n  mix: ZeroToOneNumber = 0.5\n\n  /**\n     * ConvolverNode interface is a boolean that controls whether the impulse response from the buffer will be scaled\n     * by an equal-power normalization when the buffer attribute is set, or not. Default is true\n     **/\n  normalize = true\n\n  constructor (props: PartialProperties<ConvolverReverbConfig> = {}) {\n    Object.assign(this, props)\n  }\n}\n", "export function strarr (arr: unknown[], sep = ', '): string {\n  const str = arr.map(item => String(item)).join(sep)\n  return `[ ${str} ]`\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isString } from '@netent-tech/ecas-utils'\nimport { type MusicalPosition, type TimeSignature } from '../ecas-config/sound-config'\n/**\n * Check if a value is valid bar.beat.tick syntax.\n *\n * @param {ValueOrRandomOrBarBeatTick} thing Value to check.\n * @return {boolean} If value conforms to bar.beat.tick true and val is a string, else false.\n */\nexport function isMusicalPosition (thing: unknown): thing is MusicalPosition {\n  if (!isString(thing)) {\n    return false\n  }\n  const regExp = /^\\d{1,2}\\.\\d{1,2}\\.\\d{1,3}$/\n  const match = isString(thing) ? thing.match(regExp) : null\n  return match !== null\n}\n\nexport function isTimeSignature (thing: string): thing is TimeSignature {\n  const timeSignatureRegex = /\\d\\/\\d/\n  return timeSignatureRegex.test(thing)\n}\n", "\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\nexport class BusHandlerError extends Error {\n  override name = 'BusHandlerError'\n}\n\nexport class EnvelopeHandlerError extends Error {\n  override name = 'EnvelopeHandlerError'\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n", "export * from './ecas-engine-api'\nexport * from './EcasOptions'\nexport * from './ecas-config'\nexport * from './utils'\n\nexport const MASTER_BUS_ID = 'master' as const\nexport const OUTPUT_BUS_ID = 'OUTPUT' as const\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isTimeSignature, ITempoConfig, ITimeSignature, MusicalPosition, TimeSignature } from \"@netent-tech/ecas-common\"\nconst TICKS_PER_BEAT = 32 as const\n\n/**\n * Convert bar.beat.tick notation to seconds.\n *\n * @param {MusicalPosition} val Position in bar.beat.tick format to convert.\n * @param {ITempoConfig} tempoConfig Tempo settings to use in conversion.\n * @param {number} now Current time in seconds to use in conversion.\n * @private\n */\nexport function barBeatTickToSeconds(val: MusicalPosition, tempoConfig: ITempoConfig, now: number): number {\n    if (!tempoConfig || !tempoConfig.tempo) {\n        logger().warn(\"[ecas] unable to convert bar.beat.tick to time, since no tempo is configured.\")\n        return 0\n    }\n    tempoConfig.timeSignature = tempoConfig.timeSignature || {meter: 4, unit: 4}\n    tempoConfig.triggerQuantize = tempoConfig.triggerQuantize || 1\n    const parts = val.split(\".\")\n    const bars = parseInt(parts[0], 10)\n    const beats = parseInt(parts[1], 10)\n    const ticks = parseInt(parts[2], 10)\n    const signatureDenom = (1 / tempoConfig.timeSignature.unit) * 4\n    let secPerUnit\n    const secPerBeat = 60 / (tempoConfig.tempo / signatureDenom)\n    const secPerBar = secPerBeat * tempoConfig.timeSignature.meter\n    const secPerTick = secPerBeat / TICKS_PER_BEAT\n    if (tempoConfig.triggerQuantize >= 1) {\n        secPerUnit = secPerBeat * (tempoConfig.timeSignature.meter * tempoConfig.triggerQuantize)\n    }\n    else {\n        const secPerWhole = secPerBeat / (1 / tempoConfig.timeSignature.unit)\n        secPerUnit = secPerWhole * tempoConfig.triggerQuantize\n    }\n    const remainUntilQuantize = secPerUnit - ((now % secPerUnit) || secPerUnit)\n    const barsTotalSeconds = bars * secPerBar\n    const beatsTotalSeconds = beats * secPerBeat\n    const ticksTotalSeconds = ticks * secPerTick\n    return barsTotalSeconds + beatsTotalSeconds + ticksTotalSeconds + remainUntilQuantize\n}\n\n\n/**\n * Converts a string to time signature object.\n * @param {string} str Time signature expressed as a string. E.g. \\\"4/4\\\".\n * @return {ITimeSignature} Object with meter and unit properties.\n */\nexport function createTimeSignatureFromString(str: TimeSignature = \"4/4\"): ITimeSignature { //Maybe TimeSignature default should be blank?\n    if (!isTimeSignature(str)) {\n        throw new Error(`[ecas] createTimeSignatureFromString; Invalid time signature '${str}'. Please enter a string such as '4/4', '3/4' or '6/8'.`)\n    }\n    const parts = str.split(\"/\")\n    const meter = parseInt(parts[0], 10)\n    const unit = parseInt(parts[1], 10)\n    return {\n        meter,\n        unit\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { hasOwnProperty, isArray, isNumber, isNumeric, isString, isStringNumber } from \"@netent-tech/ecas-utils\"\nimport { isMusicalPosition, ITempoConfig, ValueOrRandom, ValueOrRandomOrBarBeatTick } from \"@netent-tech/ecas-common\"\nimport { barBeatTickToSeconds } from \"./beats\"\nexport class Utils {\n\n    /**\n     * Convert a pitch value in cents to playback rate\n     * @param {number} detuneInCents Pitch value in cents. Valid values between -4800 and 4800.\n     * @returns {number} Playback rate clamped between 0.0625 (1/16) and 16\n     */\n    static pitchToPlaybackRate(detuneInCents: number): number {\n        const min = -4800\n        const max = 4800\n        if (detuneInCents < min || detuneInCents > max) {\n            logger().info(`[ecas] pitch outside allowed range (${min} to ${max}), was: ${detuneInCents}, clamping.`)\n            detuneInCents = Math.min(max, Math.max(min, detuneInCents))\n        }\n        return Math.pow(2, detuneInCents / 1200)\n    }\n\n    /**\n     * Converts a string fraction to a number. For example '1/4' to 0.25\n     * @param {string} val Fraction expressed as a string.\n     * @return {number} Fraction as number.\n     */\n    static stringFractionToNumber(val: string | number): number {\n        if (isNumeric(val) || !val) {\n            return this.defaultNumber(val, 0)\n        }\n        if (isString(val)) {\n            const parts = val.split(\"/\").map((v) => parseInt(v, 10))\n            if (!parts || parts.length !== 2) {\n                throw new Error(\"[ecas] can only convert fraction in format 'n/n'. Got:\" + val)\n            }\n            return parts[0] / parts[1]\n        }\n        return 0\n    }\n\n    /**\n     * Checks if a value is numeric and if not returns default value. Also ensures\n     * it is returned as a proper number, and that bar.beat.tick notation or random values are converted.\n     *\n     * @param {ValueOrRandomOrBarBeatTick} val Suspected number, or random range array.\n     * @param {number} defaultValue Default value to use if not numeric.\n     * @param {ITempoConfig} tempoConfig Tempo information to use when converting bar.beat.tick notation.\n     * @param {number} now Current time of playback, used when converting bar.beat.tick notation.\n     * @returns {number} The checked and parsed number\n     */\n    static defaultNumber(val: ValueOrRandomOrBarBeatTick, defaultValue = 0, tempoConfig?: ITempoConfig, now = 0): number {\n        if (isNumber(val)) {\n            return val\n        }\n        if (isArray(val)) {\n            const newVal = this.randomizeValues(val)\n            if (typeof newVal === 'number') {\n                return newVal\n            }\n            logger().warn(`[ecas] provided value is an array: ${val}, but ECAS is unable to get a randomised value from it, returning ${defaultValue} instead.`)\n            return defaultValue\n        }\n        if (isMusicalPosition(val)) {\n            if (!tempoConfig) {\n                logger().warn(\"[ecas] you need to provide tempo information for conversion of bar.beat.tick notation to time.\")\n                return defaultValue\n            }\n            return barBeatTickToSeconds(val, tempoConfig, now)\n        }\n        if (isStringNumber(val)) {\n            return parseFloat(val.toString())\n        }\n        logger().log(\"[ecas] unable to set default number value, returning 0. val was:\", val)\n        return defaultValue\n    }\n\n    /**\n     * Checks if a value is undefined, null or empty string, and in that case sets it to a default value.\n     * @param {T} val any value\n     * @param {T} defaultValue default value to use if not numeric\n     * @returns {number} The checked and parsed number\n     */\n    static defaultValue<T>(val: T, defaultValue: T): T {\n        if (val === undefined || val === null || (isString(val) && val === \"\")) {\n            val = defaultValue\n        }\n        return val\n    }\n\n    /**\n     * Randomizing Value\n     * @param {RandomSet} values Passes as a range. example [[0.1, 0.3], 0.5, 0.5]\n     * would result in 66.6% chance of returning 0.5 and 33.3% chance of returning\n     * a value in between 0.1-0.3\n     * @returns {number} Random value if input was a random range, otherwise same as input\n     */\n    static randomizeValues(values: ValueOrRandom): number {\n        if (isNumber(values)) {\n            return values\n        }\n\n        let isValid = true\n        const rangeReg = /^-?\\d*\\.?\\d+,-?\\d*\\.?\\d+$/ // eslint-disable-line\n        const valueReg = /^-?\\d*\\.?\\d+$/\n        let randomVal\n        let filterArr\n\n        if (!isNumber(values) && Array.isArray(values)) {\n            if (values.length > 0) {\n                filterArr = (values as string[]).map((n) => {\n                    if (valueReg.test(n)) {\n                        return n\n                    }\n\n                    else if (isArray(n)) {\n                        return this._getRandomValue(parseFloat(n[0]), parseFloat(n[1]))\n                    }\n\n                    else if (rangeReg.test(n)) {\n                        const range = n.split(\",\")\n                        return this._getRandomValue(parseFloat(range[0]), parseFloat(range[1]))\n                    }\n\n                    else {\n                        isValid = false\n                        logger().warn(\"[ecas] invalid random value format: \" + values)\n                    }\n                    return null\n                })\n\n                if (isValid) {\n                    randomVal  = this.randomShuffle(filterArr)[0]\n                    return parseFloat(randomVal)\n                }\n            }\n            else {\n                logger().warn(\"[ecas] invalid random value: empty array\")\n            }\n        }\n        else {\n            randomVal = values\n            return randomVal\n        }\n        throw new Error(\"[ecas] randomize values should not reach this line\")\n    }\n\n    /**\n     * Shuffle the sequential array when pool type is random and ends the Q\n     * @param {T[]} array Array to shuffle\n     * @returns {T[]} Shuffled array\n     */\n    static randomShuffle<T>(array: T[]): T[] {\n        const arrayWithRandomNumbers: Array<[number, T]> = array.map((n: T) => [Math.random(), n])\n        arrayWithRandomNumbers.sort()\n        return arrayWithRandomNumbers.map((n) => n[1])\n    }\n\n    /**\n     * Sum two volume values and return a number.\n     * NOTE: When summing levels the actual operation used is multiplication.\n     * @param {ValueOrRandom} volumeA Volume value A\n     * @param {ValueOrRandom} volumeB Volume value B\n     * @returns {number} Sum of volume values\n     */\n    static sumVolume(volumeA: ValueOrRandom = 1, volumeB: ValueOrRandom = 1): number {\n        const a = this.defaultNumber(volumeA, 1)\n        const b = this.defaultNumber(volumeB, 1)\n        return a * b\n    }\n\n    /**\n     * Sum two pan values and return a number.\n     * Should mimic playing a sound with panning through a bus with panning in Web Audio API using StereoPannerNode.\n     * PanB acts as the bus, so for example if panA = 1 and panB = -1 the expected value is -1\n     *\n     * @param {ValueOrRandom} panA Pan value to use as source\n     * @param {ValueOrRandom} panB Pan value to use as bus\n     * @returns {number} Sum of pan values\n     */\n    static sumPan(panA: ValueOrRandom, panB: ValueOrRandom): number {\n        const a = Math.max(-1, Math.min(this.defaultNumber(panA), 1))\n        const b = Math.max(-1, Math.min(this.defaultNumber(panB), 1))\n        return b + ((1 - Math.abs(b)) * a)\n    }\n\n    /**\n     * Sum two pitch values and return a number.\n     * @param {ValueOrRandom} pitchA Pitch value A\n     * @param {ValueOrRandom} pitchB Pitch value B\n     * @returns {number} Sum of pitch values\n     */\n    static sumPitch(pitchA: ValueOrRandom, pitchB: ValueOrRandom): number {\n        const a = this.defaultNumber(pitchA)\n        const b = this.defaultNumber(pitchB)\n        return a + b\n    }\n\n    /**\n     * Sum two position values and return a number.\n     * @param {ValueOrRandom} posA Position value A\n     * @param {ValueOrRandom} posB Position value B\n     * @returns {number} Sum\n     */\n    static sumPos(posA: ValueOrRandom, posB: ValueOrRandom): number {\n        const a = this.defaultNumber(posA)\n        const b = this.defaultNumber(posB)\n        return a + b\n    }\n    /**\n     * Take and array with objects, and return an array where specified props are unique.\n     *\n     * @param array Array to filter.\n     * @param props Props to filter on.\n     * @return {Array} Array with only unique items.\n     */\n    static filterUnique<T>(array: T[], props: string[]): T[] | null {\n        if (array === null || array === undefined) {\n            return null\n        }\n        const unique: T[] = []\n        const matches: string[] = []\n        array.forEach((item) => {\n            let key = \"\"\n            props.forEach((prop) => {\n                if (hasOwnProperty(item, prop)) {\n                    key += item[prop]\n                }\n            })\n            if (matches.indexOf(key) === -1) {\n                unique.push(item)\n            }\n            matches.push(key)\n        })\n        return unique\n    }\n\n    static getWetMixValue(mix: number) {\n        if (!isNumeric(mix) || mix > 1 || mix < 0) {\n            return 0\n        }\n        if (mix >= 0.5) {\n            return 1\n        }\n        return 1 - ((0.5 - mix) * 2)\n    }\n\n    static getDryMixValue(mix: number) {\n        if (!isNumeric(mix) || mix > 1 || mix < 0) {\n            return 0\n        }\n        if (mix <= 0.5) {\n            return 1\n        }\n        return 1 - ((mix - 0.5) * 2)\n    }\n\n\n    /**\n     * Generate a unique identifier with or without a prefix.\n     *\n     * @param {string} prefix String to append before identifier. Automatically followed by underscore.\n     * @return {string} Universally unique identifier generated.\n     */\n    public static generateUniqueId(prefix?: string): string {\n        const time = new Date().getTime()\n        const uuidv4Format = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\"\n\n        const uniqueId = uuidv4Format.replace(\n            /[xy]/g,\n            (match) => {\n                /* tslint:disable:no-bitwise */\n                const randomDigit = time + (crypto.getRandomValues(new Uint32Array(1))[0] / 10)\n                const randomCharacter = (randomDigit + Math.random() * 16) % 16 | 0\n\n                return (match === \"x\" ? randomCharacter : (randomCharacter & 0x3 | 0x8)).toString(16)\n            }\n        )\n\n        if (prefix && prefix !== \"\" && typeof prefix === \"string\") {\n            return prefix + \"_\" + uniqueId\n        }\n        else {\n            return uniqueId\n        }\n    }\n\n    /**\n     * Get random value from two values\n     * @param {number} min lower limit\n     * @param {number} max upper limit\n     * @returns {number} random value from range\n     */\n    private static _getRandomValue(min: number, max: number) {\n        const rand = Math.random() * (max - min) + min\n        return rand.toFixed(3)\n    }\n}\n", "/**\n * Sort topologically.\n * Based on https://github.com/samuelneff/topsort/blob/master/lib/topsort.ts\n * Useful in ECAS to sort the bus graph.\n *\n * For example say you have a bus graph with \"bussA\" going into \"bussB\" going into \"master\".\n * When creating the busses, you need to have the destination bus created first to connect to it.\n * Use the following as the edges param to describe the graph:\n * [[\"bussA\", \"bussB\"], [\"master\"], [\"bussB\", \"master\"]]\n * You would then get the following return value from the topoSort:\n * [\"master\", \"bussB\", \"bussA\"]\n *\n * This function will accept input and output arrays to use any type that can be converted with toString for indexing.\n * So you can also use a numerical graph, such as [[1,2], [0], [2,0]], which would return [0,2,1] as number[]\n *\n * @param {T[][]} edges Array containing arrays with id and destination pairs, with destination being optional.\n * @return {T[]} Array with sorted ids, from bottom up.\n */\nexport function topoSort<T extends { toString: () => string }>(edges: T[][]): T[] {\n    class EdgeNode {\n        public afters:T[] = []\n        constructor(public id: T) {}\n    }\n    const nodes: {[key: string]: EdgeNode}   = {}\n    const sorted: T[]  = []\n\n    // hash: id of already visited node => true\n    const visited: {[key: string]: boolean } = {}\n\n    // 1. build data structures\n    edges.forEach((edge: T[]) => {\n\n        const fromEdge: T = edge[0]\n        const fromStr: string = fromEdge.toString()\n        let fromNode: EdgeNode = nodes[fromStr]\n        if (!fromNode) {\n            fromNode = nodes[fromStr] = new EdgeNode(fromEdge)\n        }\n        edge.forEach((toEdge: T) => {\n\n            // since from and to are in same array, we'll always see from again, so make sure we skip it..\n            if (!toEdge || toEdge === fromEdge) {\n                return\n            }\n            const toEdgeStr: string = toEdge.toString()\n\n            if (!nodes[toEdgeStr]) {\n                nodes[toEdgeStr] = new EdgeNode(toEdge)\n            }\n            fromNode.afters.push(toEdge)\n        })\n    })\n\n    // 2. topological sort\n    const keys: string[] = Object.keys(nodes)\n\n    const visit = (idstr: string, ancestorsIn: unknown) => {\n        const node: EdgeNode = nodes[idstr]\n        const id: T = node.id\n\n        // if already exists, do nothing\n        if (visited[idstr]) {\n            return\n        }\n\n        const ancestors: T[] = Array.isArray(ancestorsIn) ? ancestorsIn : []\n\n        ancestors.push(id)\n        visited[idstr] = true\n\n        for (const afterID of node.afters) {\n            // if already in ancestors, a closed chain exists.\n            if (ancestors.indexOf(afterID) >= 0) {\n                throw new Error(\"Circular chain found: \" + id + \" must be before \" + afterID +\n                    \" due to a direct order specification, but \" + afterID + \" must be before \" + id + \n                    \" based on other specifications.\")\n            }\n\n            // recursive call\n            visit(afterID.toString(), ancestors.map((v) => v))\n        }\n        sorted.unshift(id)\n    }\n    keys.forEach(visit)\n\n    return sorted.reverse()\n}\n", "import { Assert, AssertIsNumber, asWriteable, clone, exists, hasOwnProperty, isNumber, isObject } from '@netent-tech/ecas-utils'\nimport { AudioAction, IBasicTranslation, IMinMaxTranslation, Translation, TranslationProps } from \"@netent-tech/ecas-common\"\nimport { Utils } from '../utils'\n\nfunction isBasicTranslation (obj: object): obj is IBasicTranslation {\n    if (hasOwnProperty(obj, TranslationProps.in) && hasOwnProperty(obj, TranslationProps.out)) {\n        return isNumber(obj[TranslationProps.in]) && isNumber(obj[TranslationProps.out])\n    }\n    return false\n}\n\nfunction isMinMaxTranslation (obj: object): obj is IMinMaxTranslation {\n    if (hasOwnProperty(obj, TranslationProps.min) && hasOwnProperty(obj, TranslationProps.max)) {\n        if (isObject(obj.min) && isObject(obj.max)) {\n            return isBasicTranslation(obj.min) && isBasicTranslation(obj.max)\n        }\n    }\n    return false\n}\n\nfunction isTranslation (thing: unknown): thing is Translation {\n    if (isObject(thing) && hasOwnProperty(thing, TranslationProps.param)) {\n        return hasOwnProperty(thing, TranslationProps.param)\n            && isBasicTranslation(thing)\n            || isMinMaxTranslation(thing)\n    }\n    return false\n}\n\nfunction translateMinMax(translation: Readonly<IMinMaxTranslation>, arg: Readonly<number>) {\n    const inMin = Utils.randomizeValues(translation.min.in)\n    const outMin = Utils.randomizeValues(translation.min.out)\n    const inRange = Utils.randomizeValues(translation.max.in) - inMin\n    const outRange = Utils.randomizeValues(translation.max.out) - outMin\n    const factor = (arg - inMin) / inRange\n    return outRange * factor + outMin\n}\n\nfunction translateBasic (translation: Readonly<IBasicTranslation>, arg: Readonly<number>) {\n    if (arg === translation.in) {\n        // will only randomize if translation.out is an array, otherwise same as in\n        return Utils.randomizeValues(translation.out)\n    }\n    throw new Error(\"translateBasic failed\")\n}\n\nfunction translateObject (translation: Readonly<Translation>, arg: Readonly<number>) {\n    if (isBasicTranslation(translation)) {\n        return translateBasic(translation, arg)\n    }\n    else if (isMinMaxTranslation(translation)) {\n        return translateMinMax(translation, arg)\n    }\n    throw new Error ('ECAS Translator.translateObject should never reach this line.')\n}\n\n// only exported for testing\nfunction translateTranslation (translation: Translation, gameArgs: readonly unknown[]) {\n    Assert(gameArgs.length > translation.param, 'translateAction param is out of range. Aborting.')\n    const arg = gameArgs[translation.param]\n    AssertIsNumber(arg, `translate only works for numbers but arg is ${typeof arg}, args.length: ${gameArgs.length}, eventParam: ${translation.param}, args: ${gameArgs}`)\n    return translateObject(translation, arg)\n}\n\nexport function translateActionArgs (actionArgs: Readonly<AudioAction['args']>, gameArgs: readonly unknown[]): Readonly<AudioAction['args']> {\n    const result = asWriteable(clone(actionArgs)) \n    const gameArgsCopy = [...gameArgs]\n\n    for (let i = 0; i < result.length; i++) {\n        const actionArg = result[i]\n        if (isTranslation(actionArg)) {\n            result[i] = translateTranslation(actionArg, gameArgsCopy)\n        }\n        else if (isObject(actionArg)) {\n            for (const [key, value] of Object.entries(actionArg)) {\n                if (isTranslation(value)) {\n                    const ri = result[i]\n                    if (exists(ri)) {\n                        (ri as [])[key] = translateTranslation(value, gameArgsCopy)\n                    }\n                }\n            }\n        }\n    }\n    return result\n}\n\n// recommended for making it clear it is only exported for testing reasons and not needed to be exported otherwise.\nexport const Testing = {\n    translateTranslation\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\r\nimport { type Disposable, exists, isArray, isDefined, isNumber, isObject, isString, keys, tryAsync, unique } from '@netent-tech/ecas-utils'\r\nimport { ECAS } from \"../ECAS\"\r\nimport type { AudioAction, EventConfig, EventConnections, IAudioState, ILoadrConfig, StateConfig } from \"@netent-tech/ecas-common\"\r\nimport { Observable } from \"./Observable\"\r\nimport { StateMachine } from \"./StateMachine\"\r\nimport { translateActionArgs } from \"./translations\"\r\n\r\n/**\r\n * Adds support for mapping game events to sound events\r\n * Sets up state handler that manages audio states.\r\n */\r\nexport class EventHandler extends Observable implements Disposable {\r\n    public stateMachine: StateMachine\r\n    private _gameEvents: Array<string>\r\n    private _audioEvents: Set<string>\r\n    private _eventMap: Map<EventConfig[number]['id'], EventConfig[number]['actions']>\r\n    private _ecas: Readonly<ECAS>\r\n\r\n    dispose() {\r\n        this._gameEvents = []\r\n        this._audioEvents = new Set()\r\n        this._eventMap.clear()\r\n        this.stateMachine.dispose()\r\n    }\r\n\r\n    constructor(events: Readonly<EventConfig>, states: Readonly<StateConfig>, loaderConfig: Readonly<ILoadrConfig>,  ecas: Readonly<ECAS>) {\r\n        super()\r\n        this._eventMap = new Map<EventConfig[number]['id'], EventConfig[number]['actions']>()\r\n        for (const event of events) {\r\n            this._eventMap.set(event.id, event.actions)\r\n        }\r\n        this._gameEvents = this._createListOfGameEvents(Object.values(states))\r\n        this._audioEvents = this._createSetOfAudioEvents(events)\r\n        this.stateMachine = new StateMachine(states, loaderConfig)\r\n        this._ecas = ecas\r\n        logger().info(\"[ecas] gameEvents:\", this._gameEvents)\r\n        logger().info(\"[ecas] audioEvents:\", this._audioEvents)\r\n        logger().info(\"[ecas] actions:\", this._eventMap)\r\n    }\r\n\r\n    /**\r\n     * Proxies the game event through the state handler into ecas.\r\n     */\r\n    public async triggerGameEvent(gameEvent: string, ...args: readonly unknown []) {\r\n        logger().info('[ecas] game-event', gameEvent, ...args)\r\n        const isEventRelevant = this._gameEvents.includes(gameEvent)\r\n        if (!isEventRelevant) {\r\n            return\r\n        }\r\n\r\n        // Maybe gameEvent triggers a state change\r\n        this.stateMachine.triggerStateChange(gameEvent, ...args)\r\n        const audioEvent = this.getAudioEventName(gameEvent, ...args)\r\n        if (!audioEvent) {\r\n            return\r\n        }\r\n        // be careful so that triggering actions doesn't halt the rest of\r\n        // game if an issue occurs\r\n        const [error] = await tryAsync(this.triggerAudioEvent.bind(this))(audioEvent, ...args)\r\n        if (error) {\r\n            logger().log(\"[ecas] error when running event:\", audioEvent, error)\r\n        }\r\n    }\r\n\r\n    /* Use this if you want to trigger an audio event directly */\r\n    public async triggerAudioEvent(audioEvent: string, ...args: readonly unknown []) {\r\n        logger().info('[ecas] audio-event', audioEvent, ...args)\r\n        const promises: Promise<unknown>[] = []\r\n        this.emit(audioEvent, ...args)\r\n        if (audioEvent) {\r\n            if (!this._audioEvents.has(audioEvent)) {\r\n                return Promise.resolve()\r\n            }\r\n            const actions = this._eventMap.get(audioEvent)\r\n            if (isDefined(actions)) {\r\n                for (const action of actions) {\r\n                    promises.push(this.runAction(action, ...args))\r\n                }\r\n            }\r\n        }\r\n        return Promise.all(promises)\r\n    }\r\n\r\n    public triggerOnEndedEvent(eventName: string, ...args: readonly undefined []) {\r\n        // requested to make playlist functionality in tacofury possible\r\n        this.triggerGameEvent(eventName, ...args)\r\n        // previously only triggered audio event\r\n        this.triggerAudioEvent(eventName, ...args)\r\n    }\r\n\r\n    private async runAction(action: AudioAction, ...args: readonly unknown []) {\r\n        const translatedArgs = translateActionArgs(action.args, args)\r\n        const method = this._ecas[action.type]\r\n        const unsafe = method as any\r\n        // be careful so that triggering actions doesn't halt the rest of\r\n        // game if an issue occurs, but throw it on debug build so tests fail\r\n        const [error] = await tryAsync(() => unsafe.apply(this._ecas, translatedArgs))()\r\n        if (error) {\r\n            logger().log(\"[ecas] error when running action:\", action, error)\r\n        }\r\n    }\r\n\r\n    private getAudioEventName(event: string, ...args: readonly unknown []): string {\r\n        const ret = this._getAudioEventConnectionOrName(event)\r\n\r\n        if (!exists(ret)) {\r\n            logger().debug('[ecas] no audio-event to trigger on game-event:', event, 'in state:', this.stateMachine.activeState)\r\n            return ''\r\n        }\r\n\r\n        if (isObject(ret)) {\r\n            return walkThroughObject(ret)\r\n        }\r\n        // audio-event is a string\r\n        return ret\r\n\r\n        /**\r\n         * if game for example sends: GameAudioEvents.ReelBounce 0\r\n         * and eventmapping is\r\n         *  [GameAudioEvents.ReelBounce]: {\r\n         *       0: AudioEvents.Bounce1,\r\n         *       1: AudioEvents.Bounce2\r\n         * },\r\n         * then should return AudioEvents.Bounce1\r\n        */\r\n        function walkThroughObject(obj: object) {\r\n            // Look through the members to see if args correspond\r\n            if (isArray(args)) {\r\n                const key = args[0]\r\n                if (isString(key) || isNumber(key)) {\r\n                    const mappedEvent = obj[key]\r\n                    if (isString(mappedEvent)) {\r\n                        return mappedEvent\r\n                    }\r\n                }\r\n            }\r\n            return ''\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<string>} A copy of all game events that existed in the audio-states file.\r\n     */\r\n    get gameEvents(): readonly string[] {\r\n        return this._gameEvents\r\n    }\r\n\r\n\r\n    /**\r\n     * @returns {Array<string>} A copy of all audio event names that existed in the audio-states file.\r\n     */\r\n    get audioEvents(): readonly string[] {\r\n        return [...this._audioEvents.keys()]\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets the audio event linked to the game event for the current state (or it's parent states if it is not used) | or null if no event should be triggered\r\n     */\r\n    private _getAudioEventConnectionOrName(gameEvent: string, state = this.stateMachine.activeState): string | EventConnections | null {\r\n        const audioEvent = state.events[gameEvent]\r\n\r\n        if (audioEvent) {\r\n            return audioEvent\r\n        }\r\n        else if (state.parent) {\r\n            const parent = this.stateMachine.getState(state.parent)\r\n            return this._getAudioEventConnectionOrName(gameEvent, parent)\r\n        }\r\n        return null\r\n    }\r\n\r\n    private _createListOfGameEvents(states: ReadonlyArray<IAudioState>): Array<string> {\r\n        const arr = states.map (\r\n            (state) =>\r\n                [\r\n                    ...keys(state.events),\r\n                    ...state.activatesOn.map((activation) => isString(activation) ? activation : activation.event),\r\n                    ...state.deactivatesOn.map((activation) => isString(activation) ? activation : activation.event),\r\n                    ...this._createListOfGameEvents(Object.values(state.children))\r\n                ]\r\n        )\r\n        const flat = arr.flat()\r\n        return unique(flat)\r\n    }\r\n\r\n    private _createSetOfAudioEvents(events: Readonly<EventConfig>) {\r\n        const audioEvents = new Array<string>()\r\n        for (const event of events) {\r\n            audioEvents.push(event.id)\r\n        }\r\n        return new Set(audioEvents)\r\n    }\r\n}\r\n", "export const EcasEvents = {\n    Ready: 'ecas-ready', // ecas has been initialized, you can add effects to busses etc\n    Mute: 'ecas-mute',\n    Unmute: 'ecas-unmute',\n    Pause: 'ecas-pause',\n    Resume: 'ecas-resume',\n    Timer: {\n        Pause: 'ecas-timer-pause',\n        Resume: 'ecas-timer-resume',\n    },\n    Context: {\n        Pause: 'ecas-context-pause',\n        Resume: 'ecas-context-resume',\n        Suspended: 'ecas-context-suspended',\n        Running: 'ecas-context-running',\n        Closed: 'ecas-context-closed',\n        Interrupted: 'ecas-context-interrupted',\n    },\n    Preload: {\n        Start:   \"ecas-preload-start\",\n        Done:    \"ecas-preload-done\",\n        Progress: \"ecas-preload-progress\",\n    },\n    Sound: {\n        LoadStart:     'ecas-sound-load-start',\n        Loading:       'ecas-sound-load-loading',\n        LoadDone:      'ecas-sound-load-done',\n        LoadError:     'ecas-sound-load-error',\n        Abort:         'ecas-sound-abort',\n        CanPlay:       'ecas-sound-canplay',\n        Play:          'ecas-sound-play',\n        Stop:          'ecas-sound-stop',\n        Ended:         'ecas-sound-ended',\n        Pause:         'ecas-sound-pause',\n        FadeOutStart:  'ecas-sound-fade-out-start',\n        FadeOutEnd:    'ecas-sound-fade-out-end',\n        PlaybackStart: 'ecas-sound-playback-start',\n        PlaybackEnd:   'ecas-sound-playback-end',\n        PlaybackError: 'ecas-sound-playback-error',\n    },\n    Events: {\n        LoadStart:     'ecas-events-load-start',\n        LoadDone:      'ecas-events-load-done',\n    },\n    Envelope: {\n        Play:          'ecas-envelope-play',\n        Start:         'ecas-envelope-start',\n        Ended:         'ecas-envelope-ended',\n    },\n} as const\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { exists, tryAsync, trySync } from \"@netent-tech/ecas-utils\"\nimport { Sound } from \"@netent-tech/ecas-common\"\nimport EventHandler, { EcasEvents } from \"../event-handler\"\nimport { ILoadSoundDetails } from \"./SoundHandler\"\n\nexport interface ICreateAudioBufferOptions {\n    id: Sound['id'] // only needed for triggering event\n    eventHandler: EventHandler\n    audioContext: AudioContext\n    url: string\n    duration?: number\n}\n\ninterface ICreateBufferOptions extends ICreateAudioBufferOptions {\n    arrayBuffer: ArrayBuffer\n}\n\ninterface ICreateEditedBufferOptions {\n    buffer: AudioBuffer\n    duration: number\n    audioContext: AudioContext\n}\n\ninterface ICreateAndStoreAudioBufferParams {\n    id: Sound['id'],\n    detail: ILoadSoundDetails,\n    mutBuffers: Map<Sound['id'], AudioBuffer>,\n    audioContext: AudioContext\n    eventHandler: EventHandler\n}\n\ninterface ICreateBufferPromisesParams {\n    ids: Sound['id'][],\n    mutDetails: Map<Sound['id'], ILoadSoundDetails>,\n    mutBuffers: Map<Sound['id'], AudioBuffer>,\n    audioContext: AudioContext,\n    eventHandler: EventHandler\n}\n\nexport function createBufferPromises (params: ICreateBufferPromisesParams) {\n    const { ids, mutDetails, eventHandler } = params\n    const promises: Promise<void>[] = []\n    for (const id of ids) {\n\n        if (!mutDetails.has(id)) {\n            logger().error(\"[ecas] create buffer'\", id, \"' not found in\", mutDetails)\n            continue\n        }\n\n        const detail = mutDetails.get(id)\n        if (detail.isLoaded) {\n            logger().debug(\"[ecas] sound\", id, \"has already been loaded\")\n            continue\n        }\n\n        if (detail.isLoading) {\n            logger().debug(\"[ecas] sound\", id, \"is already in the process of being loaded\")\n            continue\n        }\n\n        detail.isLoading = true\n        eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadStart, id)\n        // doing it this way to be able to fetch them all at the same time without having to wait for one to load before we can load next\n        promises.push(createAndStoreAudioBuffer({id: id, detail: detail, ...params }))\n    }\n    return promises\n}\n\nexport async function createAndStoreAudioBuffer (params: ICreateAndStoreAudioBufferParams) {\n    const { id, detail: detail, mutBuffers, eventHandler } = params\n    const [error, buffer] = await tryAsync(() => createAudioBuffer({ ...params, duration: detail.duration, url: detail.url }))()\n    if (error) {\n        logger().error(error)\n        detail.isLoaded = false\n        detail.isLoading = false\n        eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadError, id)\n        return\n    }\n    mutBuffers.set(id, buffer)\n    detail.isLoaded = true\n    detail.isLoading = false\n    eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadDone, id)\n}\n\nexport async function createAudioBuffer(options: ICreateAudioBufferOptions): Promise<AudioBuffer> {\n    return new Promise<AudioBuffer>((resolve, reject) => {\n        const req = createRequest(options.url)\n        req.addEventListener(\"abort\", () => {\n            reject(`[ecas]rRequest for ${options.url} aborted`)\n        })\n        req.addEventListener(\"timeout\", () => {\n            reject(`[ecas]rRequest for ${options.url} timed out`)\n        })\n        req.addEventListener(\"load\", () => {\n            options.eventHandler.triggerAudioEvent(EcasEvents.Sound.Loading, options.id)\n            const arrayBuffer = req.response as ArrayBuffer\n            if (arrayBuffer.byteLength === 0) {\n                reject(\"[ecas] response returned arraybuffer with byteLength 0\")\n            }\n            createBuffer({ ...options, arrayBuffer })\n                .then(\n                    buffer => resolve(buffer),\n                    reason => reject(reason)\n                )\n                .catch(reason => reject(reason))\n        })\n        req.addEventListener(\"error\", (ev: ProgressEvent<XMLHttpRequestEventTarget>) => {\n            reject(`[ecas] error when requesting: '${options.url}', ${ev}`)\n        })\n        req.send()\n    })\n}\n\nfunction createRequest(url: string) {\n    const request = new XMLHttpRequest()\n    request.open(\"GET\", url, true)\n    request.responseType = \"arraybuffer\"\n    return request\n}\n\nasync function createBuffer(options: ICreateBufferOptions) {\n    return new Promise<AudioBuffer>((resolve, reject) => {\n        const { duration, arrayBuffer, audioContext, url } = options\n        audioContext\n            .decodeAudioData(arrayBuffer,\n                (buffer) => {\n                    const [error, ] = trySync(() => {\n                        const isDifferentDuration = duration !== buffer.duration\n                        if (isDifferentDuration && duration > 0) {\n                            const editedBuffer = createEditedBuffer({ audioContext, buffer, duration })\n                            resolve(editedBuffer)\n                        }\n                        resolve(buffer)\n                    })()\n                    if (error) {\n                        reject(error)\n                    }\n                },\n                (error) => {\n                    options.eventHandler.triggerAudioEvent(EcasEvents.Sound.LoadError, options.id)\n                    logger().error('[ecas] createBuffer: Failed to decode audio data at url ', url, 'Error:', error )\n                    reject('[ecas] failed to decode audio data')\n                }\n            )\n            .then(\n                buffer => resolve(buffer),\n                reason => reject(reason)\n            )\n            .catch(reason => {\n                reject(reason)\n            })\n    })\n}\n\nfunction createEditedBuffer(options: ICreateEditedBufferOptions): AudioBuffer {\n    const { duration, buffer, audioContext } = options\n    const length = Math.floor(duration * buffer.sampleRate)\n    const editedBuffer = audioContext.createBuffer(buffer.numberOfChannels, length, buffer.sampleRate)\n    return copyAudioBuffer({src: buffer, trg: editedBuffer})\n}\n\ninterface ICopyBuffer {\n    src: AudioBuffer\n    trg: AudioBuffer\n}\n\nfunction copyAudioBuffer(options: ICopyBuffer) {\n    const isDecentBrowser = exists(options.src.copyToChannel)\n    if (isDecentBrowser) {\n        return copyAudioBufferDefault(options)\n    }\n    return copyAudioBufferLegacy(options)\n}\n\nfunction copyAudioBufferDefault(options: ICopyBuffer) {\n    const { src, trg } = options\n    for (let i = 0; i < src.numberOfChannels; i++) {\n        trg.copyToChannel(src.getChannelData(i), i, 0)\n    }\n    return trg\n}\n\nfunction copyAudioBufferLegacy(options: ICopyBuffer) {\n    const { src, trg } = options\n    for (let i = 0; i < src.numberOfChannels; i++) {\n        const editedChannel = trg.getChannelData(i)\n        const originalChannel = src.getChannelData(i)\n        for (let j = 0; j < editedChannel.length; j++) {\n            editedChannel[j] = originalChannel[j] || 0\n        }\n    }\n    return trg\n}\n\nfunction createEmptyAudioBufferLike(buffer: AudioBuffer, audioContext: AudioContext) {\n    return audioContext.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate)\n}\n\nfunction reverseAudioBuffer(bufferMutable: AudioBuffer) {\n    for (let channelNumber = 0; channelNumber < bufferMutable.numberOfChannels; channelNumber++) {\n        const data = bufferMutable.getChannelData(channelNumber)\n        const reversedData = data.reverse()\n        bufferMutable.copyToChannel(reversedData, channelNumber)\n    }\n    return bufferMutable\n}\n\nexport function createReversedBuffer(src: AudioBuffer, audioContext: AudioContext) {\n    const newBufferEmpty = createEmptyAudioBufferLike(src, audioContext)\n    const newBufferFilled = copyAudioBuffer({src: src, trg: newBufferEmpty})\n    return reverseAudioBuffer(newBufferFilled)\n}\n", "export class SoundLoadError extends Error {\n    override name = \"SoundLoadError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class SoundFormatError extends Error {\n    override name = \"SoundFormatError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class SoundUndefinedError extends Error {\n    override name = \"SoundUndefinedError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n\nexport class DecodeError extends Error {\n    override name = \"DecodeError\"\n\n    constructor(message?: string) {\n        super(message)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { Assert, Disposable, Exists, isUndefined, joinUrl } from '@netent-tech/ecas-utils'\nimport { Sound } from \"@netent-tech/ecas-common\"\nimport EventHandler from \"../event-handler\"\nimport { EcasOptions } from \"../options-creator\"\nimport { createBufferPromises, createReversedBuffer } from \"./buffers\"\nimport { SoundLoadError } from \"./errors\"\n\nexport interface ILoadSoundDetails {\n    url: string\n    isLoaded: boolean\n    isLoading: boolean\n    duration?: number\n}\n\nexport interface SoundHandlerOptions {\n    ecasOptions: EcasOptions\n    audioContext: AudioContext\n    eventHandler: EventHandler\n}\n\nexport class SoundHandler implements Disposable {\n    // priorityQueue: string[] = []\n    #audioContext: AudioContext\n    #details = new Map<Sound['id'], ILoadSoundDetails>()\n    #buffers = new Map<Sound['id'], AudioBuffer>()\n    #reversedBuffers = new Map<Sound['id'], AudioBuffer>()\n    #sounds: Map<Sound['id'], Sound>\n    #eventHandler: EventHandler\n\n    dispose () {\n        this.#buffers.clear()\n        this.#reversedBuffers.clear()\n        this.#details.clear()\n        this.#sounds.clear()\n        this.#eventHandler.dispose()\n    }\n\n    constructor(options: SoundHandlerOptions) {\n        const { ecasOptions, audioContext, eventHandler } = options\n        this.#audioContext = audioContext\n        this.#eventHandler = eventHandler\n\n        const { fileExtToUse, soundData, packageToUse } = ecasOptions.loadrConfig\n        const sounds = ecasOptions.soundConfig.sounds\n        const directory = joinUrl(ecasOptions.soundConfig.settings.loadPath, packageToUse)\n\n        for (const sound of sounds) {\n            this.details.set(sound.id, {\n                url: joinUrl(directory, sound.id) + fileExtToUse,\n                duration: soundData.get(sound.id) || 0,\n                isLoaded: false,\n                isLoading: false\n            })\n        }\n\n        this.#sounds = new Map(ecasOptions.soundConfig.sounds.map(sound => [sound.id, sound]))\n    }\n\n    get details() {\n        return this.#details\n    }\n\n    public getSound(id: Sound['id']): Sound {\n        Assert(this.#sounds.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] sound '${id}' does not exist.`\n        })\n        return Exists(this.#sounds.get(id))\n    }\n\n    public getDurationSeconds (id: Sound['id']) {\n        const detail = Exists(this.details.get(id))\n        if(isUndefined(detail.duration)) {\n            logger().error(`[ecas] sound '${id}' does not have a duration.`)\n        }\n        return detail.duration || this.getAudioBufferSync(id).duration // seconds\n    }\n\n    public async getAudioBuffer(id: Sound['id']) {\n        Assert(this.details.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] sound with id: ${id} cannot be loaded because it does not seem to exist`\n        })\n        if (Exists(this.details.get(id)).isLoaded) {\n            return Exists(this.#buffers.get(id))\n        }\n        logger().debug(\"[ecas] buffer has not been loaded yet, loading now...\")\n        await this.load([id]).catch(() => {\n            logger().log(`[ecas] sound with id: ${id} cannot be loaded`)\n        })\n        return Exists(this.#buffers.get(id))\n    }\n\n    public getAudioBufferSync(id: Sound['id']) {\n        Assert(this.details.has(id), {\n            Err: SoundLoadError,\n            msg: `[ecas] getBuffer - Sound with id: ${id} cannot be loaded because it does not seem to exist`\n        })\n        if (Exists(this.details.get(id)).isLoaded) {\n            return Exists(this.#buffers.get(id))\n        }\n        logger().debug(\"[ecas] getBuffer; buffer has not been loaded yet. Cannot use the sync version for this, make sure you load the sound before calling this method.\")\n        return Exists(this.#buffers.get(id))\n    }\n\n    public async getAudioBufferReversed(id: Sound['id']) {\n        if (!this.#reversedBuffers.has(id)) {\n            await this.#createReversedBufferForSound(id)\n        }\n        return this.#reversedBuffers.get(id)\n    }\n\n    /**\n     * if buffer has already been loaded soundHandler will return already existing buffer\n    */\n    public async load (ids: Sound['id'][]) {\n        logger().debug(\"[ecas] load\", ids)\n        // Todo: Check that AudioContext has been allowed to start\n        const bufferPromises = createBufferPromises({\n            ids: ids,\n            mutDetails: this.details,\n            mutBuffers: this.#buffers,\n            audioContext: this.#audioContext,\n            eventHandler: this.#eventHandler\n        })\n\n        return Promise.all(bufferPromises)\n    }\n\n    public async loadAll () {\n        logger().debug(\"[ecas] loadAll\")\n        await this.load([...this.#sounds.keys()])\n    }\n\n    public getAllSoundIds () {\n        return [...this.#sounds.keys()]\n    }\n\n    public isLoaded (id: Sound['id']) {\n        const is = this.details.has(id) && Exists(this.details.get(id)).isLoaded\n        return is\n    }\n\n    async #createReversedBufferForSound(id: Sound['id']) {\n        const buffer = await this.getAudioBuffer(id)\n        const reversed = createReversedBuffer(buffer, this.#audioContext)\n        this.#reversedBuffers.set(id, reversed)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isNonEmptyArray, type Disposable } from '@netent-tech/ecas-utils'\nimport { AudioAction, Group, IPatternContext, Pool, Sound } from \"@netent-tech/ecas-common\"\nimport { EcasOptions } from \"../options-creator\"\nimport { SoundHandler, SoundHandlerOptions } from \"./SoundHandler\"\n\n/**\n * Purpose: handle loading of assets (audio files mainly) for ecas\n *  should:\n *      load audio-files\n *      store buffers\n *      have a priority\n *      does it need to be able to load other assets?\n *\n *      load single AudioFiles\n *      load all AudioFiles = one package (desktop or mobile)\n */\nexport class AssetHandler implements Disposable {\n    soundHandler: SoundHandler\n    #groups: Map<string, Group> = new Map()\n    #pools: Map<string, Pool> = new Map()\n    /** used to store assets to be loaded that are related to events **/\n    #eventAssets: Map<string, Sound['id'][]> = new Map()\n\n    // #patterns: Map<string, Pattern> = new Map()\n    #patternContexts: Map<string, IPatternContext> = new Map()\n\n    dispose () {\n        this.#groups = new Map()\n        this.#pools = new Map()\n        this.#eventAssets = new Map()\n        this.#patternContexts = new Map()\n        this.soundHandler.dispose()\n    }\n\n    constructor(options: SoundHandlerOptions) {\n        this.soundHandler = new SoundHandler(options)\n\n        for (const group of options.ecasOptions.soundConfig.groups) {\n            this.#groups.set(group.id, group)\n        }\n        for (const pool of options.ecasOptions.soundConfig.pools) {\n            this.#pools.set(pool.id, pool)\n        }\n        // for (const pattern of options.ecasOptions.soundConfig.patterns) {\n        //     this.#patterns.set(pattern.id, pattern)\n        // }\n        this.#storeSoundsRelatedToEvents(options.ecasOptions)\n    }\n\n    #storeSoundsRelatedToEvents(ecasOptions: EcasOptions) {\n        // todo: expand to work for more event targets than \"playSound\"\n        const events = ecasOptions.eventConfig\n\n        for (const { id, actions } of events) {\n            this.#eventAssets.set(id, findSoundsUsedInActions(actions))\n        }\n        return\n\n        function findSoundsUsedInActions (actions: readonly AudioAction[]) {\n            const soundsUsed: string[] = []\n            for (const action of actions) {\n                if (action.type === \"playSound\") {\n                    soundsUsed.push(action.args[0].toString())\n                }\n            }\n            return soundsUsed\n        }\n    }\n\n    loadAssetsRelatedToEvents(ids: string[]) {\n        const loadPromises = ids.map(id => {\n            const relatedAssets = this.#eventAssets.get(id)\n            if (isNonEmptyArray(relatedAssets)) {\n                return this.soundHandler.load(relatedAssets)\n            }\n            logger().debug(`[ecas] asset - found no assets for event '${id}' ${this.#eventAssets.get(id)}`)\n            return Promise.resolve()\n        })\n        return Promise.all(loadPromises)\n    }\n\n    getPool(id: string) {\n        if (!this.#pools.has(id)) {\n            logger().error('[ecas] asset - pool with id', id, 'does not exist')\n        }\n        return this.#pools.get(id)\n    }\n\n    hasPool(id: string) {\n        return this.#pools.has(id)\n    }\n\n    getGroup(id: string) {\n        if (!this.#groups.has(id)) {\n            logger().error('[ecas] asset - group with id', id, 'does not exist')\n        }\n        return this.#groups.get(id)\n    }\n\n    getPatternContext(id: string) {\n        if (!this.#patternContexts.has(id)) {\n            logger().error('[ecas] asset - pool with id', id, 'does not exist')\n        }\n        return this.#patternContexts.get(id)\n    }\n\n    hasPatternContext(id: string) {\n        this.#patternContexts.has(id)\n    }\n\n    setPatternContext(id: string, ctx: IPatternContext) {\n        this.#patternContexts.set(id, ctx)\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { enumValues, hasOwnProperty, isDefined, isFunction } from \"@netent-tech/ecas-utils\"\nimport { AudioFileExtension } from \"@netent-tech/ecas-common\"\nimport { SoundFormatError } from \"./errors\"\n\nconst AudioFormats = {\n    caf: 'x-caf',\n    webm: 'webm',\n    ogg: 'ogg',\n    mp4: 'mp4',\n    mp3: 'mp3'\n} as const\n\n/**\n * Different browsers support different audio file formats\n * so this method is used to determine what files to load.\n */\nexport function getPrefferedFileExtension(available: AudioFileExtension[] = enumValues(AudioFileExtension)): AudioFileExtension {\n    // Todo: need to check for what extensions actually exists to use in formatPresets....\n    const supported = getBrowserSupportedAudioFormats()\n\n    logger().debug(\"[ecas] supported AudioFormats:\")\n    logger().table(supported)\n\n    // if error here it's because we dont have dom library,\n    // eg. its ecas-encoder using the function so we return a dummy value since it doesnt matter\n    if (supported === null) {\n        try {\n            isDefined(navigator)\n        }\n        catch {\n            return AudioFileExtension.WEBM\n        }\n    }\n\n    const isEdgeBrowser = () => /Edge/.test(navigator.userAgent)\n    const isSafari = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent)\n    const actuallySupportsWebm = () => !isEdgeBrowser() && !isSafari()\n\n    const isSafariOnDesktop = () => hasOwnProperty(window, 'safari') && isDefined(window.safari)\n    const isSafariOnMobile = () => isSafari() && !isSafariOnDesktop()\n    if (isEdgeBrowser()) {\n        logger().debug('[ecas] Edge Browser detected.')\n    }\n    if (isSafariOnDesktop()) {\n        logger().debug('[ecas] Safari on desktop detected.')\n    }\n    if (isSafariOnMobile()) {\n        logger().debug('[ecas] Safari on mobile detected.')\n    }\n\n    if (supported !== null) {\n        const isAvailable = (ext: AudioFileExtension) => available.includes(ext) // encoding format exists in soundConfig\n        const usable = (ext: AudioFileExtension) => supported[ext] && isAvailable(ext)\n        if (usable(AudioFileExtension.WEBM) && actuallySupportsWebm()) // Edge supports opus but it is too slow at decoding, safari pretends to play but does not..\n            return AudioFileExtension.WEBM\n        if (usable(AudioFileExtension.MP4)) // safari .caf opus often don't work with ffmpeg encoding which is why we prefer mp4 over .caf\n            return AudioFileExtension.MP4\n        if (usable(AudioFileExtension.MP3))\n            return AudioFileExtension.MP3\n        if (usable(AudioFileExtension.CAF))\n            return AudioFileExtension.CAF\n    }\n\n    throw new SoundFormatError(\"[ecas] no available audio file format found.\")\n}\n\n/** Returns null if no supported formats found. */\nexport function getBrowserSupportedAudioFormats() {\n    let element: HTMLAudioElement\n    try {\n        element = new window.Audio()\n    }\n    catch {\n        return null\n    } // need to catch for ecas-encoder.....\n\n    if (!isFunction(element.canPlayType)) {\n        return null\n    }\n\n    const canPlay = (type: string) => {\n        const can = element.canPlayType(`audio/${type}`)\n        enum CanPlay { Probably = \"probably\", Maybe = \"maybe\" }\n        return can === CanPlay.Probably || can === CanPlay.Maybe\n    }\n\n    return {\n        [AudioFileExtension.WEBM]: canPlay(AudioFormats.webm), // return false if safari they be pretending, same with edge sorta\n        [AudioFileExtension.MP4]: canPlay(AudioFormats.mp4),\n        [AudioFileExtension.CAF]: canPlay(AudioFormats.caf),\n        [AudioFileExtension.OGG]: canPlay(AudioFormats.ogg),\n        [AudioFileExtension.MP3]: canPlay(AudioFormats.mp3)\n    }\n}\n", "export const TIME_LOOKAHEAD_SECONDS = 0.03 as const\nexport const TIME_LOOKAHEAD_MILLISECONDS = 30 as const\nexport const DEFAULT_CROSSFADE_MILLISECONDS = 10 as const\nexport const DEFAULT_FADEOUT_MILLISECONDS = 10 as const\nexport const MASTER_BUS_ID = \"master\" as const\nexport const OUTPUT_BUS_ID = \"OUTPUT\" as const\n\nexport const MAX_GAIN_LINEAR = 20 as const // totally arbitrary number\nexport const MIN_GAIN_LINEAR = 0.001 as const\nexport const MIN_PAN = -1 as const\nexport const MAX_PAN = 1 as const\nexport const MIN_FREQUENCY = 10 as const\nexport const MAX_FREQUENCY = 20000 as const\n\nexport const TIMEOUT_CALLERS = {\n    DEFAULT_STOP: 'default_stop',\n    POOL_STOP: 'pool_stop',\n    POOL_PLAY: 'pool_play',\n    POOL_PAUSE: 'pool_pause',\n    POOL_RESUME: 'pool_resume',\n    SOUND_START: 'sound_start',\n    SOUND_STOP: 'sound_stop',\n    SOUND_PAUSE: 'sound_pause',\n    SOUND_RESUME: 'sound_resume',\n    SOUND_COMPLETE: \"sound_completed\",\n    PATTERN_PLAY: 'pattern_play',\n    PATTERN_STOP: 'pattern_stop',\n    PATTERN_RESUME: 'pattern_resume',\n    PATTERN_PAUSE: 'pattern_pause',\n    PATTERN: 'pattern',\n    STOP: 'stop',\n    MIXER_PLAY_SOUND: \"mixer_playSound\",\n    ENVELOPE_SCHEDULED: \"envelope_scheduled\",\n    SCHEDULED: \"scheduled\",\n    SCHEDULED_REGEX: \"scheduled_(.)+\",\n    DISCONNECT: \"disconnect\",\n    VOLUME: \"volume\",\n    CROSSFADE: \"crossfade\",\n    PLAY: \"play\"\n} as const\n", "import { ITypeNamed, noop, PartialProperties } from \"@netent-tech/ecas-utils\"\nimport type { EnvelopeCurveType, EnvelopeParameterType, IEnvelopeContext, IEnvelopePoint, TargetType } from \"@netent-tech/ecas-common\"\n\nconst typename = \"EnvelopeContext\" as const\nexport class EnvelopeContext implements IEnvelopeContext, ITypeNamed<typeof typename> {\n    static typename = typename\n    get typename () {\n        return typename\n    }\n\n    type: TargetType = \"sound\"\n    parentId = ''\n    /** In seconds */\n    startTime = 0\n    onEnded = noop\n    onplay = noop\n    willStopSoundOnEnded = false\n    isPaused = false\n    isAFadeIn = false\n    curveType: EnvelopeCurveType = 'linear'\n    envelopePoints: IEnvelopePoint[] = []\n    param: EnvelopeParameterType = 'volume'\n\n    audioParam: AudioParam\n\n    node?: DynamicsCompressorNode | BiquadFilterNode | DelayNode | GainNode\n    pauseTime?: number\n\n    constructor(config: PartialProperties<EnvelopeContext> = {}) {\n        Object.assign(this, config)\n    }\n}\n\nexport function createEnvelopeContext(config: PartialProperties<EnvelopeContext> = {}) {\n    return new EnvelopeContext(config)\n}\n", "import { type Disposable } from \"@netent-tech/ecas-utils\"\nimport { EnvelopeContext } from \".\"\nexport class EnvelopeHandler implements Disposable {\n    #contexts = new Map<string, EnvelopeContext[]>()\n\n    dispose() {\n        this.#contexts.clear()\n    }\n\n    getContexts(id: string) {\n        if (!this.#contexts.has(id)) {\n            this.#contexts.set(id, [])\n        }\n        return this.#contexts.get(id)\n    }\n\n    setContexts(options: {id: string, contexts: EnvelopeContext[]}) {\n        this.#contexts.set(options.id, options.contexts)\n    }\n\n}\n", "import { arrayPowerMutate, arraySum, isNumber, type ITypeNamed, noop, range } from \"@netent-tech/ecas-utils\"\nimport { EnvelopeCurveType, EnvelopeParameterType, IEnvelopePoint, IPlayEnvelopeArgs, TargetType } from \"@netent-tech/ecas-common\"\n\nconst typename = \"PlayEnvelopeArgs\" as const\nexport class PlayEnvelopeArgs implements IPlayEnvelopeArgs, ITypeNamed<typeof typename> {\n    static typename = typename\n    get typename () {\n        return typename\n    }\n\n    startTime = 0\n    type: TargetType = 'sound'\n    curveType: EnvelopeCurveType = 'linear'\n    onEnded = noop\n    onplay = noop\n    willStopSoundOnEnded = false\n\n    param: EnvelopeParameterType\n    envelopePoints: IEnvelopePoint[] = []\n\n    constructor(config: IPlayEnvelopeArgs) {\n        Object.assign(this, config)\n        if (isNumber(config.startTime)) {\n            this.startTime = config.startTime / 1000\n            return\n        }\n        this.startTime = 0\n    }\n}\n\nexport function isPlayEnvelopeArgs(thing: object): thing is PlayEnvelopeArgs {\n    return thing['typename'] === PlayEnvelopeArgs.typename\n}\n\nexport function createPlayEnvelopeArgs(config: IPlayEnvelopeArgs) {\n    return new PlayEnvelopeArgs(config)\n}\n\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute(envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n    let pos = 0\n    return envelope.map((point: IEnvelopePoint) => {\n        pos += Number(point.pos)\n        return {\n            pos,\n            val: point.val\n        }\n    })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative(envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n    let last = 0\n    return envelope.map((val: IEnvelopePoint) => {\n        const currPos = val.pos\n        const pos = currPos - last\n        last = currPos\n        return {\n            pos: pos,\n            val: val.val\n        }\n    })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n */\nexport function createLogarithmicCurve(direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000) {\n    const base = 9 // what is base 9 supposed to do\n    const numSamples = Math.ceil(duration * sampleRate)\n    const curve = new Float32Array(numSamples)\n\n    const indexes = range(numSamples)\n    if (direction === -1) {\n        indexes.reverse()\n    }\n\n    for (const i of range(numSamples)) {\n        const x = base * i / numSamples + 1\n        curve[indexes[i]] = Math.log10(x)\n    }\n    return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace(first = 1, last = 10, num_samples = 10) {\n    const createSafeLogValue = (val: number) => {\n        if (val > 0) {\n            return Math.log10(val)\n        }\n        return Math.log10(1e-5) // -100 dBFS\n    }\n    const first_log10 = createSafeLogValue(first)\n    const last_log10 = createSafeLogValue(last)\n\n    const increment = (last_log10 - first_log10) / (num_samples - 1)\n    const vector = new Float32Array(num_samples)\n    let accumulated = first_log10\n\n    vector[0] = first\n    for (let index = 1; index < num_samples - 1; index++) {\n        accumulated += increment\n        vector[index] = Math.pow(10, accumulated)\n    }\n    vector[num_samples - 1] = last\n\n    return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace(first = 1, last = 10, num_samples = 10) {\n    const increment = (last - first) / (num_samples - 1)\n    const vector = new Float32Array(num_samples)\n    let accumulated = first\n    for (let index = 0; index < num_samples; index++) {\n        vector[index] = accumulated\n        accumulated += increment\n    }\n    vector[0] = first\n    vector[vector.length-1] = last\n    return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace(first = 1, last = 0, numSamples = 10) {\n    const phaseStart = Math.PI / 2\n    const vector = new Float32Array(numSamples)\n\n    // create half of a sigmoid between 0-1\n    for (let i = 0; i < numSamples; i++) {\n        const phasei = Math.PI * i / (numSamples - 1)\n        const phasen = phasei - phaseStart\n        vector[i] = Math.sin(phasen) / 2 + 0.5\n    }\n\n    // scale the curve\n    const scale = last - first\n    for (let i = 0; i < numSamples; i++) {\n        vector[i] = vector[i] * scale + first\n    }\n    return vector\n}\n\nexport function powspace(first = 1, last = 0, numSamples = 10, power = 2) {\n    const linStart = Math.pow(first, 1 / power)\n    const linEnd = Math.pow(last, 1 / power)\n    const lin = linspace(linStart, linEnd, numSamples)\n    return arrayPowerMutate(lin, power)\n}\n\nexport function coolspace(numSamples = 10, shape = 2.5) {\n    const result = new Float32Array(numSamples)\n    for (let i = 0; i < numSamples; i++) {\n        result[i] = Math.pow (\n            Math.E,\n            (-i / numSamples)\n                * shape\n                * (- Math.log(0.01))\n        )\n    }\n    return result\n}\n\nfunction createCurve(values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array) {\n    const totalNumSamples = arraySum(numSamples)\n    const curve = new Float32Array(totalNumSamples)\n\n    let value_prev = values[0]\n    let start = 0\n    for (let i = 0; i < values.length; i++) {\n        const ns = numSamples[i]\n        const slice = curveCreator(value_prev, values[i], numSamples[i])\n        curve.set(slice, start)\n        start += ns\n        value_prev = values[i]\n    }\n    return curve\n}\n\nfunction getCurveCreator(curveType: EnvelopeCurveType) {\n    return {\n        \"linear\": linspace,\n        \"exponential\": logspace,\n        \"logarithmic\": logspace,\n        \"s-curve\": sigspace,\n    }[curveType]\n}\n\n\nexport function createAutomationCurve(opt: {\n        values: number[],\n        positions: number[],\n        curveType: EnvelopeCurveType\n    }) {\n    const { values, positions, curveType } = opt\n    const numSamples = getNumSamples(positions)\n\n    const curveCreator = getCurveCreator(curveType)\n    const curve = createCurve(values, numSamples, curveCreator)\n    return curve\n}\n\nfunction getNumSamples(positions: number[]) {\n    const numSamplesPerPoint = 1/4\n    return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n\nexport * from \"./envelope-context\"\nexport * from './EnvelopeHandler'\n\n", "import { EnvelopeContext } from \".\"\n\nexport function createEnvelopePointsInOriginalState(points: readonly EnvelopeContext[], parentId: string) {\n    return points.reduce(\n        (acc, curr) => {\n            if (curr.parentId === parentId) {\n                return curr\n            }\n            return acc\n        }\n    )\n        .envelopePoints\n}\n", "import { TIMEOUT_CALLERS } from \"../constants\"\n\nexport function joinTimeoutCallers(...args: string[]) {\n    return args.join('::')\n}\n\nexport function createTimeoutCallerForPlayEnvelope(arg: {targetId: string, param: string, parentId: string, willStopSoundOnEnded: boolean}) {\n    const caller = joinTimeoutCallers(arg.targetId, arg.parentId, arg.param)\n    if (arg.willStopSoundOnEnded) {\n        return joinTimeoutCallers(caller, TIMEOUT_CALLERS.STOP)\n    }\n    return caller\n}\n", "import { exists } from '@netent-tech/ecas-utils'\nimport { IStringMap, ITimerCallback, ITimerItem } from \"@netent-tech/ecas-common\"\n\n/**\n * Wrapper for setTimeout and clearTimeout\n * Used to calculate remaining time of an timeout\n * and to dispatch callbacks when timeout ends.\n */\nexport class Timer {\n    /**\n     * Storage of callers and their timeout data.\n     */\n    private static _map: IStringMap<ITimerItem> = {}\n    /**\n     *\n     * Set a timeout and save its caller id in _map.\n     * If a caller already exists, we clear its timeout\n     * and save its callback to be dispatched once the new caller\n     * has finished.\n     * @param {() => void} callback Callback function to be called when timer ends\n     * @param {number} timeout Seconds until the timeout ends\n     * @param {string} caller Caller id of setTimeout\n     * @param {unknown[]} args Arguments for setTimeout\n     */\n\n    public static setTimeout(callback: () => void, timeout: number, caller = \"\", ...args: unknown[]) {\n        if (caller === \"\") {\n            window.setTimeout(callback, timeout * 1000, args)\n            return\n        }\n\n        const start = this.dateProvider()()\n        let callbacks: ITimerCallback[] = []\n        const callerHandle = this._map[caller]\n        if (callerHandle) {\n            callbacks = callbacks.concat(callerHandle.callbacks)\n            window.clearTimeout(callerHandle.id)\n        }\n        callbacks.push({args, callback})\n        const id = window.setTimeout(() => this.onDone(caller), timeout * 1000)\n        this._map[caller] = {id, remaining: timeout, start, callbacks, caller}\n    }\n\n    /**\n     * Renames existing timeout and clears its timeout.\n     * @param {string} caller New caller id of setTimeout\n     * @param {string} oldCaller Old caller id of setTimeout\n     * @param {number} newTimeout Seconds until the timeout ends\n     */\n    public static renameTimeout(caller: string, oldCaller: string, newTimeout?: number) {\n        const callerHandle = this._map[oldCaller]\n\n        if (callerHandle) {\n            const remaining = newTimeout || callerHandle.remaining\n            window.clearTimeout(callerHandle.id)\n            Timer.clearTimeout(oldCaller)\n            const id = window.setTimeout(() => this.onDone(caller), remaining * 1000)\n            this._map[caller] = {...callerHandle, id, remaining, caller}\n        }\n    }\n\n    /**\n     * Pauses the timeout by clearing it and calculating the remaining time of the timeout, and store that information.\n     * @param {string} caller Caller id of pause\n     */\n    public static pause(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            const now: number = this.dateProvider()()\n            window.clearTimeout(callerHandle.id)\n            callerHandle.remaining -= now - callerHandle.start\n        }\n    }\n\n    /**\n     * Pause all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static pauseMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.pause(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Resumes the timeout using the previously set value \"remaining\", \"start\" value is set to now() for\n     * future pause/resume.\n     * @param {string} caller Caller id of resume\n     */\n    public static resume(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            const now = this.dateProvider()()\n            callerHandle.start = now\n            const id = window.setTimeout(this.onDone.bind(this, caller, callerHandle.callbacks), callerHandle.remaining * 1000)\n            callerHandle.id = id\n        }\n    }\n\n    /**\n     * Resume all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static resumeMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.resume(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Clears all timeouts for a caller id.\n     * @param {string} caller Caller id of clearTimeout\n     */\n    public static clearTimeout(caller: string) {\n        if (this._map[caller]) {\n            window.clearTimeout(this._map[caller].id)\n            delete this._map[caller]\n        }\n    }\n\n    /**\n     * Clear all timers with a caller id matching regexp\n     * @param regex Regular expression to match.\n     */\n    public static clearMatching(regex: RegExp) {\n        Object.keys(this._map).forEach((key) => {\n            const match = key.match(regex)\n            if (match) {\n                match.forEach((val) => {\n                    if (val === key) {\n                        Timer.clearTimeout(val)\n                    }\n                })\n            }\n        })\n    }\n\n    /**\n     * Check if a timeout exists for an id.\n     * @param caller Id of timeout to check.\n     * @return {boolean} True if timeout exists.\n     */\n    public static hasTimeout(caller: string): boolean {\n        const has = exists(this._map[caller])\n        return has\n    }\n    /**\n     * Wrapper for Date\n     * @returns {number} Date.now Return current time\n     */\n    public static dateProvider = () => () => Date.now() / 1000\n\n    /**\n     * In this function all the collected callbacks are dispatched once the last sound of the caller has finished\n     * @param {caller} caller Caller id of onDone\n     */\n    private static onDone(caller: string) {\n        if (this._map[caller]) {\n            const callerHandle = this._map[caller]\n            delete this._map[caller]\n            callerHandle.callbacks.forEach((val: ITimerCallback) => {\n                val.callback.call(val.args)\n            })\n            window.clearTimeout(callerHandle.id)\n        }\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { exists } from \"@netent-tech/ecas-utils\"\nimport { ISoundContext } from \"@netent-tech/ecas-common\"\nimport EventHandler, { EcasEvents } from \"../event-handler\"\nimport { Timer } from \"../scheduling/Timer\"\n\nexport function getAudioBufferSourceNode(bufferData: AudioBuffer, audioContext: AudioContext, soundContext: ISoundContext) {\n    const source = exists(soundContext.soundSource.source)\n        ? soundContext.soundSource.source as AudioBufferSourceNode // Todo: fix these types so they dont intermingle\n        : audioContext.createBufferSource()\n    source.buffer = bufferData\n    source.loop = soundContext.isLoop\n    return source\n}\n\nexport function playBufferSource(source: AudioBufferSourceNode, duration: number, startTimeSeconds: number, context: ISoundContext, id: string, eventHandler: EventHandler, audioContext: AudioContext) {\n    try {\n        const pos = Math.max(context.currentTime * context.playbackRate, 0)\n\n        if (duration > 0) {\n            // used to add fade to time of duration here before but we considered fade should not add to duration but start before endtime instead\n            Timer.setTimeout(\n                () => eventHandler.triggerAudioEvent(EcasEvents.Sound.PlaybackStart, id),\n                startTimeSeconds - audioContext.currentTime\n            )\n            source.start(startTimeSeconds, pos, duration)\n        }\n        else {\n            if (duration < 0) {\n                logger().warn(\"[ecas] duration cannot be negative. was \" + duration + \" when playing sound '\" + id + \"'.\")\n            }\n            Timer.setTimeout(\n                () => eventHandler.triggerAudioEvent(EcasEvents.Sound.PlaybackStart, id),\n                startTimeSeconds - audioContext.currentTime\n            )\n            source.start(startTimeSeconds, pos)\n        }\n        source.onended = context.onSourceNodeEnded\n        source.playbackRate.value = context.playbackRate\n    }\n    catch (err) {\n        logger().error(err)\n    }\n}\n", "export const idGen = {\n    nextId: 0,\n    next() {\n        return idGen.nextId++\n    }\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { isNumeric } from '@netent-tech/ecas-utils'\n\nexport interface ITypeNamed<T extends string> {\n  typename: T\n}\n\nexport function getWetMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix >= 0.5) {\n    return 1\n  }\n  return 1 - ((0.5 - mix) * 2)\n}\n\nexport function getDryMixValue (mix: number): number {\n  if (!isNumeric(mix) || mix > 1 || mix < 0) {\n    return 0\n  }\n  if (mix <= 0.5) {\n    return 1\n  }\n  return 1 - ((mix - 0.5) * 2)\n}\n\nexport function lastElement<T> (arr: T[]): T | undefined {\n  return arr.at(-1)\n}\n\nexport class InsertHandlerError extends Error {\n  override name = 'InsertHandlerError'\n}\n\nexport const FILTER_TYPES: readonly BiquadFilterType[] = ['lowpass', 'highpass', 'bandpass', 'lowshelf', 'highshelf', 'peaking', 'notch', 'allpass'] as const\n\nexport interface SoundHandler {\n  dispose: () => void\n  details: Map<string, any>\n  getSound: (id: string) => any\n  getDurationSeconds: (id: string) => number\n  getAudioBuffer: (id: string) => Promise<AudioBuffer>\n  getAudioBufferSync: (id: string) => AudioBuffer\n  getAudioBufferReversed: (id: string) => Promise<AudioBuffer>\n  // eslint-disable-next-line\n    load: (ids: string[]) => Promise<void[]>\n  loadAll: () => Promise<void>\n  getAllSoundIds: () => string[]\n  isLoaded: (id: string) => boolean\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "import { noop } from '@netent-tech/ecas-utils/noop'\nimport { type LooseAutoComplete } from '@netent-tech/ecas-utils/types'\n\nexport type LoggerName = 'none' | 'console' | 'timestamp'\n\nexport interface EcasLogger {\n  typename?: LooseAutoComplete<LoggerName | 'custom'>\n  debug: typeof console.debug\n  log: typeof console.log\n  info: typeof console.info\n  warn: typeof console.warn\n  error: typeof console.error\n  table: typeof console.table\n  trace: typeof console.trace\n}\n\nlet instance: EcasLogger = {\n  typename: 'none',\n  debug: noop,\n  log: noop,\n  info: noop,\n  warn: noop,\n  error: noop,\n  table: noop,\n  trace: noop\n}\n\nexport const logger = getLogger\n\nfunction getLogger (): EcasLogger {\n  return instance\n}\n\nexport function setLogger (logger: EcasLogger): void {\n  instance = logger\n}\n\nfunction resetLogger (): void {\n  instance = getNoopLogger()\n}\n\nexport function loadFromName (name: LoggerName): void {\n  instance = getPredefinedLogger(name)\n}\n\nfunction getPredefinedLogger (name: LoggerName): EcasLogger {\n  switch (name) {\n    case 'console':\n      return getConsoleLogger()\n    case 'timestamp':\n      return getTimestampLogger()\n    case 'none':\n    default:\n      return getNoopLogger()\n  }\n}\n\nexport function loadUsingSearchParam (): void {\n  loadFromName(getNameFromSearchParam() ?? 'none')\n}\n\nfunction getNameFromSearchParam (): LoggerName | null {\n  const searchParams = new URLSearchParams(window.location.search)\n  const name = getName(searchParams)\n  return isLoggerName(name) ? name : null\n}\n\nfunction getName (searchParams: URLSearchParams): string | null {\n  return searchParams.get('ecas-logger') ?? searchParams.get('ecasLogger')\n}\n\nfunction isLoggerName (name: unknown): name is LoggerName {\n  return name === 'none' || name === 'console' || name === 'timestamp'\n}\n\nexport function isSearchParamUsed (): boolean {\n  return isLoggerName(getNameFromSearchParam())\n}\n\nfunction getConsoleLogger (): EcasLogger {\n  return {\n    typename: 'console',\n    ...console\n  }\n}\n\nfunction getTimestampLogger (): EcasLogger {\n  return new class {\n    typename = 'timestamp'\n    start = performance.now()\n    now = (): number => performance.now() - this.start\n    seconds = (): number => this.now() / 1000\n    format = (...args: any[]): any[] => [`Time: ${this.seconds().toFixed(2)}`, ...args]\n\n    /* eslint-disable no-console */\n    debug = (...args: any[]): void => { console.debug(...this.format(...args)) }\n    log = (...args: any[]): void => { console.log(...this.format(...args)) }\n    info = (...args: any[]): void => { console.log(...this.format(...args)) }\n    warn = (...args: any[]): void => { console.warn(...this.format(...args)) }\n    error = (...args: any[]): void => { console.error(...this.format(...args)) }\n    table = (...args: any[]): void => { console.table(...this.format(...args)) }\n    trace = (...args: any[]): void => { console.trace(...this.format(...args)) }\n    /* eslint-enable no-console */\n  }()\n}\n\nfunction getNoopLogger (): EcasLogger {\n  return {\n    typename: 'none',\n    debug: noop,\n    log: noop,\n    info: noop,\n    warn: noop,\n    error: noop,\n    table: noop,\n    trace: noop\n  }\n}\n\nexport const test = {\n  getPredefinedLogger,\n  getTimestampLogger,\n  getNoopLogger,\n  resetLogger,\n  setLogger,\n  isLoggerName,\n  getNameFromSearchParam,\n  getName,\n  getLogger,\n  getConsoleLogger\n} as const\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "\n/** start https://fettblog.eu/typescript-better-object-keys/ Improving Typescript built-in definitions for Object.keys() */\n\n/**\n * Returns the names of the enumerable string properties and methods of an object\n */\nexport const keys = Object.keys as <T>(o: T) => Array<Extract<keyof T, string>>\n\n/**\n * Creates an object that has the specified prototype or that has null prototype\n */\nexport const create = Object.create as <T>(o: T) => T\n\n/**\n * Returns an array of key/values of the enumerable properties of an object\n */\nexport const entries = Object.entries as <T, K extends keyof T>(o: T) => Array<[K, T[K]]>\n\n/**\n * Determines whether an object has a property with the specified name\n */\nexport function hasOwnProperty<X, Y extends string> (obj: X, prop: Y): obj is X & Record<Y, unknown> {\n  return Object.prototype.hasOwnProperty.call(obj, prop)\n}\n\n/**\n * Adds a property to an object, or modifies attributes of an existing property\n * @param o Object on which to add or modify the property. This can be a native JavaScript object (that is, a user-defined object or a built in object) or a DOM object\n * @param p The property name\n * @param attributes Descriptor for the property. It can be for a data property or an accessor property\n */\nexport function defineProperty<O extends object, P extends string, A extends PropertyDescriptor & ThisType<O>> (o: O, p: P, attributes: A): asserts o is ObjectWithNewProperty<O, P, A['value']> {\n  Object.defineProperty(o, p, attributes) as ObjectWithNewProperty<O, P, A['value']>\n}\n\n/**\n * Returns the prototype of an object\n */\nexport function getPrototypeOf<O extends { prototype: P }, P> (o: O): O['prototype'] {\n  return Object.getPrototypeOf(o) as O['prototype']\n}\n\n/**\n * Gets the own property descriptor of the specified object. An own property descriptor is one that is defined directly on the object and is not inherited from the object's prototype\n */\nexport function getOwnPropertyDescriptor<O extends object, P extends keyof O> (o: O, p: P): PropertyDescriptor {\n  return Object.getOwnPropertyDescriptor(o, p) as PropertyDescriptor\n}\n\n/**\n * Returns the names of the own properties of an object. The own properties of an object are those that are defined directly on that object, and are not inherited from the object's prototype. The properties of an object include both fields (objects) and functions\n */\nexport function getOwnPropertyNames<O extends object> (o: O): Array<Extract<keyof O, string>> {\n  return Object.getOwnPropertyNames(o) as Array<Extract<keyof O, string>>\n}\n\ntype ObjectWithNewProperty<O extends object, P extends string, V> = O & { [K in P]: V }\n", "import { hasOwnProperty } from '../object/object'\n\n/**\n * Detect the Safari browser.\n *\n * @return True if its a Safari\n */\nexport function isSafari (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Safari') &&\n        !userAgent.includes('Chrome')\n}\n\n/**\n * Detect the Firefox browser.\n *\n * @return True if its a Firefox\n */\nexport function isFirefox (userAgent: string = navigator.userAgent): boolean {\n  return userAgent.includes('Firefox')\n}\n\n/**\n * Detect the IOS devices.\n *\n * @return True if its a Firefox\n */\nexport function isIOS (userAgent = navigator.userAgent, global: object & { MSStream?: string } = window): boolean {\n  return /iPad|iPhone|iPod/.test(userAgent) && !hasOwnProperty(global, 'MSStream')\n}\n", "/**\n * Returns the larger of two numbers\n */\nexport function max (input: number, max: number): number {\n  return Math.max(input, max)\n}\n\n/**\n * Returns the smaller of two numbers\n */\nexport function min (input: number, min: number): number {\n  return Math.min(input, min)\n}\n\n/**\n * Clamps input to max or min if outside the range\n */\nexport function clamp (input: number, min: number, max: number): number {\n  return Math.min(Math.max(input, min), max)\n}\n\n/**\n * Clamps to 0 if input is less than 0 and 1 if input is greater than 1\n */\nexport function clampZeroToOne (input: number): number {\n  return clamp(input, 0, 1)\n}\n", "import { keys } from '../object/object'\nimport { type Newable } from '../types/types'\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\ntype NonExistant = null | undefined\n\nexport class AssertionError extends Error {\n  override name = 'AssertionError'\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Throws an error if condition is false with optional error constructor and message\n */\nexport function Assert<T extends Newable<Error>> (condition: boolean, opt?: { Err?: T, msg?: string } | string): asserts condition is true {\n  if (!condition) {\n    if (isString(opt)) {\n      throw new AssertionError(opt)\n    }\n    if (opt?.Err !== undefined) {\n      throw new opt.Err(opt.msg)\n    }\n    throw new AssertionError(opt?.msg)\n  }\n}\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function AssertIsString (thing: unknown, message?: string): asserts thing is string {\n  Assert(isString(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is not typeof number\n */\nexport function AssertIsNumber (thing: unknown, message?: string): asserts thing is number {\n  Assert(isNumber(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof number.` })\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function AssertIsObject (thing: unknown, message?: string): asserts thing is object {\n  Assert(isObject(thing), { msg: message ?? `thing typeof ${typeof thing} is not typeof object.` })\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function AssertIsFunction (thing: unknown, message?: string): asserts thing is () => unknown {\n  Assert(isFunction(thing), { msg: message ?? `[${typeof thing}] is not a string` })\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function AssertIsDefined<T> (thing: T | undefined, message?: string): asserts thing is T {\n  Assert(isDefined(thing), { msg: message ?? 'thing is undefined' })\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function AssertIsNotNull<T> (thing: T | null, message?: string): asserts thing is T {\n  Assert(!isNull(thing), { msg: message ?? 'thing is null' })\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function AssertExists<T> (thing: T | NonExistant, message?: string): asserts thing is T {\n  AssertIsDefined(thing, message)\n  AssertIsNotNull(thing, message)\n}\n\n/**\n * Throws an error if given object is empty\n */\nexport function AssertObjectNotEmpty (thing: object, message?: string): void | never {\n  Assert(!isObjectEmpty(thing), { msg: message ?? 'thing is empty.' })\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/**\n * Throws an error if given variable is not typeof string\n */\nexport function IsString (thing: unknown, message?: string): string | never {\n  AssertIsString(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof function\n */\nexport function IsFunction (thing: unknown, message?: string): CallableFunction | never {\n  AssertIsFunction(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined\n */\nexport function IsDefined<T> (thing: T | undefined, message?: string): T | never {\n  AssertIsDefined(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is null\n */\nexport function IsNotNull<T> (thing: T | null, message?: string): T | never {\n  AssertIsNotNull(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is not typeof object\n */\nexport function IsObject (thing: unknown, message?: string): object | never {\n  AssertIsObject(thing, message)\n  return thing\n}\n\n/**\n * Throws an error if given variable is undefined or null\n */\nexport function Exists<T> (thing: T | NonExistant, message?: string): T | never {\n  AssertExists(thing, message)\n  return thing\n}\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n/**\n * Returns true if given variable is not undefined\n */\nexport function isDefined<T> (thing: T | undefined): thing is T {\n  return !isUndefined(thing)\n}\n\n/**\n * Returns true if given variable is undefined\n */\nexport function isUndefined (thing: unknown): thing is undefined {\n  return thing === undefined\n}\n\n/**\n * Returns true if given object is empty\n */\nexport function isObjectEmpty (thing: object): boolean {\n  return Object.keys(thing).length === 0\n}\n\n/**\n * Returns true if given variable is not null\n */\nexport function isNotNull<T> (thing: T | null): thing is T {\n  return !isNull(thing)\n}\n\n/**\n * Returns true if given variable is not undefined and not null\n */\nexport function exists<T> (thing: T | NonExistant): thing is T {\n  return isDefined(thing) && isNotNull(thing)\n}\n\n/**\n * Returns true if given variable is null\n */\nexport function isNull (thing: unknown): thing is null {\n  return thing === null\n}\n\n/**\n * Returns true if given variable is typeof object\n */\nexport function isObject (thing: unknown): thing is object {\n  return typeof thing === 'object' && !isNull(thing) // null is considered\n}\n\n/**\n * Returns true if given variable is an array\n */\nexport function isArray (thing: unknown): thing is unknown[] | readonly unknown[] {\n  return Array.isArray(thing)\n}\n\n/**\n * Returns true if given condition is true\n */\nexport function isTrue (thing: unknown): thing is true {\n  return thing === true\n}\n\n/**\n * Returns true if given condition is false\n */\nexport function isFalse (thing: unknown): thing is false {\n  return thing === false\n}\n\n/**\n * Returns true if given array is empty\n */\nexport function isArrayEmpty<T> (arr: T[]): boolean {\n  return arr.length === 0\n}\n\n/**\n * Returns true if given array is non empty\n */\nexport function isArrayNonEmpty<T> (arr: T[]): boolean {\n  return !isArrayEmpty(arr)\n}\n\nexport type ArrayOfMinLengthOne<T> = [T, ...T[]]\n/**\n * Returns true if given variable is a non empty array\n */\nexport function isNonEmptyArray<T> (thing: unknown): thing is ArrayOfMinLengthOne<T> | Readonly<ArrayOfMinLengthOne<T>> {\n  return Array.isArray(thing) && thing.length > 0\n}\n\n/**\n * Returns true if given variable is typeof number and not NaN\n */\nexport function isNumber (thing: unknown): thing is number {\n  return typeof thing === 'number' && !isNaN(thing)\n}\n\n/**\n * Returns true if given variable is typeof function\n */\nexport function isFunction (thing: unknown): thing is typeof Function {\n  return typeof thing === 'function'\n}\n\n/**\n * Returns true if given variable is typeof string\n */\nexport function isString (thing: unknown): thing is string {\n  return typeof thing === 'string'\n}\n\n/**\n * Returns true if given object has key\n */\nexport function isKeyof<T> (key: unknown, thing: T): key is keyof T {\n  return keys(thing).includes(key as Extract<keyof T, string>)\n}\n\n/**\n * Check if a value is a numeric, ie. can be interpreted as a number including numeric strings.\n *\n * @param {unknown} thing Value to check.\n * @returns {boolean} True if value is numeric.\n */\nexport function isNumeric (thing: unknown): thing is number | `${number}` {\n  if (isNumber(thing)) {\n    return true\n  }\n  if (isString(thing)) {\n    return isStringNumber(thing)\n  }\n  return false\n}\n\nexport function isStringNumber (thing: string): thing is `${number}` {\n  return !isNaN(parseFloat(thing))\n}\n\n/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */\n", "import { defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames } from '../object/object'\nimport { isArray, isObject } from '../type-check/type-check'\n\nfunction cloneDeep (source: unknown): unknown {\n  if (isArray(source)) {\n    return source.map(item => cloneDeep(item))\n  } else if (source instanceof Date) {\n    return new Date(source.getTime())\n  } else if (isObject(source)) {\n    return getOwnPropertyNames(source).reduce((obj, prop) => {\n      const descriptor = getOwnPropertyDescriptor(source, prop)\n      defineProperty(obj, prop, descriptor)\n      obj[prop] = cloneDeep((source as Record<string, any>)[prop])\n      return obj\n    }, Object.create(Object.getPrototypeOf(source)))\n  }\n  return source\n}\n\n/**\n * Returns a deep clone of source\n */\nexport function clone<T> (source: T): T {\n  return cloneDeep(source) as T\n}\n", "/**\n * Returns the values of each key\n */\nexport function enumValues <O extends object, K extends keyof O = keyof O> (obj: O): Array<O[K]> {\n  return Object.values(obj)\n}\n", "/**\n * Use to ignore warning about unused variable or function or if import has wanted side effects\n */\nexport function ignoreUnused (...things: unknown[]): unknown[] {\n  return things\n}\n", "/**\n * Returns a string with arguments joined together with \"/\"\n * I the argument contains \"://\" (e.g an absolute url). \"://\" will be retained.\n * Any other \"//\" or \"///\" etc will be converted to \"/\".\n * @param arg0 - The first string to join.\n * @param rest - The rest of the strings to join together.\n * @returns The joined string.\n * @example\n * joinUrl('test', 'url', 'string') // 'test/url/string'\n * joinUrl('https://cit1.egcdn.com/', 'audio', 'desktop', 'song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n * joinUrl('https://cit1.egcdn.com/', '/audio/', '/desktop', '/song.webm') // 'https://cit1.egcdn.com/audio/desktop/song.webm'\n */\nexport function joinUrl (arg0: string, ...rest: string[]): string {\n  // since safari doesn't support lookbehind we can't use regex for this\n  // we don't need to do anything if there are only one argument...\n  if (rest.length === 0) return arg0\n\n  // get the first argument and remove the trailing slash if it exists\n  const first = arg0.endsWith('/') ? arg0.slice(0, -1) : arg0\n\n  return first.startsWith('http')\n    // if the first argument is an absolute url, we retain the \"://\" and remove any other slashes, then join the rest of the arguments with one slash\n    ? [first, rest.map((item) => item.replace(/\\/+/g, '')).join('/')].join('/')\n    // otherwise we just join the arguments with one slash and replace any duplicate slashes with one slash\n    : [first, ...rest].join('/').replace(/\\/+/g, '/')\n}\n", "\n/**\n * Converts to linear from decibel\n */\nexport function linearFromDecibel (decibels: number): number {\n  return decibelsToLinear(decibels)\n}\n\n/**\n * Converts to decibel from linear\n */\nexport function decibelFromLinear (linear: number): number {\n  return linearToDecibels(linear)\n}\n\n/**\n * Converts from decibel to linear\n */\nexport function decibelsToLinear (decibels: number): number {\n  return Math.pow(10, 0.05 * decibels)\n}\n\n/**\n * Converts from linear to decibel\n */\nexport function linearToDecibels (linear: number): number {\n  // It's not possible to calculate decibels for a zero linear value since it would be -Inf.\n  // -1000.0 dB represents a very tiny linear value in case we ever reach this case.\n  if (linear === 0) {\n    return -1000\n  }\n\n  return 20 * Math.log10(linear)\n}\n\n/**\n * Returns sum of all arguments.\n * Works when adding undefined, null etc also\n */\nexport function add (...args: unknown[]): number {\n  let total = Number(0)\n  for (const arg of args) {\n    const val = Number(arg)\n    if (Number.isFinite(val)) {\n      total += val\n    }\n  }\n  return total\n}\n\n/**\n * Subtracts y from x.\n * Works when subtracting undefined, null etc also\n */\nexport function subtract (x: unknown, y: unknown): number {\n  let result = 0\n  const xn = Number(x)\n  const yn = Number(y)\n  if (Number.isFinite(xn)) {\n    result = xn\n  }\n  if (Number.isFinite(yn)) {\n    result -= yn\n  }\n  return result\n}\n", "/**\n * Default function that returns void/undefined\n */\nexport function noop (): void {\n  return undefined\n}\n", "export class StrictMapError extends Error {\n  override name = 'StrictMapError'\n}\n\n/** The strict map will throw an error if you try to get a nonexisting key */\nexport class StrictMap<Key extends string, Value> {\n  #map = new Map<Key, Value>()\n\n  get (key: Key): NonNullable<Value> {\n    if (!this.#map.has(key)) {\n      throw new StrictMapError(`Key: '${key}' does not exist.`)\n    }\n    // we just checked that the key exists\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.#map.get(key)!\n  }\n\n  set (key: Key, value: Value): this {\n    this.#map.set(key, value)\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'StrictMap'\n  readonly [Symbol.iterator]: IterableIterator<[Key, Value]> = this.#map.entries()\n\n  forEach (callbackfn: (value: Value, key: Key, map: Map<Key, Value>) => void, thisArg?: any): void {\n    this.#map.forEach(callbackfn, thisArg)\n  }\n\n  clear (): void {\n    this.#map.clear()\n  }\n\n  delete (key: Key): boolean {\n    return this.#map.delete(key)\n  }\n\n  entries (): IterableIterator<[Key, Value]> {\n    return this.#map.entries()\n  }\n\n  has (key: Key): boolean {\n    return this.#map.has(key)\n  }\n\n  keys (): IterableIterator<Key> {\n    return this.#map.keys()\n  }\n\n  size (): number {\n    return this.#map.size\n  }\n\n  values (): IterableIterator<Value> {\n    return this.#map.values()\n  }\n}\n", "export type FunctionAny = (...args: any[]) => any\nexport type FunctionSyncLike <T extends FunctionAny> = (...args: Parameters<T>) => ReturnType<T> extends Promise<any> ? never : ReturnType<T>\nexport type FunctionAsyncLike <T extends FunctionAny> = (...args: Parameters<T>) => Promise<ReturnType<T> extends Promise<any> ? Awaited<ReturnType<T>> : never>\n\ntype TryitReturnSync<F extends FunctionSyncLike<F>, E> = [E, null] | [null, ReturnType<F>]\ntype TryitReturnAsync<F extends FunctionAsyncLike<F>, E> = Promise<[E, null] | [null, Awaited<ReturnType<F>>]>\n\nexport function tryAsync <F extends FunctionAsyncLike<F>, E extends Error> (func: F) {\n  return async (...args: Parameters<F>): TryitReturnAsync<F, E> => {\n    try {\n      return [null, await func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n\nexport function trySync <F extends FunctionSyncLike<F>, E extends Error> (func: F) {\n  return (...args: Parameters<F>): TryitReturnSync<F, E> => {\n    try {\n      return [null, func(...args)]\n    } catch (err) {\n      return [err as E, null]\n    }\n  }\n}\n", "/* * * * * * * Utility Types * * * * * * * * * * * * */\n\n/** Makes it possible to get autocomplete for specified strings but still allow all strings to be used */\nexport type LooseAutoComplete<T extends string> = T | Omit<string, T>\n\nexport type DeepReadonly<T> =\n    T extends Array<infer R> ? DeepReadonlyArray<R> :\n      T extends (...args: any) => any ? T :\n        T extends object ? DeepReadonlyObject<T> :\n          T\n\nexport type DeepReadonlyArray<T> = ReadonlyArray<DeepReadonly<T>>\n\nexport type DeepReadonlyObject<T> = {\n  readonly [P in keyof T]: DeepReadonly<T[P]>;\n}\n\nexport type Writeable<T> = { -readonly [P in keyof T]: T[P] }\nexport type DeepWriteable<T> = { -readonly [P in keyof T]: DeepWriteable<T[P]> }\n\nexport type Properties<T> = { [K in keyof T]: T[K] }\nexport type PartialProperties<T> = Partial<Properties<T>>\n\nexport type DeepPartial<T> = T extends object ? {\n  [P in keyof T]?: DeepPartial<T[P]>;\n} : T\n\nexport type DeepPartialProperties<T> = DeepPartial<Properties<T>>\n\nexport type Newable<T> = new (...args: any[]) => T // Make it possible to pass a class into a function\n\nexport type KeyofType = string | number | symbol\n\nexport function asWriteable<T> (thing: Readonly<T>): T {\n  return thing as T\n}\n\nexport function asDeepWriteable<T> (thing: DeepReadonly<T>): T {\n  return thing as T\n}\n\nexport type Values<T> = T[keyof T]\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isFirefox, StrictMap, trySync } from '@netent-tech/ecas-utils'\n\ninterface AutomateOptions<T extends string> {\n  /** Id of the parameter to modify, for example: pan, pitch, gain */\n  paramId: T\n  /** A value curve that will be applied to the AudioParam */\n  valueCurve: number[] | Float32Array\n  /** When the curve should start in consideration to AudioContext timer */\n  when: number\n  /** How long it should take to reach the last value */\n  duration: number\n}\n\nexport type AutomatableParameters<T> = T extends Automatable<infer U> ? U extends readonly string[] ? U : never : never\n\nexport interface Automatable<T extends readonly string[]> {\n  automator: Automator<T>\n}\n\nexport class AutomatorError extends Error {\n  override name = 'AutomatorError'\n}\n\nexport class Automator<T extends readonly string[]> {\n  readonly AutomatableParameters: T\n  constructor (automatableParameters: T) {\n    this.AutomatableParameters = automatableParameters\n  }\n\n  /** Stores a reference to the id and audio parameter that can be automated */\n  private readonly audioParams = new StrictMap<T[number], AudioParam>()\n\n  /** Stores a reference of the default value for said parameter */\n  private readonly defaults = new StrictMap<T[number], number>()\n\n  /** Stores a reference of timeouts for envelopes that has needed timeouts using linearRamps instead of using valueCurve */\n  private readonly firefoxHacks = new Map<T[number], number[]>()\n\n  automate ({ paramId, valueCurve, when, duration }: AutomateOptions<T[number]>): void {\n    logger().debug('[ecas] automate', { paramId, valueCurve, when, duration })\n\n    const audioParam: AudioParam = this.audioParams.get(paramId)\n\n    // cancel immediatly cause we still get issues sometimes when overriding envelopes otherwise :(\n    audioParam.cancelAndHoldAtTime(0)\n\n    const usingFirefox: boolean = isFirefox()\n    if (usingFirefox) {\n      this.firefoxHack({ paramId, valueCurve, when, duration, audioParam })\n      return\n    }\n\n    const [curveError] = trySync(() => audioParam.setValueCurveAtTime(valueCurve, when, duration))()\n\n    if (curveError === null) {\n      return\n    }\n\n    // firefox will throw error if we try to create new value curve before previous has finished even though we've canceled values\n    // this is here for if we get the same error with any other browsers that we don't know about yet\n    // ignoring the curve and doing a linear ramp instead so at least we move towards the set end value..\n    logger().log('[ecas]: failed to override scheduled valueCurve. Using a linear ramp to the end value instead.', curveError)\n    audioParam.cancelAndHoldAtTime(0)\n\n    const lastValue = valueCurve.at(-1)\n\n    if (lastValue !== undefined) {\n      const [rampError] = trySync(() => audioParam.linearRampToValueAtTime(lastValue, when + duration))()\n\n      if (rampError !== null) {\n        logger().log('[ecas]: failed to schedule linearRampToValueAtTime that was used as a fallback when the valueCurve failed.', rampError)\n      }\n    }\n  }\n\n  private firefoxHack ({ paramId, audioParam, valueCurve, when, duration }: AutomateOptions<T[number]> & { audioParam: AudioParam }): void {\n    // clear all scheduled values\n    const timeoutIDs = this.firefoxHacks.get(paramId) ?? []\n    const newTimeoutIds: number[] = []\n    const numValues = valueCurve.length\n    const durationPerValue = duration / numValues\n\n    for (const id of timeoutIDs) {\n      window.clearTimeout(id)\n    }\n\n    this.firefoxHacks.set(paramId, newTimeoutIds)\n\n    for (const [i, value] of valueCurve.entries()) {\n      const valueTime = i * durationPerValue\n      const ms = valueTime * 1000\n\n      // we need to use the Timer here if we want to be able to pause / resume\n      newTimeoutIds.push(window.setTimeout(() => {\n        audioParam.cancelAndHoldAtTime(0)\n\n        const [error] = trySync(() => audioParam.linearRampToValueAtTime(value, when + valueTime - 0.3))()\n\n        if (error !== null) {\n          logger().log('[ecas]: (automator) failed to set linearRamp', error)\n        }\n      }, ms))\n    }\n  }\n\n  add (paramId: T[number], audioParam: AudioParam, defaultValue?: number): void {\n    const audioparamHasId: boolean = this.audioParams.has(paramId)\n    if (audioparamHasId) {\n      throw new AutomatorError(`AudioParam with id ${paramId as string} has already been added.`) as Error\n    }\n\n    this.set(paramId, audioParam)\n\n    if ((defaultValue !== null && defaultValue !== undefined)) {\n      this.setDefault(paramId, defaultValue)\n    } else {\n      this.setDefault(paramId, audioParam.value)\n    }\n  }\n\n  /** Cancel any planned values */\n  cancel ({ paramId, when }: { paramId: T[number], when: number }): void {\n    const audioParam = this.audioParams.get(paramId)\n    audioParam.cancelScheduledValues(when)\n  }\n\n  get (param: T[number]): AudioParam {\n    return this.audioParams.get(param)\n  }\n\n  /** replace the reference to a parameter */\n  set (paramId: T[number], audioParam: AudioParam): void {\n    this.audioParams.set(paramId, audioParam)\n  }\n\n  /** Get the current value of the parameter */\n  current (param: T[number]): number {\n    return this.audioParams.get(param).value\n  }\n\n  /** get the default value of said parameter */\n  getDefault (param: T[number]): number {\n    return this.defaults.get(param)\n  }\n\n  setDefault (param: T[number], value: number): void {\n    this.defaults.set(param, value)\n  }\n\n  dispose (): void {\n    this.audioParams.clear()\n  }\n}\n", "/* Returns an array with no duplicate items */\nexport function unique <T> (array: readonly T[]): T[] {\n  return [...new Set(array)]\n}\n\n// Courtesy of the chrismilson, thank you chris. https://gist.github.com/chrismilson/e6549023bdca1fa9c263973b8f7a713b\nexport type Iterableify<T> = {\n  [K in keyof T]: Iterable<T[K]>\n}\n\n/**\n * Returns the sum of an array of numbers\n */\nexport function arraySum (arr: number[]): number {\n  let sum = 0\n  for (const v of arr) {\n    sum += v\n  }\n  return sum\n}\n\n/**\n * Mutates array by applying exponent to each element\n * @param arr Array to mutate\n * @param pow exponent (defaults to 2)\n * @return Mutated array\n */\nexport function arrayPowerMutate (arr: number[] | Float32Array, pow = 2): number[] | Float32Array {\n  for (let i = 0; i < arr.length; i++) {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    arr[i] = Math.pow(arr[i]!, pow)\n  }\n  return arr\n}\n\n/**\n * Returns an array where the num has been added to each element\n * @param arr Array to add to\n * @param num Number to add to each element\n * @returns New array with num added to each element\n */\nexport function arrayAdd (arr: number[], num: number): number[] {\n  return arr.map(val => val + num)\n}\n\n/**\n * Returns an array from 0 to max (not included)\n * @param max Lenght of the array\n */\nexport function range (max: number): number[] {\n  return [...Array(max).keys()]\n}\n\n/**\n * returns true if searchElement is in array\n * @param arr Array to search\n * @param searchElement Element to search for\n * @returns boolean\n */\nexport function includes<T extends readonly unknown[]> (arr: T, searchElement: unknown): boolean {\n  return Array.prototype.includes.call(arr, searchElement)\n}\n", "import { arraySum, range } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType, type IEnvelopePoint } from '../utils'\n/**\n * Convert an envelope to absolute time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToAbsolute (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let pos = 0\n\n  return envelope.map((point: IEnvelopePoint) => {\n    pos += Number(point.pos)\n    return {\n      pos,\n      val: point.val\n    }\n  })\n}\n\n/**\n * Convert an envelope to relative time positions.\n *\n * @param {IEnvelopePoint[]} envelope Envelope to convert.\n * @returns {IEnvelopePoint[]} Converted envelope.\n */\nexport function envelopePosToRelative (envelope: IEnvelopePoint[]): IEnvelopePoint[] {\n  let last = 0\n\n  return envelope.map((val: IEnvelopePoint) => {\n    const currPos = val.pos\n    const pos = currPos - last\n    last = currPos\n\n    return {\n      pos,\n      val: val.val\n    }\n  })\n}\n\n/**\n * Creating a curve to simulate a logarithmic curve with setValueCurveAtTime.\n *\n * @param {number} direction Direction positive for fade in, negative for fade out\n * @param {number} startVal Staring value of Audio param\n * @param {number} endVal Ending value of Audio param\n * @param {number} duration Duration of curve, in seconds\n */\nexport function createLogarithmicCurve (direction: -1 | 1, _startVal: number, _endVal: number, duration: number, sampleRate = 48000): Float32Array {\n  const base = 9 // what is base 9 supposed to do\n  const numSamples = Math.ceil(duration * sampleRate)\n  const curve = new Float32Array(numSamples)\n  const indexes = range(numSamples)\n\n  if (direction === -1) {\n    indexes.reverse()\n  }\n\n  for (const i of range(numSamples)) {\n    const x = base * i / numSamples + 1\n    const item = indexes[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      curve[item] = Math.log10(x)\n    }\n  }\n\n  return curve\n}\n\n/**\n* @returns logarithmically spaced vector ranging from first to last value\n*/\nexport function logspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const createSafeLogValue = (val: number): number => {\n    if (val > 0) {\n      return Math.log10(val)\n    }\n    return Math.log10(1e-5) // -100 dBFS\n  }\n  const firstLog10 = createSafeLogValue(first)\n  const lastLog10 = createSafeLogValue(last)\n\n  const increment = (lastLog10 - firstLog10) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n  let accumulated = firstLog10\n\n  vector[0] = first\n  for (let index = 1; index < numSamples - 1; index++) {\n    accumulated += increment\n    vector[index] = Math.pow(10, accumulated)\n  }\n  vector[numSamples - 1] = last\n\n  return vector\n}\n\n/**\n* @returns linearly spaced vector ranging from first to last value\n*/\nexport function linspace (first = 1, last = 10, numSamples = 10): Float32Array {\n  const increment = (last - first) / (numSamples - 1)\n  const vector = new Float32Array(numSamples)\n\n  let accumulated = first\n\n  for (let index = 0; index < numSamples; index++) {\n    vector[index] = accumulated\n    accumulated += increment\n  }\n  vector[0] = first\n  vector[vector.length - 1] = last\n  return vector\n}\n\n/**\n * Creating a curve to simulate a s-curve (sigmoid function)\n *\n */\nexport function sigspace (first = 1, last = 0, numSamples = 10): Float32Array {\n  const phaseStart = Math.PI / 2\n  const vector = new Float32Array(numSamples)\n\n  // create half of a sigmoid between 0-1\n  for (let i = 0; i < numSamples; i++) {\n    const phasei = Math.PI * i / (numSamples - 1)\n    const phasen = phasei - phaseStart\n    vector[i] = Math.sin(phasen) / 2 + 0.5\n  }\n\n  // scale the curve\n  const scale = last - first\n\n  for (let i = 0; i < numSamples; i++) {\n    const item = vector[i]\n\n    /* istanbul ignore else */\n    if (item !== undefined) {\n      vector[i] = item * scale + first\n    }\n  }\n  return vector\n}\n\nfunction createCurve (values: number[], numSamples: number[], curveCreator: (first: number, last: number, ns: number) => Float32Array): Float32Array {\n  const totalNumSamples = arraySum(numSamples)\n  const curve = new Float32Array(totalNumSamples)\n\n  let prevValue = values[0]\n  let start = 0\n\n  for (let i = 0; i < values.length; i++) {\n    const ns = numSamples[i]\n    const value = values[i]\n\n    /* istanbul ignore else */\n    if (prevValue !== undefined && ns !== undefined && value !== undefined) {\n      const slice = curveCreator(prevValue, value, ns)\n\n      curve.set(slice, start)\n      start += ns\n      prevValue = values[i]\n    }\n  }\n\n  return curve\n}\n\nfunction getCurveCreator (curveType: EnvelopeCurveType): ((first?: number, last?: number, numSamples?: number) => Float32Array) {\n  return {\n    linear: linspace,\n    exponential: logspace,\n    logarithmic: logspace,\n    's-curve': sigspace\n  }[curveType]\n}\n\nexport function createAutomationCurve (opt: {\n  values: number[]\n  positions: number[]\n  curveType: EnvelopeCurveType\n}): Float32Array {\n  const { values, positions, curveType } = opt\n  const numSamples = getNumSamples(positions)\n\n  const curveCreator = getCurveCreator(curveType)\n  const curve = createCurve(values, numSamples, curveCreator)\n  return curve\n}\n\nfunction getNumSamples (positions: number[]): number[] {\n  const numSamplesPerPoint = 1 / 4\n  return positions.map(pos => Math.floor(Math.max(pos * numSamplesPerPoint, 2)))\n}\n", "import { arraySum } from '@netent-tech/ecas-utils/array'\nimport { type EnvelopeCurveType } from '../utils'\nimport { createAutomationCurve } from './implementation'\n\nexport const CurveCreator = {\n  linear (points: [number[], number[]]): [Float32Array, number] {\n    return create('linear', points)\n  },\n  logarithmic (points: [number[], number[]]): [Float32Array, number] {\n    return create('logarithmic', points)\n  },\n  exponential (points: [number[], number[]]): [Float32Array, number] {\n    return create('exponential', points)\n  },\n  's-curve' (points: [number[], number[]]): [Float32Array, number] {\n    return create('s-curve', points)\n  }\n}\n\nfunction create (curveType: EnvelopeCurveType, [values, positions]: [number[], number[]]): [Float32Array, number] {\n  return [\n    createAutomationCurve({ curveType, values, positions }),\n    arraySum(positions) / 1000\n  ]\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface AlgorithmicReverbInsertOptions extends Identifiable { // implements ConvolverNode {\n  /**\n     * in seconds, min: 0.001, max: 10, default: 0.2\n     */\n  time?: number\n  /**\n     * in seconds,min: 0.001, max: 10, default: 0.2\n     */\n  decay?: number\n  /**\n     * how wet do you like it?, min: 0, max: 1, default: 1 (100%)\n     */\n  mix?: number\n  /**\n     * should we reverse time?\n     */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'AlgorithmicReverbInsert' as const\n/**\n * AlgorithmicReverb class is responsible to generate reverb nodes based on configuration given\n */\nexport class AlgorithmicReverbInsert implements InsertApi<AlgorithmicReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): AlgorithmicReverbInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options for algorithmic reverb\n     */\n  private readonly options: Required<AlgorithmicReverbInsertOptions>\n  /**\n     * Input node for algorithmic reverb\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node for algorithmic reverb\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node for algorithmic reverb\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node for algorithmic reverb\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Convolver node for algorithmic reverb\n     */\n  private reverbNode: ConvolverNode\n  /**\n     * Audio context for algorithmic reverb\n     */\n  private readonly audioContext: AudioContext\n\n  /**\n   * Creates an instance of algorithmic reverb.\n   * @param audioContext\n   * @param options\n   */\n  constructor (audioContext: AudioContext, options: AlgorithmicReverbInsertOptions = { id: TYPENAME }) {\n    this.options = {\n      id: options.id,\n      mix: 1,\n      time: 0.2,\n      decay: 0.2,\n      reverse: false\n    }\n\n    this.audioContext = audioContext\n\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.reverbNode = audioContext.createConvolver()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.dryGainNode)\n    this.dryGainNode.connect(this.outputGainNode)\n    this.inputGainNode.connect(this.reverbNode)\n    this.reverbNode.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.modify({ ...this.options, ...options }).catch(logger().error)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain, options.mix)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  async modify (options: PartialProperties<AlgorithmicReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let smoothingTimeSeconds = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      smoothingTimeSeconds = true\n    }\n\n    if (options.time !== undefined && this.options.time !== options.time) {\n      const MAX_TIME = 10 as const\n      // large impulses are costly\n      this.options.time = clamp(options.time, MIN, MAX_TIME)\n      smoothingTimeSeconds = true\n    }\n    // no need to rebuild if no change since previous update\n    if (options.decay !== undefined && this.options.decay !== options.decay) {\n      smoothingTimeSeconds = true\n      this.options.decay = Math.min(\n        Math.max(options.decay, MIN),\n        this.options.time\n      )\n    }\n\n    if (smoothingTimeSeconds) {\n      this.buildImpulse()\n    }\n  }\n\n  buildImpulse (): void {\n    const length = this.audioContext.sampleRate * this.options.time\n    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate)\n    const impulseL = impulse.getChannelData(0)\n    const impulseR = impulse.getChannelData(1)\n\n    let n: number\n    let i: number\n\n    for (i = 0; i < length; i++) {\n      n = this.options.reverse ? length - i : i\n      impulseL[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n      impulseR[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, this.options.decay)\n    }\n\n    if (this.reverbNode.buffer != null) {\n      this.inputGainNode.disconnect(this.reverbNode)\n      this.reverbNode.disconnect(this.wetGainNode)\n\n      this.reverbNode = this.audioContext.createConvolver()\n      this.inputGainNode.connect(this.reverbNode)\n      this.reverbNode.connect(this.wetGainNode)\n    }\n\n    this.reverbNode.buffer = impulse\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { FILTER_TYPES } from '../utils'\nimport { type InsertApi } from './types'\n\n/**\n * Uses BiquadFilterNode\n * see https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n **/\nexport interface BiquadFilterInsertOptions extends Identifiable, Omit<BiquadFilterOptions, keyof AudioNodeOptions> {\n  /**\n     * String value defining the kind of filtering algorithm the node is implementing. default to lowpass.\n     * Available is: 'lowpass' | 'highpass' | 'bandpass' | 'lowshelf' | 'highshelf' | 'peaking' | 'notch' | 'allpass'\n     * @Type FilterType\n     * @Default {\"lowpass\"}\n     **/\n  type?: BiquadFilterType\n\n  /**\n     * A-rate AudioParam, a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n     * Default value is 350.\n     *\n     * Meaning depends on filter type.\n     *  - lowpass / highpass: The cutoff frequency.\n     *  - bandpass: The center of the range of frequencies.\n     *  - lowshelf: The upper limit of the frequencies getting a boost or an attenuation.\n     *  - highshelf: The lower limit of the frequencies getting a boost or an attenuation\n     *  - peaking: The middle of the frequency range getting a boost or an attenuation.\n     *  - notch: The center of the range of frequencies.\n     *  - allpass: The frequency with the maximal group delay, that is, the frequency where the center of the phase transition occurs.\n     *\n     * @Type {number}\n     * @Default {350}\n     **/\n  frequency?: number\n\n  /**\n     * A-rate AudioParam representing detuning of the frequency in cents. default to 0\n     * @Type {number}\n     * @Default {0}\n     * */\n  detune?: number\n\n  /**\n     * A-rate AudioParam, a double representing a Quality factor which sets the sharpness of the filter.\n     * Defaults to 1. Nominal range: 0.0001 to 1000\n     *\n     * Meaning depends on filter type:\n     * - lowpass: Indicates how peaked the frequency is around the cutoff. The greater the value is, the greater is the peak.\n     * - highpass: Indicates how peaked the frequency is around the cutoff. The greater the value, the greater the peak.\n     * - bandpass: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - peaking: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - notch: Controls the width of the frequency band. The greater the Q value, the smaller the frequency band.\n     * - allpass: Controls how sharp the transition is at the medium frequency. The larger this parameter is, the sharper and larger the transition will be.\n     * - shelf: not used\n     *\n     * @Type {Number}\n     * @Default {1}\n     **/\n  Q?: number\n\n  /**\n     * A-rate AudioParam setting the gain of the filter.\n     * Only used on shelving and peaking types.\n     * It is expressed in dB, has a default value of 0 and can take a value in a nominal range of -40 to 40.\n     * @Type {Number}\n     * @Default {0}\n     */\n  gain?: number\n}\n\nexport default BiquadFilterInsertOptions\n\n/** Converted to not extend BiquadFilterNode cause doesn't work on old browsers */\nconst TYPENAME = 'BiquadFilterInsert' as const\nexport class BiquadFilterInsert implements InsertApi<BiquadFilterInsert> {\n  static typename = TYPENAME\n  typename = BiquadFilterInsert.typename\n  id: string = TYPENAME\n  automator = new Automator(['frequency', 'detune', 'Q', 'gain'] as const)\n\n  private readonly options: BiquadFilterInsertOptions\n\n  node: BiquadFilterNode\n\n  constructor (context: BaseAudioContext, options: BiquadFilterInsertOptions) {\n    // will set the parameters to any options provided so no need to run modify in constructor\n    this.node = context.createBiquadFilter()\n    this.id = options.id\n    // any options provided overrides default\n    this.options = Object.assign({\n      id: options.id,\n      detune: 0,\n      frequency: context.sampleRate / 2,\n      gain: 0,\n      Q: 1,\n      type: 'lowpass'\n    }, options)\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.Q.value = this.options.Q!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.detune.value = this.options.detune!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.frequency.value = this.options.frequency!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.gain.value = this.options.gain!\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.node.type = this.options.type!\n\n    this.automator.add('Q', this.node.Q)\n    this.automator.add('detune', this.node.detune)\n    this.automator.add('frequency', this.node.frequency)\n    this.automator.add('gain', this.node.gain)\n  }\n\n  get input (): BiquadFilterNode {\n    return this.node\n  }\n\n  get output (): BiquadFilterNode {\n    return this.node\n  }\n\n  get getOptions (): BiquadFilterInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the filter options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     */\n  async modify (\n    options: BiquadFilterInsertOptions,\n    endTimeSeconds: number,\n    sampleRate: number\n  ): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode/Q\n         *\n         * The Q property of the BiquadFilterNode interface is an a-rate AudioParam, a double representing a Q factor, or quality factor.\n         * It is a dimensionless value with a default value of 1 and a nominal range of 0.0001 to 1000.\n         */\n    if (typeof options.Q === 'number') {\n      const MIN_Q = 0.0001 as const\n      const MAX_Q = 1000 as const\n      this.options.Q = clamp(options.Q, MIN_Q, MAX_Q)\n      this.node.Q.cancelScheduledValues(0)\n      this.node.Q.linearRampToValueAtTime(this.options.Q, endTimeSeconds)\n    }\n\n    /**\n         * Detune is basically the same as using frequency\n         *\n         * https://developer.mozilla.org/en-US/docs/Web/API/AudioBufferSourceNode/detune\n         * https://webaudio.github.io/web-audio-api/dom-audiobuffersourcenode-detune\n         *\n         * The detune property of the BiquadFilterNode interface is an a-rate AudioParam representing detuning of the frequency in cents.\n         * For many AudioParams the minValue and maxValue is intended to be set to the maximum possible range.\n         * In this case, maxValue should be set to the most-positive-single-float value, which is 3.4028235e38.\n         * (However, in JavaScript which only supports IEEE-754 double precision float values,\n         * this must be written as 3.4028234663852886e38.)\n         * Similarly, minValue should be set to the most-negative-single-float value,\n         * which is the negative of the most-positive-single-float: -3.4028235e38.\n         * (Similarly, this must be written in JavaScript as -3.4028234663852886e38.)\n         */\n    if (typeof options.detune === 'number') {\n      const MOST_POSITIVE_SINGLE_FLOAT_VALUE = 3.4028234663852886e38 as const\n      const MOST_NEGATIVE_SINGLE_FLOAT_VALUE = -3.4028234663852886e38 as const\n      this.options.detune = clamp(\n        options.detune,\n        MOST_NEGATIVE_SINGLE_FLOAT_VALUE,\n        MOST_POSITIVE_SINGLE_FLOAT_VALUE\n      )\n      this.node.detune.cancelScheduledValues(0)\n      this.node.detune.linearRampToValueAtTime(\n        this.options.detune,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The frequency property of the BiquadFilterNode interface is an a-rate AudioParam\n         *  \u2014 a double representing a frequency in the current filtering algorithm measured in hertz (Hz).\n         * Its default value is 350, with a nominal range of 10 to the Nyquist frequency \u2014 that is, half of the sample rate.\n         */\n    if (typeof options.frequency === 'number') {\n      const minFrequency = 10 as const\n      const maxFrequency = sampleRate / 2\n      this.options.frequency = clamp(options.frequency, minFrequency, maxFrequency)\n      this.node.frequency.cancelScheduledValues(0)\n      this.node.frequency.exponentialRampToValueAtTime(\n        this.options.frequency,\n        endTimeSeconds\n      )\n    }\n\n    /**\n         * The gain property of the BiquadFilterNode interface is an a-rate AudioParam\n         *    \u2014 a double representing the gain used in the current filtering algorithm.\n         * When its value is positive, it represents a real gain; when negative, it represents an attenuation.\n         *  It is expressed in dB, has a default value of 0, and can take a value in a nominal range of -40 to 40.\n         */\n    if (typeof options.gain === 'number') {\n      const maxGainDecibel = 40 as const\n      const minGainDecibel = -40 as const\n      this.options.gain = clamp(\n        options.gain,\n        minGainDecibel,\n        maxGainDecibel\n      )\n      this.node.gain.cancelScheduledValues(0)\n      this.node.gain.linearRampToValueAtTime(\n        this.options.gain,\n        endTimeSeconds\n      )\n    }\n\n    if (options.type !== undefined && options.type !== null && FILTER_TYPES.includes(options.type)) {\n      this.node.type = this.options.type = options.type\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.node.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, Exists, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type SoundHandler } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface ConvolverReverbInsertOptions extends Identifiable { //, Omit<ConvolverOptions, keyof AudioNode> {\n  /** the id of the sound to use for impulse */\n  impulseResponse?: string\n  /** wetness 0 - 1, default 1 */\n  mix?: number\n  /** Should the impulse response file be normalized */\n  normalize?: boolean\n  /** Should the impulse be reversed.. */\n  reverse?: boolean\n}\n\nconst TYPENAME = 'ReverbConvolverInsert' as const\n/**\n * ReverbConvolver class is responsible to generate a reverb node based on configuration given\n */\nexport class ConvolverReverbInsert implements InsertApi<ConvolverReverbInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): ConvolverReverbInsertOptions {\n    return this.options\n  }\n\n  get audioParams (): { dryGain: AudioParam, wetGain: AudioParam } {\n    return { dryGain: this.dryGainNode.gain, wetGain: this.wetGainNode.gain }\n  }\n\n  private readonly soundHandler: SoundHandler // to fetch buffers for the impulses\n\n  /**\n     * Options of ConvolverNode\n     */\n  private readonly options: Required<ConvolverReverbInsertOptions> = {\n    id: TYPENAME,\n    normalize: false,\n    reverse: false,\n    impulseResponse: 'none', // updated in .modify\n    mix: 1\n  } as const\n\n  /**\n     * Input node of ConvolverNode\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ConvolverNode\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ConvolverNode\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ConvolverNode\n     */\n  private readonly wetGainNode: GainNode\n\n  /**\n     * convolver node of ConvolverNode\n     */\n  private readonly convolverNode: ConvolverNode\n\n  /**\n     * Creates an instance of Reverb Convolver node.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: ConvolverReverbInsertOptions, soundHandler: SoundHandler) {\n    this.soundHandler = soundHandler\n    this.inputGainNode = audioContext.createGain()\n    this.convolverNode = audioContext.createConvolver()\n    this.outputGainNode = audioContext.createGain()\n\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n\n    this.inputGainNode.connect(this.convolverNode)\n\n    this.convolverNode.connect(this.wetGainNode)\n    this.inputGainNode.connect(this.dryGainNode)\n\n    this.dryGainNode.connect(this.outputGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n\n    this.id = options.id\n    if (options.impulseResponse === undefined) {\n      logger().warn('[ecas] convolver reverb impulse file should be specified.')\n      return\n    }\n    this.modify(options).catch(logger().error)\n  }\n\n  async modify (options: PartialProperties<ConvolverReverbInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const MIN = 0.0001 as const\n\n    let shouldUpdateBuffer = false\n\n    if (options.id !== undefined) {\n      this.options.id = this.id = options.id\n    }\n    if (options.mix !== undefined) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(\n        clamp(1 - this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(\n        clamp(this.options.mix, MIN, MIX_MAX),\n        endTimeSeconds\n      )\n    }\n\n    if (options.normalize !== undefined && this.options.normalize !== options.normalize) {\n      this.options.normalize = options.normalize\n      this.convolverNode.normalize = this.options.normalize\n      shouldUpdateBuffer = true\n    }\n\n    if (options.reverse !== undefined && this.options.reverse !== options.reverse) {\n      this.options.reverse = options.reverse\n      shouldUpdateBuffer = true\n    }\n\n    // no need to rebuild if no change since previous update\n    if (options.impulseResponse !== undefined && this.options.impulseResponse !== options.impulseResponse) {\n      shouldUpdateBuffer = true\n      this.options.impulseResponse = options.impulseResponse\n    }\n\n    if (shouldUpdateBuffer) {\n      await this.updateBuffer()\n    }\n  }\n\n  async updateBuffer (): Promise<void> {\n    const bufferPromise = this.options.reverse\n      ? this.soundHandler.getAudioBufferReversed(this.options.impulseResponse)\n      : this.soundHandler.getAudioBuffer(this.options.impulseResponse)\n\n    this.convolverNode.buffer = Exists(await bufferPromise)\n  }\n}\n", "\nimport { Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { clamp, max, type Identifiable, type PartialProperties } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DelayInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  /**\n     * The initial delay time for the node, in seconds. The default is 0\n     * The delayTime property of the DelayNode interface is an a-rate AudioParam representing the amount of delay to apply.\n     * delayTime is expressed in seconds, its minimal value is 0,\n     * and its maximum value is defined by the maxDelayTime argument of the BaseAudioContext.createDelay method that created it\n     *\n     * Todo: add beatsync for delayTime\n    */\n  delayTime?: number\n\n  /**\n     * The maximum delay time for the node, in seconds. Defaults to 1.\n     */\n  maxDelayTime?: number\n\n  /**\n     * The amount of feedback, e.g how much of the output is fed back into the delay\n     * min: 0 (only one bounce, no repeated bounces)\n     * max: 1 (all will create a neverending repeat)\n     */\n  feedback?: number\n\n  /**\n     * The amount of delay to be applied to the signal\n     * min: 0 (0%),\n     * max: 1 (100%)\n     * default is 1\n     */\n  mix?: number\n\n  /**\n     * The frequence of low-pass-filter to be applied to the feedback loop\n     * a.k.a dub delay\n     * min: 10\n     * max: 20000\n     * default: 20000\n     */\n  cutoff?: number\n}\n\nconst TYPENAME = 'DelayInsert' as const\n/**\n * Delay class is responsible to generate a delay node based on configuration given\n */\nexport class DelayInsert implements InsertApi<DelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  automator = new Automator(['delayTime', 'feedback', 'dry-gain', 'wet-gain', 'cutoff'] as const)\n\n  get id (): string {\n    return this.options.id\n  }\n\n  set id (newId: string) {\n    this.options.id = newId\n  }\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  get getOptions (): DelayInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of delay\n     */\n  private readonly options: Required<DelayInsertOptions>\n  /**\n     * Input node of delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of delay\n     */\n  private readonly delayNode: DelayNode\n\n  private readonly filterNode: BiquadFilterNode\n\n  /**\n     * Creates an instance of delay.\n     * @param audioContext\n     * @param options\n     */\n  constructor (audioContext: AudioContext, options: DelayInsertOptions = { id: 'delay' }) {\n    this.inputGainNode = audioContext.createGain()\n    this.outputGainNode = audioContext.createGain()\n    this.dryGainNode = audioContext.createGain()\n    this.wetGainNode = audioContext.createGain()\n    this.feedbackGainNode = audioContext.createGain()\n    this.filterNode = audioContext.createBiquadFilter()\n    this.filterNode.type = 'lowpass'\n    this.delayNode = audioContext.createDelay(options.maxDelayTime !== undefined ? options.maxDelayTime : 1)\n\n    // final graph\n    // input->dry->output\n    // input->delay->feedback\n    //        feedback->delay\n    //        delay->wet->output\n    this.inputGainNode\n      .connect(this.dryGainNode)\n      .connect(this.outputGainNode)\n\n    this.inputGainNode\n      .connect(this.delayNode)\n      .connect(this.wetGainNode)\n      .connect(this.outputGainNode)\n\n    this.delayNode\n      .connect(this.feedbackGainNode)\n      .connect(this.filterNode)\n      .connect(this.delayNode)\n\n    this.options = {\n      id: options.id,\n      feedback: 0.1,\n      mix: 1,\n      delayTime: 0.3,\n      maxDelayTime: 1,\n      cutoff: 20000\n    }\n\n    this.modify(Object.assign(this.options, options)).catch(logger().error)\n\n    this.automator.add('cutoff', this.filterNode.frequency)\n    this.automator.add('delayTime', this.delayNode.delayTime)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n  }\n\n  public async modify (options: PartialProperties<DelayInsertOptions>, endTimeSeconds = 0): Promise<void> {\n    // partialproperties because no reason to force id here\n    const GAIN_MIN = 0.0001 as const\n\n    if (options.delayTime !== undefined) {\n      this.options.delayTime = clamp(options.delayTime, 0, this.options.maxDelayTime)\n\n      this.delayNode.delayTime.cancelScheduledValues(0)\n      this.delayNode.delayTime.linearRampToValueAtTime(this.options.delayTime, endTimeSeconds)\n    }\n    if (options.feedback !== undefined) {\n      this.options.feedback = clamp(options.feedback, GAIN_MIN, 1)\n\n      this.feedbackGainNode.gain.cancelScheduledValues(0)\n      this.feedbackGainNode.gain.exponentialRampToValueAtTime(this.options.feedback, endTimeSeconds)\n    }\n    if ((options.maxDelayTime !== undefined)) {\n      this.options.maxDelayTime = clamp(options.maxDelayTime, 0, 10)\n    }\n    if ((options.mix !== undefined)) {\n      const MIX_MAX = 1 as const\n      this.options.mix = clamp(options.mix, GAIN_MIN, MIX_MAX)\n\n      this.dryGainNode.gain.cancelScheduledValues(0)\n      this.dryGainNode.gain.linearRampToValueAtTime(clamp(1 - this.options.mix, GAIN_MIN, MIX_MAX), endTimeSeconds)\n\n      this.wetGainNode.gain.cancelScheduledValues(0)\n      this.wetGainNode.gain.linearRampToValueAtTime(this.options.mix, endTimeSeconds)\n    }\n    if ((options.id !== undefined)) {\n      this.options.id = options.id\n    }\n\n    if ((options.cutoff !== undefined)) {\n      this.options.cutoff = clamp(options.cutoff, 10, 20000)\n      this.filterNode.frequency.exponentialRampToValueAtTime(this.options.cutoff, endTimeSeconds)\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTimeSeconds - this.outputGainNode.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { clamp, max, type Identifiable } from '@netent-tech/ecas-utils'\nimport { type InsertApi } from './types'\n\nexport interface DynamicsCompressorInsertOptions extends Identifiable, Omit<DynamicsCompressorOptions, keyof AudioNode> {\n  /**\n     * Is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n     * The threshold property's default value is -24 and it can be set between -100 and 0.\n     **/\n  threshold?: number\n\n  /**\n     * Is a k-rate AudioParam containing a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * The knee property's default value is 30 and it can be set between 0 and 40.\n     **/\n  knee?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * The ratio property's default value is 12 and it can be set between 1 and 20.\n     **/\n  ratio?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * It defines how quickly the signal is adapted when its volume is increased.\n     * The attack property's default value is 0.003 and it can be set between 0 and 1.\n     **/\n  attack?: number\n\n  /**\n     * Is a k-rate AudioParam representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * It defines how quick the signal is adapted when its volume is reduced.\n     * The release property's default value is 0.25 and it can be set between 0 and 1.\n     **/\n  release?: number\n}\n\nconst TYPENAME = 'DynamicsCompressorInsert' as const\nexport class DynamicsCompressorInsert implements InsertApi<DynamicsCompressorInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  private readonly options: DynamicsCompressorInsertOptions\n  automator = new Automator(['threshold', 'ratio', 'attack', 'release', 'knee'] as const)\n  node: DynamicsCompressorNode\n  context: BaseAudioContext\n\n  constructor (context: BaseAudioContext, options: DynamicsCompressorInsertOptions) {\n    this.context = context\n    this.id = options.id\n    this.options = { ...options }\n    this.node = context.createDynamicsCompressor()\n    this.automator.add('threshold', this.threshold)\n    this.automator.add('ratio', this.ratio)\n    this.automator.add('attack', this.attack)\n    this.automator.add('release', this.release)\n    this.automator.add('knee', this.knee)\n    void this.modify(options, 0)\n  }\n\n  get attack (): AudioParam {\n    return this.node.attack\n  }\n\n  get knee (): AudioParam {\n    return this.node.knee\n  }\n\n  get ratio (): AudioParam {\n    return this.node.ratio\n  }\n\n  get release (): AudioParam {\n    return this.node.release\n  }\n\n  get threshold (): AudioParam {\n    return this.node.threshold\n  }\n\n  get input (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get output (): DynamicsCompressorNode {\n    return this.node\n  }\n\n  get getOptions (): DynamicsCompressorInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Updates the compressor options.\n     * Uses ramps to values to not cause audible artifacts.\n     * https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode\n     * @param node\n     * @param options -\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * @param endTime\n     * @param sampleRate\n     */\n  async modify (options: DynamicsCompressorInsertOptions, endTime: number): Promise<void> {\n    /**\n         * https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode/attack\n         * The attack property's default value is 0.003 and it can be set between 0 and 1\n         */\n    if (typeof options.attack === 'number') {\n      const MIN_ATTACK = 0 as const\n      const MAX_ATTACK = 1 as const\n      this.attack.cancelScheduledValues(0)\n      this.attack.linearRampToValueAtTime(\n        clamp(\n          options.attack,\n          MIN_ATTACK,\n          MAX_ATTACK\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The knee property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam containing a decibel value\n         * representing the range above the threshold where\n         * the curve smoothly transitions to the compressed portion\n         * The knee property's default value is 30 and it can be set between 0 and 40\n         */\n    if (typeof options.knee === 'number') {\n      const MIN_KNEE = 0 as const\n      const MAX_KNEE = 40 as const\n      this.knee.cancelScheduledValues(0)\n      this.knee.linearRampToValueAtTime(\n        clamp(\n          options.knee,\n          MIN_KNEE,\n          MAX_KNEE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The ratio property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n         * The ratio property's default value is 12 and it can be set between 1 and 20.\n         */\n    if (typeof options.ratio === 'number') {\n      const MIN_RATIO = 1 as const\n      const MAX_RATIO = 20 as const\n      this.ratio.cancelScheduledValues(0)\n      this.ratio.linearRampToValueAtTime(\n        clamp(\n          options.ratio,\n          MIN_RATIO,\n          MAX_RATIO\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The release property of the DynamicsCompressorNode interface\n         * Is a k-rate AudioParam representing the amount of time, in seconds,\n         * required to increase the gain by 10 dB.\n         * It defines how quick the signal is adapted when its volume is reduced.\n         * The release property's default value is 0.25 and it can be set between 0 and 1.\n         */\n    if (typeof options.release === 'number') {\n      const MAX_RELEASE = 1 as const\n      const MIN_RELEASE = 0 as const\n      this.release.cancelScheduledValues(0)\n      this.release.exponentialRampToValueAtTime(\n        clamp(\n          options.release,\n          MIN_RELEASE,\n          MAX_RELEASE\n        ),\n        endTime\n      )\n    }\n\n    /**\n         * The threshold property of the DynamicsCompressorNode interface\n         * is a k-rate AudioParam representing the decibel value above which the compression will start taking effect.\n         * The threshold property's default value is -24 and it can be set between -100 and 0.\n         */\n    if (typeof options.threshold === 'number') {\n      const MIN_THRESHOLD = -100 as const\n      const MAX_THRESHOLD = 0 as const\n      this.threshold.cancelScheduledValues(0)\n      this.threshold.linearRampToValueAtTime(\n        clamp(\n          options.threshold,\n          MIN_THRESHOLD,\n          MAX_THRESHOLD\n        ),\n        endTime\n      )\n    }\n    await new Promise<void>((resolve) => {\n      setTimeout(() => { resolve() }, max((endTime - this.context.currentTime) * 1000, 0))\n    })\n  }\n}\n", "import { Automator } from '@netent-tech/ecas-automator'\nimport { type Identifiable } from '@netent-tech/ecas-utils'\nimport { getDryMixValue, getWetMixValue } from '../utils'\nimport { type InsertApi } from './types'\n\nexport interface PingPongInsertOptions extends Identifiable, Omit<DelayOptions, keyof AudioNode> {\n  feedback?: number\n  mix?: number\n}\n\nexport default PingPongInsertOptions\n\nconst TYPENAME = 'PingPongDelayInsert' as const\n/**\n * PingPongDelay class is responsible to generate a ping pong delay nodes based on configuration given\n */\nexport class PingPongDelayInsert implements InsertApi<PingPongDelayInsert> {\n  static typename = TYPENAME\n  typename = TYPENAME\n  id: string = TYPENAME\n  automator = new Automator(['dry-gain', 'wet-gain', 'delay-time-left', 'delay-time-right', 'feedback'] as const)\n\n  get input (): GainNode {\n    return this.inputGainNode\n  }\n\n  get output (): GainNode {\n    return this.outputGainNode\n  }\n\n  /** Todo: implement */\n  async modify (): Promise<void> {\n    await Promise.resolve<undefined>(undefined)\n  }\n\n  get getOptions (): PingPongInsertOptions {\n    return this.options\n  }\n\n  /**\n     * Options of ping pong delay\n     */\n  private readonly options: Required<PingPongInsertOptions>\n  /**\n     * Input node of ping pong  delay\n     */\n  private readonly inputGainNode: GainNode\n  /**\n     * Output node of ping pong  delay\n     */\n  private readonly outputGainNode: GainNode\n  /**\n     * Dry gain node of ping pong delay\n     */\n  private readonly dryGainNode: GainNode\n  /**\n     * Wet gain node of ping pong delay\n     */\n  private readonly wetGainNode: GainNode\n  /**\n     * Feedback gain node of ping pong delay\n     */\n  private readonly feedbackGainNode: GainNode\n  /**\n     * Delay node of ping pong delay\n     */\n  private readonly delayNodeLeft: DelayNode\n  /**\n     * Delay node right of ping pong delay\n     */\n  private readonly delayNodeRight: DelayNode\n  /**\n     * Channel merger of ping pong delay\n     */\n  private readonly channelMerger: ChannelMergerNode\n\n  /**\n     * Creates an instance of ping pong delay.\n     * @param ecasContext\n     * @param options\n     */\n  constructor (ecasContext: AudioContext, options: PingPongInsertOptions = { id: TYPENAME }) {\n    this.options = Object.assign({\n      feedback: 0.5,\n      mix: 0.5,\n      delayTime: 0.3,\n      maxDelayTime: 1\n    }, options)\n\n    this.maxDelayTime = options.maxDelayTime !== undefined ? options.maxDelayTime : 1\n\n    this.inputGainNode = ecasContext.createGain()\n    this.outputGainNode = ecasContext.createGain()\n    this.dryGainNode = ecasContext.createGain()\n    this.wetGainNode = ecasContext.createGain()\n    this.feedbackGainNode = ecasContext.createGain()\n    this.delayNodeLeft = ecasContext.createDelay(this.maxDelayTime)\n    this.delayNodeRight = ecasContext.createDelay(this.maxDelayTime)\n    this.channelMerger = ecasContext.createChannelMerger(2)\n\n    // dry mix\n    this.inputGainNode.connect(this.dryGainNode)\n    // dry out\n    this.dryGainNode.connect(this.outputGainNode)\n\n    // feedback loop\n    this.delayNodeLeft.connect(this.channelMerger, 0, 0)\n    this.delayNodeRight.connect(this.channelMerger, 0, 1)\n    this.delayNodeLeft.connect(this.delayNodeRight)\n    this.feedbackGainNode.connect(this.delayNodeLeft)\n    this.delayNodeRight.connect(this.feedbackGainNode)\n\n    // wet mix\n    this.inputGainNode.connect(this.feedbackGainNode)\n    // wet out\n    this.channelMerger.connect(this.wetGainNode)\n    this.wetGainNode.connect(this.outputGainNode)\n\n    this.id = options.id\n\n    this.automator.add('delay-time-left', this.delayNodeLeft.delayTime)\n    this.automator.add('delay-time-right', this.delayNodeRight.delayTime)\n    this.automator.add('dry-gain', this.dryGainNode.gain)\n    this.automator.add('wet-gain', this.wetGainNode.gain)\n    this.automator.add('feedback', this.feedbackGainNode.gain)\n  }\n\n  public get mix (): number {\n    return this.options.mix\n  }\n\n  public set mix (mix: number) {\n    this.options.mix = mix\n    this.dryGainNode.gain.value = getDryMixValue(this.mix)\n    this.wetGainNode.gain.value = getWetMixValue(this.mix)\n  }\n\n  public get feedback (): number {\n    return this.options.feedback\n  }\n\n  public set feedback (feedback: number) {\n    if (feedback < 0 || feedback > 1) {\n      return\n    }\n    this.options.feedback = feedback\n    this.feedbackGainNode.gain.value = this.feedback\n  }\n\n  public get delayTime (): number {\n    return this.options.delayTime\n  }\n\n  public set delayTime (time: number) {\n    if (time < 0 || time > this.maxDelayTime) {\n      return\n    }\n    this.options.delayTime = time\n    this.delayNodeLeft.delayTime.value = this.delayTime\n    this.delayNodeRight.delayTime.value = this.delayTime\n  }\n\n  public get maxDelayTime (): number {\n    return this.options.maxDelayTime\n  }\n\n  public set maxDelayTime (maxDelay) {\n    this.options.maxDelayTime = maxDelay\n  }\n\n  public getPingPongDelayNodes (param: string): GainNode | DelayNode[] {\n    if (param === 'feedback') {\n      return this.feedbackGainNode\n    }\n    return [\n      this.delayNodeLeft,\n      this.delayNodeRight\n    ]\n  }\n\n  public getGeneratedGraph (): { leftNode: GainNode, rightNode: GainNode } {\n    return {\n      leftNode: this.inputGainNode,\n      rightNode: this.outputGainNode\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { InsertHandlerError, type SoundHandler } from '../utils'\nimport { AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { BiquadFilterInsert } from './BiquadFilterInsert'\nimport { ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { DelayInsert } from './DelayInsert'\nimport { DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { PingPongDelayInsert } from './PingPongDelayInsert'\nimport { type InsertClass, type InsertOptions, type InsertTypenames } from './types'\n\nexport function createInsert<T extends InsertTypenames> (\n  audioContext: AudioContext,\n  soundHandler: SoundHandler,\n  typename: T,\n  options: InsertOptions<T>\n): InsertClass<T> {\n  logger().debug('createInsert;', typename)\n  switch (typename) {\n    case BiquadFilterInsert.typename: {\n      return new BiquadFilterInsert(audioContext, options as BiquadFilterInsert['options']) as InsertClass<T>\n    }\n    case DynamicsCompressorInsert.typename: {\n      return new DynamicsCompressorInsert(audioContext, options as DynamicsCompressorInsert['options']) as InsertClass<T>\n    }\n    case DelayInsert.typename: {\n      return new DelayInsert(audioContext, options as DelayInsert['options']) as InsertClass<T>\n    }\n    case AlgorithmicReverbInsert.typename: {\n      return new AlgorithmicReverbInsert(audioContext, options as AlgorithmicReverbInsert['options']) as InsertClass<T>\n    }\n    case ConvolverReverbInsert.typename: {\n      return new ConvolverReverbInsert(audioContext, options as ConvolverReverbInsert['options'], soundHandler) as InsertClass<T>\n    }\n    case PingPongDelayInsert.typename: {\n      return new PingPongDelayInsert(audioContext, options as PingPongDelayInsert['options']) as InsertClass<T>\n    }\n    default: {\n      throw new InsertHandlerError(`create insert failed to create any insert for, ${typename as string}`)\n    }\n  }\n}\n", "import { logger } from '@netent-tech/ecas-logger'\nimport { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { createInsert, type InsertAny, type InsertClass, type InsertOptions, type InsertTypenames } from '.'\nimport { InsertHandlerError, lastElement, type SoundHandler } from '../utils'\n\nexport class InsertHandler implements Disposable {\n  private readonly insertMap = new Map<InsertAny['id'], Readonly<InsertAny>>()\n  private inserts: Array<Readonly<InsertAny>>\n  private readonly audioContext: AudioContext\n  private readonly soundHandler: SoundHandler\n  private readonly source: AudioNode\n  private readonly destination: AudioNode\n\n  constructor (audioContext: AudioContext, soundHandler: SoundHandler, source: AudioNode, destination: AudioNode) {\n    this.audioContext = audioContext\n    this.soundHandler = soundHandler\n    this.source = source\n    this.destination = destination\n    this.inserts = []\n  }\n\n  create<T extends InsertTypenames>(typename: T, options: InsertOptions<T>): void {\n    logger().debug('[ecas] insert.create', typename)\n    const insert = createInsert(\n      this.audioContext,\n      this.soundHandler,\n      typename,\n      options\n    )\n    this.add(insert)\n  }\n\n  add<T extends InsertTypenames>(insert: Readonly<InsertClass<T>>): void {\n    logger().debug('[ecas] insert.add')\n    const last = lastElement(this.inserts)\n\n    if (last != null) {\n      last.output.disconnect(this.destination)\n      last.output.connect(insert.input)\n    } else {\n      this.source.disconnect(this.destination)\n      this.source.connect(insert.input)\n    }\n\n    insert.output.connect(this.destination)\n\n    this.inserts.push(insert)\n    this.insertMap.set(insert.id, insert)\n  }\n\n  remove (id: string): void {\n    logger().debug('[ecas] insert.remove', id)\n    const newInserts: Array<Readonly<InsertAny>> = []\n    for (const [index, insert] of this.inserts.entries()) {\n      if (insert.id === id) {\n        const next = this.inserts[index + 1]?.input ?? this.destination\n        const prev = this.inserts[index - 1]?.output ?? this.source\n        prev.disconnect()\n        insert.output.disconnect()\n        prev.connect(next)\n      } else {\n        newInserts.push(insert)\n      }\n    }\n    this.inserts = newInserts\n    this.insertMap.delete(id)\n  }\n\n  get<T extends InsertTypenames>(id: string): InsertClass<T> {\n    if (!this.insertMap.has(id)) {\n      throw new InsertHandlerError(`[ecas] cannot get insert: ${id} since it does not exist`)\n    }\n    return this.insertMap.get(id) as InsertClass<T>\n  }\n\n  logInserts (): void {\n    logger().log(this.inserts)\n  }\n\n  has (id?: string): boolean {\n    return typeof id === 'string'\n      ? this.insertMap.has(id)\n      : isArrayEmpty(this.inserts)\n  }\n\n  dispose (): void {\n    for (const id of this.insertMap.keys()) {\n      this.insertMap.delete(id)\n    }\n\n    while (this.inserts.length > 0) {\n      const insert = this.inserts.pop()\n      insert?.input.disconnect()\n      insert?.output.disconnect()\n    }\n  }\n}\n", "import { type AutomatableParameters, type Automator } from '@netent-tech/ecas-automator'\nimport { logger } from '@netent-tech/ecas-logger'\nimport { type ITypeNamed } from '../utils'\nimport { type AlgorithmicReverbInsert } from './AlgorithmicReverbInsert'\nimport { type BiquadFilterInsert } from './BiquadFilterInsert'\nimport { type ConvolverReverbInsert } from './ConvolverReverbInsert'\nimport { type DelayInsert } from './DelayInsert'\nimport { type DynamicsCompressorInsert } from './DynamicsCompressorInsert'\nimport { type PingPongDelayInsert } from './PingPongDelayInsert'\n\nexport type InsertClasses\n    = AlgorithmicReverbInsert\n    | BiquadFilterInsert\n    | DynamicsCompressorInsert\n    | ConvolverReverbInsert\n    | DelayInsert\n    | PingPongDelayInsert\n\nexport type InsertClass<T extends InsertTypenames>\n    = T extends AlgorithmicReverbInsert['typename'] ? AlgorithmicReverbInsert\n      : T extends BiquadFilterInsert['typename'] ? BiquadFilterInsert\n        : T extends DynamicsCompressorInsert['typename'] ? DynamicsCompressorInsert\n          : T extends ConvolverReverbInsert['typename'] ? ConvolverReverbInsert\n            : T extends DelayInsert['typename'] ? DelayInsert\n              : T extends PingPongDelayInsert['typename'] ? PingPongDelayInsert\n                : never\n\nexport interface InsertApi<T extends InsertClasses> extends ITypeNamed<T['typename']> {\n  id: string\n  input: AudioNode\n  output: AudioNode\n  getOptions: T['getOptions']\n  modify: UseReturnType<T['modify'], Promise<void>>\n  automator: Automator<AutomatableParameters<T>>\n}\n\ntype UseReturnType<T extends (...args: any[]) => any, R> = ReturnType<T> extends R ? T : never\n\nexport type InsertAny = InsertApi<InsertClasses>\nexport type InsertTypenames = InsertAny['typename']\nexport type InsertOptions<T extends InsertTypenames> = InsertApi<InsertClass<T>>['getOptions']\nexport type InsertOptionsAny = InsertOptions<InsertTypenames>\nexport type InsertAutomator<T extends InsertTypenames> = InsertApi<InsertClass<T>>['automator']\nexport type InsertParameters<T extends InsertTypenames> = ReadonlyArray<InsertAutomator<T>['AutomatableParameters'][number]>\n\nexport function is <T extends InsertTypenames> (\n  insert: InsertClasses,\n  typename: T\n): insert is InsertClass<T> {\n  const result = insert.typename === typename\n  if (!result) {\n    logger().warn('[ecas] insert', insert?.typename, 'is not of type', typename)\n  }\n  return result\n}\n\nexport type InsertClassAutomator<T extends InsertTypenames> = Automator<InsertClass<T>['automator']['AutomatableParameters']>\nexport type InsertClassAutomatableParameters<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>\nexport type InsertClassAutomatableParameter<T extends InsertTypenames> = AutomatableParameters<InsertClass<T>>[number]\n\nexport interface InsertIdentifiable {\n  insertId: string\n}\n", "import { clamp } from \"@netent-tech/ecas-utils\"\n\n/**\n * Create a pan node.\n *\n * @param {number} pan Pan value between -1 and 1. Defaults to 0 (center).\n *\n * @returns {StereoPannerNode} The created pan node instance.\n * @private\n */\nexport function createPanNode(audioContext: AudioContext, pan = 0): StereoPannerNode {\n    const stereoPanner = audioContext.createStereoPanner()\n    stereoPanner.pan.value = clamp(pan, -1, 1)\n    return stereoPanner\n}\n\nexport function createGainNode(audioContext: AudioContext, gain = 1): GainNode {\n    const gainNode = audioContext.createGain()\n    gainNode.gain.value = Math.max(gain, 0)\n    return gainNode\n}\n", "export function playSilenceToNode(audioContext: AudioContext, node: AudioNode) {\n    const silence = audioContext.createBufferSource()\n    silence.buffer = audioContext.createBuffer(2, 128, audioContext.sampleRate)\n    silence.connect(node)\n    silence.loop = true\n    silence.start()\n}\n", "import { Automatable, AutomatableParameters, Automator } from \"@netent-tech/ecas-automator\"\nimport { clamp, type Disposable } from \"@netent-tech/ecas-utils\"\nimport { Timer } from \"../../scheduling/Timer\"\nimport { SoundHandler } from \"../../asset-handler/SoundHandler\"\nimport { MAX_GAIN_LINEAR, MAX_PAN, MIN_GAIN_LINEAR, MIN_PAN, TIME_LOOKAHEAD_SECONDS } from \"../../constants\"\nimport { idGen } from \"../../id-generator\"\nimport { BusConfig } from \"@netent-tech/ecas-common\"\nimport { InsertHandler } from \"@netent-tech/ecas-inserts\"\nimport { createGainNode, createPanNode } from \"../node-creators\"\nimport { playSilenceToNode } from \"../silence\"\n\n/** #inputNode -> inserts -> #pannerNode -> #gainNode */\nexport class Bus implements Disposable, Automatable<AutomatableParameters<Bus>> {\n    automator = new Automator([\"gain\", \"pan\"] as const)\n    #audioContext: AudioContext\n    #soundHandler: SoundHandler\n\n    /** The name of this bus */\n    #id: string\n\n    // just here to provide something to be connected to without having to change every time an insert is added\n    #inputNode: GainNode\n\n    /** inserts destination connect to this node **/\n    #pannerNode: StereoPannerNode\n\n    /** Used as output node, pannerNode connects to this node */\n    #outputNode: GainNode\n\n    inserts: InsertHandler\n\n    constructor(audioContext: AudioContext, soundHandler: SoundHandler, config: BusConfig) {\n        this.#audioContext = audioContext\n        this.#soundHandler = soundHandler\n        this.#inputNode = createGainNode(audioContext, 1)\n        this.#outputNode = createGainNode(audioContext, clamp(config.volume, MIN_GAIN_LINEAR, MAX_GAIN_LINEAR))\n        this.#pannerNode = createPanNode(audioContext, clamp(config.pan, MIN_PAN, MAX_PAN))\n\n        // Adding a silence node to keep bus nodes from being reset when no sound is playing\n        // This is causing pan and gain changes set by envelopes to be lost. (ECAS-218)\n        // Note that this could break since clearing of unused nodes is not specified in the spec and might change\n        playSilenceToNode(this.#audioContext, this.#inputNode)\n\n        this.#inputNode\n            .connect(this.#pannerNode)\n            .connect(this.#outputNode)\n\n        this.setGain(config.volume)\n        this.setPan(config.pan)\n        this.#id = config.id\n        this.inserts = new InsertHandler(\n            this.#audioContext,\n            this.#soundHandler,\n            this.#inputNode,\n            this.#pannerNode\n        )\n\n        this.automator.add(\"gain\", this.#outputNode.gain)\n        this.automator.add(\"pan\", this.#pannerNode.pan)\n    }\n\n    get input () {\n        return this.#inputNode\n    }\n\n    get output () {\n        return this.#outputNode\n    }\n\n    get id () {\n        return this.#id\n    }\n\n    /** Used as input node when no inserts active */\n    get pannerNode () {\n        return this.#pannerNode\n    }\n\n    /** Used as output node */\n    get gainNode () {\n        return this.#outputNode\n    }\n\n    get gain() {\n        return this.#outputNode.gain\n    }\n\n    /**\n     * Set the output volume for a bus.\n     *\n     * @param {string} bussId ID of bus to modify.\n     * @param {number} val Volume value between 0-1.\n     */\n    setGain(newGain: number, duration = 0) {\n        const clampedValue = clamp(newGain, MIN_GAIN_LINEAR, MAX_GAIN_LINEAR)\n        this.#outputNode.gain.cancelScheduledValues(0)\n        this.#outputNode.gain.exponentialRampToValueAtTime(\n            clampedValue,\n            this.#audioContext.currentTime + TIME_LOOKAHEAD_SECONDS + duration\n        )\n        return new Promise<void>((resolve) => Timer.setTimeout(\n            () => resolve(),\n            (TIME_LOOKAHEAD_SECONDS + duration) * 1000,\n            String(idGen.next())\n        ))\n    }\n\n    /**\n     * Change pan position for a bus.\n     *\n     * @param {string} bussId ID of bus to modify.\n     * @param {number} newPan position between -1 to 1.\n     */\n    setPan(newPan: number, duration = 0) {\n        this.#outputNode.gain.cancelScheduledValues(0)\n        // linearRamp to prevent distortion when instantly changing pan value\n        this.#pannerNode.pan.linearRampToValueAtTime(\n            clamp(newPan, MIN_PAN, MAX_PAN),\n            this.#audioContext.currentTime + TIME_LOOKAHEAD_SECONDS + duration\n        )\n        return new Promise<void>((resolve) => Timer.setTimeout(\n            () => resolve(),\n            (TIME_LOOKAHEAD_SECONDS + duration) * 1000,\n            String(idGen.next())\n        ))\n    }\n\n    get pan() {\n        return this.#pannerNode.pan\n    }\n\n    dispose() {\n        this.#inputNode.disconnect()\n        this.#outputNode.disconnect()\n        this.#pannerNode.disconnect()\n    }\n}\n", "import { isArrayEmpty, type Disposable } from '@netent-tech/ecas-utils'\nimport { SoundHandler } from \"../../asset-handler/SoundHandler\"\nimport { MASTER_BUS_ID, OUTPUT_BUS_ID } from \"../../constants\"\nimport { BusConfig, BusHandlerError, IBusConnection, ISoundSource } from \"@netent-tech/ecas-common\"\nimport { topoSort } from \"../../utils\"\nimport { Bus } from \"./Bus\"\n\nexport class BusHandler implements Disposable {\n    #buses = new Map<Bus['id'], Bus>()\n    #busConnections = new Map<Bus['id'], IBusConnection>()\n    #audioContext: AudioContext\n    #soundHandler: SoundHandler\n\n    constructor(\n        audioContext: AudioContext,\n        soundHandler: SoundHandler,\n        busConfigs: BusConfig[]\n    ) {\n        this.#audioContext = audioContext\n        this.#soundHandler = soundHandler\n\n        const masterBusConfig = new BusConfig({\n            id: MASTER_BUS_ID,\n            destination: OUTPUT_BUS_ID\n        })\n        busConfigs.unshift(masterBusConfig)\n\n        // Should not be modified by anyone but ecas, only used for mute / unmute atm.\n        const outputBusConfig = new BusConfig({\n            id: OUTPUT_BUS_ID,\n            destination: null\n        })\n        busConfigs.unshift(outputBusConfig)\n\n        const connections = createSortedConnections(busConfigs)\n        connections.forEach(this.#setupBuss)\n    }\n\n    #setupBuss = (busConfig: BusConfig) => {\n        const bus = new Bus(this.#audioContext, this.#soundHandler, busConfig)\n\n        if (bus.id === OUTPUT_BUS_ID) {\n            bus.output\n                .connect(this.#audioContext.destination)\n        }\n        else {\n            bus.output\n                .connect(this.get(busConfig.destination).input)\n        }\n\n        this.#buses.set(bus.id, bus)\n\n        this.#busConnections\n            .set(bus.id, {\n                inputs: [],\n                outputs: [{\n                    index: 0,\n                    originalDestinationNode: busConfig.destination,\n                    node: this.#audioContext.destination,\n                    nodeId: bus.id + \"_0\",\n                    soundContext: null,\n                    isUsed: true\n                }]\n            })\n    }\n\n    get(id: string) {\n        if (!this.#buses.has(id)) {\n            throw new BusHandlerError(`[ecas] cannot get bus: ${id} since it does not exist`)\n        }\n        return this.#buses.get(id)\n    }\n\n    getBusConnections(id: string) {\n        if (!this.#busConnections.has(id)) {\n            throw new BusHandlerError(`[ecas] cannot get bus: ${id} since it does not exist`)\n        }\n        return this.#busConnections.get(id)\n    }\n\n    /**\n     * Remove a node connection from internal bus connection references\n     *\n     * @param {string} soundId Id of sound associated with SourceAudioNode.\n     * @param {string} parentId Id of sound parent (pattern or pool id).\n     * @param {ISoundSource} soundSource SourceAudioNode of the sound connection to purge.\n     * @param {string} busId The bus ID to purge sound connection from.\n     */\n    purgeConnections(soundId: string, parentId: string, soundSource: ISoundSource, busId: string): void {\n        const connections = this.getBusConnections(busId)\n\n        if (isArrayEmpty(connections.inputs)) {\n            return\n        }\n\n        connections.inputs = connections.inputs.filter (\n            (node) =>\n                node.soundContext.id !== soundId\n                && node.soundContext.parentId !== parentId\n                && node.soundContext.soundSource !== soundSource\n                && node.soundContext.bussId !== busId\n        )\n    }\n\n    dispose() {\n        for (const busNode of this.#buses.values()) {\n            busNode.dispose()\n        }\n    }\n}\n\nfunction createSortedConnections(buses: BusConfig[]) {\n    const busConnections = buses.map(bus => [bus.id, bus.destination])\n    const sortedConnections = topoSort(busConnections)\n    return sortedConnections.map(\n        val => buses.reduce(\n            (curr, acc) => curr.id === val ? curr : acc\n        )\n    )\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isDefined } from \"@netent-tech/ecas-utils\"\nimport { BusConfig, EnvelopeParameterType, ISoundContext, ISoundNodes, Sound, TargetType } from \"@netent-tech/ecas-common\"\nimport { joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Bus } from \"./buses/Bus\"\n\ninterface IGetAudioParamsOptions {\n    targetId: BusConfig['id'] | Sound['id']\n    param: EnvelopeParameterType\n    type: TargetType\n    parentId: BusConfig['id'] | Sound['id']\n    getSoundContexts: (id: string, parentId: string) => ISoundContext[]\n    getSoundConnections: (id: string) => ISoundNodes[]\n    getBuss: (id: BusConfig['id']) => Bus\n}\n\n/**\n * Read parameters from a bus or sound.\n *\n * @param {string} target ID of bus or sound to read from.\n * @param {string} param Type of value to read. \"volume\" or \"pan\" or \"pitch\".\n * @param {string} targetType Type of bus to read param from. Defaults to \"bus\", else interpreted as parentId for \"sound\".\n * @param {string} parentId Id of sound parent (pattern or pool id)\n * @returns {AudioParam} The retrieved AudioParam.\n*/\nexport function createAudioParams(options: IGetAudioParamsOptions): Array<AudioParam> {\n    if (options.type === \"bus\") {\n        return createAudioParamArrayForBuss(options)\n    }\n    // target type not bus, probably a sound parent id\n    return createAudioParamArrayForSound(options)\n}\n\nfunction createAudioParamArrayForBuss(options: IGetAudioParamsOptions) {\n    const { getBuss, targetId } = options\n    return createAudioParamArray(options, [getBuss(targetId)])\n}\n\nfunction createAudioParamArrayForSound(options: IGetAudioParamsOptions) {\n    const { targetId, parentId, getSoundConnections } = options\n    const connections = getSoundConnections(joinTimeoutCallers(targetId, parentId))\n    return createAudioParamArray(options, connections)\n}\n\nfunction createAudioParamArray (options: IGetAudioParamsOptions, arr: Array<ISoundNodes> | Array<Bus>) {\n    const { targetId, parentId, getSoundContexts, param } = options\n    const audioParams = new Array<AudioParam>()\n    for (const item of arr) {\n        switch (param) {\n            case \"volume\":\n                audioParams.push(item.gainNode.gain)\n                break\n            case \"pan\":\n                audioParams.push(item.pannerNode.pan)\n                break\n            case \"pitch\": {\n                // Todo: Check this\n                const soundContexts: ISoundContext[] = getSoundContexts(targetId, parentId)\n                const ctx = soundContexts.pop()\n                if (isDefined(ctx)) {\n                    const src = ctx.soundSource\n                    if (isDefined(src)) {\n                        const source = src.source as AudioBufferSourceNode\n                        audioParams.push(source.playbackRate)\n                    }\n                }\n                break\n            }\n            default:\n                logger().warn(\"[ecas] createAudioParamArray needs either \\\"volume\\\", \\\"pan\\\" or \\\"pitch\\\" as param type\")\n                break\n        }\n    }\n    return audioParams\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isArray } from \"@netent-tech/ecas-utils\"\nimport { SoundHandler } from \"../asset-handler/SoundHandler\"\nimport { SoundConfig } from \"@netent-tech/ecas-common\"\n\n/**\n* Get audio param (volume,pan and pitch) default value of sound/bus\n*\n* @param {string} target SoundId, bussId or EffectId.\n* @param {string} param Audio param volume,pan and pitch.\n* @param {string} targetType type of the target node.\n* @returns {number|undefined} Return number if audio param is configured, otherwise return undefined.\n*/\nexport function getDefaultValueFromSoundConfig(opt: {\n        targetId: string,\n        targetParam: string,\n        targetType: string,\n        soundConfig: SoundConfig,\n        soundHandler: SoundHandler\n    }): number | undefined {\n    const soundParams = [\"volume\", \"pan\", \"pitch\"] as const\n    function isSoundParam(thing: string): thing is typeof soundParams[number] {\n        return soundParams.includes(thing as typeof soundParams[number])\n    }\n\n    const { targetId: target, targetParam: param, targetType, soundConfig, soundHandler } = opt\n\n    if (targetType === \"sound\") {\n        const sound = soundHandler.getSound(target)\n\n        if (!isSoundParam(param)) {\n            logger().warn('[ecas] targetType is sound, but param is not eligible on sound.', target, param, targetType)\n        }\n\n        const soundParam = sound[param]\n        if (isArray(soundParam)) {\n            return getFirstValueInNDimensionalArray(soundParam)\n        }\n        return soundParam\n    }\n\n    const busConfig = soundConfig.buses.filter(bus_ => bus_.id === target)[0]\n    return busConfig[param]\n}\n\nfunction getFirstValueInNDimensionalArray<T> (arr: T) {\n    if (isArray(arr)) {\n        return getFirstValueInNDimensionalArray(arr[0])\n    }\n    return arr[0]\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { isFunction, isString } from \"@netent-tech/ecas-utils\"\nimport EventHandler from \"../event-handler\"\n\n\nexport function callOnEnded(val: unknown, eventHandler: EventHandler): void {\n    if (isFunction(val)) {\n        val()\n        return\n    }\n\n    if (isString (val)) {\n        eventHandler.triggerOnEndedEvent(val)\n        return\n    }\n\n    logger().warn(\"[ecas] invalid parameter type specified in onEnded.\")\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { arraySum, clamp, Disposable, exists, isArrayNonEmpty, isDefined, isNull, isUndefined, noop } from '@netent-tech/ecas-utils'\nimport { AssetHandler } from \"../asset-handler\"\nimport { MAX_GAIN_LINEAR, MIN_GAIN_LINEAR, TIMEOUT_CALLERS, TIME_LOOKAHEAD_SECONDS } from \"../constants\"\nimport { BusConfig, IConnection, ISoundContext, ISoundNodes, ISoundSource, IStringMap, Sound, SourceAudioNode } from \"@netent-tech/ecas-common\"\nimport { createAutomationCurve, createEnvelopeContext, EnvelopeContext, EnvelopeHandler } from \"../envelopes\"\nimport { createEnvelopePointsInOriginalState } from \"../envelopes/envelopes\"\nimport { EcasEvents, EventHandler } from \"../event-handler\"\nimport { EcasOptions } from \"../options-creator\"\nimport { createTimeoutCallerForPlayEnvelope, joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Timer } from \"../scheduling/Timer\"\nimport { Utils } from \"../utils\"\nimport { getAudioBufferSourceNode, playBufferSource } from \"./buffer\"\nimport { BusHandler } from \"./buses/BusHandler\"\nimport { createAudioParams } from \"./create-audio-params\"\nimport { getDefaultValueFromSoundConfig } from \"./get-default-value-from-sound-config\"\nimport { createPanNode } from \"./node-creators\"\nimport { callOnEnded } from \"./onended\"\n\nexport class Mixer implements Disposable {\n    buses: BusHandler\n    #envelopeHandler: EnvelopeHandler\n\n    // #envelopes: IStringMap<IEnvelopeContext[]>;\n    #soundConnections: IStringMap<ISoundNodes[]>\n    #elementSoundSources: IStringMap<ISoundSource>\n    #audioContext: AudioContext\n    #soundContexts: IStringMap<ISoundContext[]>\n    #options: EcasOptions\n    #eventHandler: EventHandler\n    #assetHandler: AssetHandler\n\n    /**\n     * @param {ECASContext} context Context object with configuration.\n     */\n    constructor(audioContext: AudioContext, ecasOptions: EcasOptions, eventHandler: EventHandler, assetHandler: AssetHandler, envelopeHandler: EnvelopeHandler) {\n        this.#audioContext = audioContext\n        this.#eventHandler = eventHandler\n        this.#assetHandler = assetHandler\n        this.#envelopeHandler = envelopeHandler\n        this.#options = ecasOptions\n        this.#soundConnections = {}\n        this.#elementSoundSources = {}\n        this.#soundContexts = {}\n        this.buses = new BusHandler(\n            this.#audioContext,\n            this.#assetHandler.soundHandler,\n            ecasOptions.soundConfig.buses\n        )\n    }\n\n    get audioContext () {\n        return this.#audioContext\n    }\n\n    get assetHandler () {\n        return this.#assetHandler\n    }\n\n    get elementSoundSources () {\n        return this.#elementSoundSources\n    }\n\n    //Needed for testing\n    get soundConnections () {\n        return this.#soundConnections\n    }\n\n    /**\n     * Get current time since sound context was started.\n     * @returns {number} Current time in seconds\n     * why is this function in the mixer????\n     */\n    now(): number {\n        return this.#audioContext.currentTime\n    }\n\n\n    /**\n     * Pause a sound.\n     * @param {string} id Id of sound to pause.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     */\n    pauseSound(id: Sound['id'], parentId = id) {\n        const contexts = this.#getSoundContexts(id, parentId)\n        const fullId = joinTimeoutCallers(id, parentId)\n\n        if (isNull(contexts)) {\n            return null\n        }\n        for (const ctx of contexts) {\n            if (ctx && !ctx.isPaused) {\n                ctx.startTimeSeconds = Utils.defaultNumber(ctx.startTimeSeconds)\n                ctx.currentTime = Utils.defaultNumber(ctx.currentTime)\n                const elapsed = (ctx.currentTime + (this.now() - ctx.startTimeSeconds)) % (this.#assetHandler.soundHandler.getDurationSeconds(id) / ctx.playbackRate)\n\n                ctx.currentTime = elapsed\n                ctx.isPaused = true\n                ctx.playing = false\n\n                this.#stopSoundSource(id, parentId, ctx.soundSource, ctx.bussId)\n                Timer.clearTimeout(fullId)\n\n                if (!ctx.isLoop) {\n                    Timer.clearTimeout(\n                        joinTimeoutCallers(\n                            fullId,\n                            TIMEOUT_CALLERS.STOP\n                        )\n                    )\n                    Timer.clearTimeout(\n                        joinTimeoutCallers(\n                            fullId,\n                            TIMEOUT_CALLERS.DEFAULT_STOP\n                        )\n                    )\n                }\n            }\n        }\n    }\n\n    /**\n     * Resume a paused sound.\n     * @param {string} id Id of sound to resume.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     */\n    resumeSound(id: string, parentId = id) {\n        const contexts: ISoundContext[] = this.#getSoundContexts(id, parentId)\n\n        if (contexts) {\n            for (const ctx of contexts) {\n                if (ctx && ctx.isPaused) {\n                    ctx.startTimeSeconds = this.now()\n                    this.connectSound(null, id, ctx, () => {\n                        this.playSound(id, ctx)\n                    })\n                }\n                else {\n                    logger().debug(`[ecas] unable to resume sound with sound id ${id}. sound was not paused`)\n                }\n            }\n        }\n    }\n\n    /**\n     * Play a sound.\n     *\n     * @param {string} id - Id of sound to play.\n     * @param {ISoundContext} context - Context for sound to play.\n     * @return {Promise<void>}\n     */\n    playSound(id: string, context: ISoundContext) {\n        const fullId = joinTimeoutCallers(id, context.parentId)\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Play, id, fullId)\n\n        if (isUndefined(context.parentId)) {\n            context.parentId = id\n        }\n        if (isUndefined(context.playbackRate)) {\n            context.playbackRate = 1\n        }\n\n        const startTimeSeconds = Utils.defaultNumber(context.startTimeSeconds)\n        const startPositionSeconds = context.currentTime || Utils.defaultNumber(context.startPos)\n        const delay = Utils.defaultNumber(context.delaySeconds)\n\n        context.durationSeconds = Utils.defaultNumber(context.durationSeconds)\n        const confDuration = context.durationSeconds ? context.durationSeconds : Number.POSITIVE_INFINITY\n        const soundDurationSeconds = (this.#assetHandler.soundHandler.getDurationSeconds(id) / context.playbackRate) - startPositionSeconds\n        const duration = context.isLoop ? undefined : Math.min(confDuration || Number.POSITIVE_INFINITY, soundDurationSeconds)\n\n        context.currentTime = startPositionSeconds\n        context.delaySeconds = delay ? delay : 0\n\n        // If the sound duration is less than configured duration, we handle ending the sound here,\n        // otherwise we will get the stop from sequencer.\n        if (!context.isLoop && !context.isScheduled && confDuration >= soundDurationSeconds) {\n            const endPositionSeconds = this.#audioContext.currentTime + soundDurationSeconds\n            const timeoutSeconds = soundDurationSeconds - TIME_LOOKAHEAD_SECONDS\n            Timer.setTimeout(\n                this.stopSound.bind(this, id, context.parentId, endPositionSeconds),\n                timeoutSeconds,\n                joinTimeoutCallers(\n                    fullId,\n                    TIMEOUT_CALLERS.DEFAULT_STOP\n                )\n            )\n        }\n\n        context.isPaused = false\n        this.createSourceNodeAndStartSource(id, context, duration, startTimeSeconds)\n    }\n\n    async createSourceNodeAndStartSource(id: string, soundContext: ISoundContext, durationSeconds: number, startTimeSeconds: number) {\n        const getAudioBuffer = async (reverse: boolean) => {\n            if (reverse) {\n                return this.assetHandler.soundHandler.getAudioBufferReversed(id)\n            }\n            return this.assetHandler.soundHandler.getAudioBuffer(id)\n        }\n\n        const audioBuffer = await getAudioBuffer(soundContext.reverse)\n        const sourceNode = getAudioBufferSourceNode(audioBuffer, this.#audioContext, soundContext)\n        playBufferSource(sourceNode, durationSeconds, startTimeSeconds, soundContext, id, this.#eventHandler, this.#audioContext)\n    }\n\n    /**\n     * Stop a sound.\n     * @param {string} id Id of sound to stop.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence). Optional.\n     * @param {number} when When to stop, as current position in seconds.\n     */\n    stopSound(id: Sound['id'], parentId = id, when = 0, onEnded?: string) {\n        logger().debug(`[ecas] stop sound ${id} at ${when} seconds with onEnded ${onEnded}`)\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Stop, id)\n\n        const contexts = this.#getSoundContexts(id, parentId)\n\n        if (contexts) {\n            contexts.forEach((ctx) => {\n                if (onEnded !== undefined) {\n                    ctx.onEnded = () => this.#eventHandler.triggerAudioEvent(onEnded)\n                }\n\n                this.#onCompleteSound(id, ctx, when)\n            })\n        }\n    }\n\n    /**\n     * Logs ID's of all of the currently playing sounds.\n     */\n    logActiveSounds() {\n        logger().log(this.getActiveSounds())\n    }\n\n    /**\n     * Gets a list of all of the currently playing sounds.\n     */\n    getActiveSounds(): string[] {\n        const active: string[] = []\n        for (const key of Object.keys(this.#soundContexts)) {\n            const contexts: ISoundContext[] = this.#soundContexts[key]\n            if (contexts) {\n                contexts.forEach((context: ISoundContext) => {\n                    active.push(context.id)\n                })\n            }\n        }\n        return active\n    }\n\n    /**\n     * Remove a sound from mixer.\n     *\n     * @param {string} id The individual id of the sound.\n     * @param {string} parentId Pool or group of the sound.\n     * @param {ISoundSource} soundSource The connected ISound.\n     * @param {string} bussId The id of the bus sound is connected to.\n     */\n    removeSound(id: string, parentId: string, soundSource: ISoundSource, bussId: string): void {\n        this.buses.purgeConnections(id, parentId, soundSource, bussId)\n        if (soundSource.source) {\n            soundSource.source.disconnect()\n            soundSource.source = null\n        }\n    }\n\n    buildAudioParamArray(targetId: BusConfig['id'] | Sound['id'], ctx: EnvelopeContext) {\n        if (!ctx.node) {\n            return createAudioParams({\n                targetId: targetId,\n                ...ctx,\n                getSoundContexts: this.#getSoundContexts.bind(this),\n                getSoundConnections: this.getSoundConnections.bind(this),\n                getBuss: this.buses.get.bind(this.buses)\n            })\n        }\n\n        const param = ctx.node[ctx.param]\n        return [param] as [AudioParam]\n    }\n\n    /**\n     * Play an envelope.\n     * @param {string} targetId Id of a bus or a sound.\n     * @param {IEnvelopeContext} context Context object with configuration.\n     */\n    playEnvelope(targetId: BusConfig['id'] | Sound['id'], context: Readonly<EnvelopeContext>): void {\n        this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Play, targetId)\n\n        const envelopeContext: EnvelopeContext = createEnvelopeContext(context)\n        envelopeContext.parentId = context.parentId || targetId\n\n        if (envelopeContext.startTime === 0) {\n            envelopeContext.startTime = this.#audioContext.currentTime\n        }\n\n        const audioParamArray = this.buildAudioParamArray(targetId, envelopeContext)\n\n        //Naming? :|\n        const createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout = (passedAudioParam: AudioParam) => {\n            envelopeContext.audioParam = passedAudioParam\n            const originalAudioParamValue = passedAudioParam.value\n\n            const envelopeContexts = this.#envelopeHandler.getContexts(targetId)\n\n            // Store the provided context\n            envelopeContexts.push(envelopeContext)\n\n            // I don't know what this is for\n            if (isArrayNonEmpty(envelopeContexts)) {\n                const firstEnvelope = envelopeContexts[0]\n                const tid = createTimeoutCallerForPlayEnvelope({\n                    targetId: targetId,\n                    param: firstEnvelope.param,\n                    parentId: firstEnvelope.parentId,\n                    willStopSoundOnEnded: firstEnvelope.willStopSoundOnEnded\n                })\n                Timer.clearTimeout(tid)\n                passedAudioParam.cancelScheduledValues(0)\n            }\n\n            // Since resume operation modifies envelope to start from pause position\n            // we need to restore envelope to original state when playing back again\n            if (!envelopeContext.isPaused) {\n                envelopeContext.envelopePoints = createEnvelopePointsInOriginalState(envelopeContexts, envelopeContext.parentId)\n            }\n\n            const createRealValuesFromDefaultOrCurrent = () => {\n                // get real values out of default and current\n                return envelopeContext.envelopePoints.map(point => {\n                    if (point.val === \"default\") {\n                        return getDefaultValueFromSoundConfig({\n                            targetId: targetId,\n                            targetType: envelopeContext.type,\n                            targetParam: envelopeContext.param,\n                            soundConfig: this.#options.soundConfig,\n                            soundHandler: this.#assetHandler.soundHandler\n                        })\n                    }\n                    if (point.val === \"current\") {\n                        return originalAudioParamValue\n                    }\n                    return point.val\n                })\n            }\n\n            const values = createRealValuesFromDefaultOrCurrent()\n            const positions = envelopeContext.envelopePoints.map(point => point.pos)\n\n            // Calculate playbackRate if target parameter is pitch\n            if (envelopeContext.param === \"pitch\") {\n                for (let i = 0; i < values.length; i++) {\n                    values[i] = Utils.pitchToPlaybackRate(values[i])\n                }\n            }\n\n            const curve = createAutomationCurve({\n                values: values,\n                positions: positions,\n                curveType: envelopeContext.curveType\n            })\n\n            const totalDurationMilliSeconds = arraySum(envelopeContext.envelopePoints.map(point => point.pos))\n            const totalDurationSeconds = totalDurationMilliSeconds / 1000\n\n            passedAudioParam.cancelScheduledValues(envelopeContext.startTime) // if a previous envelope is still running we need to override that one\n\n            passedAudioParam.setValueCurveAtTime(curve, envelopeContext.startTime, totalDurationSeconds)\n\n            // Seems like unless you specify at least a frame worth of delay, timeout will trigger before envelope completed\n            // Since the onEnded callback and value update is not really timing critical, it should be safe to add some margin.\n            const safety = 0.05\n\n            Timer.setTimeout(\n                () => {\n                    if (envelopeContext.onplay) {\n                        envelopeContext.onplay()\n                    }\n                    this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Start, targetId)\n                },\n                envelopeContext.startTime + safety,\n                joinTimeoutCallers(targetId, TIMEOUT_CALLERS.ENVELOPE_SCHEDULED, \"START\")\n            )\n\n            Timer.setTimeout(\n                () => {\n                    if (this.#audioContext.state === \"suspended\") {\n                        return\n                    }\n\n                    if (envelopeContext.onEnded) {\n                        this.#eventHandler.triggerAudioEvent(EcasEvents.Envelope.Ended, targetId)\n                        callOnEnded(envelopeContext.onEnded, this.#eventHandler)\n                    }\n\n                    this.#envelopeHandler.setContexts({\n                        id: targetId,\n                        contexts: envelopeContexts.filter((val) => envelopeContext.parentId !== val.parentId)\n                    })\n                },\n                totalDurationSeconds + safety,\n                createTimeoutCallerForPlayEnvelope({\n                    targetId: targetId,\n                    param: envelopeContext.param,\n                    parentId: envelopeContext.parentId,\n                    willStopSoundOnEnded: context.willStopSoundOnEnded\n                })\n            )\n        }\n\n        if (context.isAFadeIn) createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout(audioParamArray[audioParamArray.length - 1])\n        else for (const audioParam of audioParamArray) {\n            createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout(audioParam)\n        }\n    }\n\n    connect(src: AudioNode, dst: AudioNode) {\n        src.connect(dst)\n    }\n\n    getSoundParam (soundId: Sound['id'], param: keyof Sound) {\n        const sound: Sound = this.#assetHandler.soundHandler.getSound(soundId)\n        return sound[param]\n    }\n\n    getSoundConnections(id: Sound['id']): ISoundNodes[] {\n        if (!exists(this.#soundConnections[id])) {\n            logger().warn(\"[ecas] no sound connections found for id\", id, \"in\", this.#soundConnections)\n        }\n        return this.#soundConnections[id] || []\n    }\n\n    stopAll({onEnded}: {onEnded?: string} = {}) {\n        Object.values(this.#soundContexts)\n            .forEach(\n                (contexts) => {\n                    contexts\n                        .forEach(\n                            (ctx: ISoundContext) => {\n                                this.stopSound(ctx.id, ctx.parentId, 0, onEnded)\n                            }\n                        )\n                }\n            )\n    }\n\n    dispose() {\n        this.stopAll()\n        this.buses.dispose()\n    }\n\n    /**\n     * Connect a source to mixer.\n     *\n     * @param {AudioNode} sourceNode The AudioNode to connect. From an HTMLMediaElement or buffer source.\n     * @param {string} id The id of the sound to connect.\n     * @param {ISoundContext} context Sound context for the sound to connect.\n     * @param {Function} cb Callback invoked with the index of the input connected to if successful.\n     */\n    connectSound(sourceNode: SourceAudioNode, id: string, soundContext: ISoundContext, cb: (connection: IConnection) => void = noop) {\n        if (!exists(sourceNode)) {\n            sourceNode = this.#audioContext.createBufferSource()\n        }\n\n        // Signal flow as follows:\n        // element -> panNode -> gainNode -> bus -> audioContext\n        const gainNode = this.#audioContext.createGain()\n\n        const panValue = isDefined(soundContext.pan)\n            ? clamp(Utils.randomizeValues(soundContext.pan), -1, 1)\n            : 0\n\n        const panNode = createPanNode(this.#audioContext, panValue)\n\n        sourceNode.disconnect()\n        sourceNode.connect(panNode)\n        panNode.connect(gainNode)\n        gainNode.connect(this.buses.get(soundContext.bussId).input)\n\n        const inputs = this.buses.getBusConnections(soundContext.bussId).inputs\n        const inputIndex = inputs.length\n        const nodeId = Utils.generateUniqueId(id)\n        const connection: IConnection = {\n            index: inputIndex,\n            node: gainNode,\n            nodeId,\n            soundContext: soundContext,\n            isUsed: true\n        }\n\n        inputs.push(connection)\n\n        const volume = isDefined(soundContext.volume)\n            ? clamp(Utils.randomizeValues(soundContext.volume), MIN_GAIN_LINEAR, MAX_GAIN_LINEAR)\n            : 1\n\n        gainNode.gain.value = volume\n\n        const caller = joinTimeoutCallers(id, soundContext.parentId)\n\n        this.#soundConnections[caller] = Utils.defaultValue(this.#soundConnections[caller], [])\n        this.#soundConnections[caller].push({\n            context: soundContext,\n            audioEffectNodes: [],\n            pannerNode: panNode,\n            gainNode: gainNode,\n            sourceNode: sourceNode,\n            nodeId\n        })\n\n        this.#soundContexts[id] = Utils.defaultValue(this.#soundContexts[id], [])\n        soundContext.parentId = Utils.defaultValue(soundContext.parentId, id)\n        // Avoid duplicating context when it comes to resume\n        if (!soundContext.isPaused) {\n            this.#soundContexts[id].push(soundContext)\n        }\n        const index = Object.keys(this.#soundContexts).length\n        soundContext.soundSource = { source: sourceNode, index }\n        cb(connection)\n    }\n\n\n    #onCompleteSound(id: string, context: ISoundContext, when: number) {\n        const combinedId = joinTimeoutCallers(context.id, context.parentId)\n\n        this.#stopSoundSource(id, context.parentId, context.soundSource, context.bussId, when)\n\n        Timer.clearTimeout(combinedId)\n\n        if (!context.isLoop) {\n            Timer.clearTimeout(joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.STOP))\n            Timer.clearTimeout(joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.DEFAULT_STOP))\n        }\n\n        this.#soundContexts[id] = this.#soundContexts[id].filter((ctx) => ctx.parentId !== context.parentId)\n\n        Timer.setTimeout(\n            () => {\n                if (context.onEnded) {\n                    this.#eventHandler.triggerAudioEvent(EcasEvents.Sound.Ended, id)\n                    callOnEnded(context.onEnded, this.#eventHandler)\n                }\n            },\n            when - this.now(),\n            joinTimeoutCallers(combinedId, TIMEOUT_CALLERS.SOUND_COMPLETE)\n        )\n    }\n\n    /**\n     * Stop a sound source.\n     * @param {string} id Id of sound to stop.\n     * @param {string} parentId Id of sound parent (pattern or pool id).\n     * @param {string} type Type of sound (element or buffer)\n     * @param {ISoundSource} soundSource Source of sound to stop.\n     * @param {string} bussId bus ID of the sound to stop.\n     * @param {number} when Global position when sound should stop.\n     * @private\n     */\n    #stopSoundSource(id: Sound['id'], parentId: Sound['id'], soundSource: ISoundSource, bussId: BusConfig['id'], when = 0) {\n        const combinedId = joinTimeoutCallers(id, parentId)\n\n        const connections = this.#soundConnections[combinedId]\n        const node = soundSource.source as AudioBufferSourceNode\n\n        //Is this just to check if it's really the correct type? Because now it always is\n        const isSoundSourceParams = soundSource && node && node.buffer && node.stop\n\n        const checkEffectAndDisconnect = (connection: ISoundNodes) => {\n            this.#disconnectNodes(connection, id, parentId, soundSource, bussId)\n        }\n\n        //Is soundSource.source enough or do you need to check for just soundSource too?\n        if (isSoundSourceParams) {\n            try {\n                node.stop(when)\n\n                if (connections) {\n                    connections.forEach(checkEffectAndDisconnect)\n                }\n                delete this.#soundConnections[combinedId]\n            }\n\n            catch (err) {\n                logger().error(err)\n            }\n        }\n    }\n\n    #disconnectNodes (connectionNode: ISoundNodes, id: string, parentId: string, soundSource: ISoundSource, bussId: string) {\n        this.removeSound(id, parentId, soundSource, bussId)\n\n        connectionNode.pannerNode.disconnect()\n        connectionNode.gainNode.disconnect()\n        connectionNode.sourceNode.disconnect()\n\n        if (connectionNode.audioEffectNodes) {\n            connectionNode.audioEffectNodes.forEach((effect) => {\n                effect.node.disconnect()\n            })\n        }\n    }\n\n    /**\n     * Get sound contexts for a sound.\n     * @param {string} id Id of sound to find contexts for.\n     * @param {string} parentId Id of parent context (pattern, pool, event or sequence).\n     * @returns {ISoundContext[]}  Array with sound contexts for found sounds.\n     * @private\n     */\n    #getSoundContexts(id: string, parentId: string): ISoundContext[] {\n        const contexts = this.#soundContexts[id]\n        if (!contexts) {\n            return null\n        }\n        return contexts.filter((context: ISoundContext) => context.parentId === parentId)\n    }\n}\n", "import { logger, type LoggerName } from \"@netent-tech/ecas-logger\"\nimport { type PartialProperties } from \"@netent-tech/ecas-utils\"\nimport { getPrefferedFileExtension } from \"../asset-handler/formats\"\nimport { AudioFileExtension, EncoderSettings, FormatPreset, ILoadrConfig, Sound } from \"@netent-tech/ecas-common\"\n\nfunction iOS14() {\n    return typeof(navigator) !== 'undefined'\n        && navigator.userAgent !== undefined\n        && navigator.userAgent.match(/like Mac OS X/) !== null\n        && navigator.userAgent.match(/OS 14/) !== null\n}\nexport class LoadrConfig implements ILoadrConfig {\n    /** @deprecated */\n    forceLegacy = false\n    forcePolyfills = {}\n    packageToUse = \"desktop\"\n    fileExtToUse: AudioFileExtension\n    initState?: string\n    /** true will load all sounds, array of strings will load those specified sounds */\n    preload: boolean | Sound['id'][] = false\n    soundData: Map<string, number> = new Map<string, number>()\n    pauseOnInvisible = true\n    muteOnInvisible = !iOS14()\n    resumeOnVisible = true\n    unmuteOnVisible = true\n    logger: LoggerName = 'none'\n    /**\n     * if these game events where triggered before AudioContext was unlocked, the will fire once it is unlocked.\n     * So if game sends a \"start-main-music\" event before AudioContext could be started (due to no user interaction)\n     * then that event will be queued and fired on the first user interaction.\n     * use true to queue all events\n     * use an array of gameEvent names to queue only those events\n     */\n    queue: true | string[] = true\n    constructor(formatPresets: FormatPreset[], props: PartialProperties<LoadrConfig> & {soundData?: Map<string, number>}= { }) {\n        Object.assign(this, props)\n        this.soundData = new Map(props.soundData)\n        const availableFileExtensions = getAvailableFileExtensions(formatPresets)\n        this.fileExtToUse = props.fileExtToUse || getPrefferedFileExtension(availableFileExtensions)\n        if (!availableFileExtensions.includes(this.fileExtToUse)) {\n            logger().error('[ecas] fileExtToUse:', this.fileExtToUse, 'is not available.')\n        }\n    }\n}\n\n/* To see what files will actually exist after encoding (depending on what the settings were in soundconfig) */\nfunction getAvailableFileExtensions(formatPresets: FormatPreset[]) {\n    const exts = formatPresets.map(\n        formatPreset => formatPreset.presets.map(\n            encoderPreset => encoderPreset.formats.map(\n                encoderSettings => encoderSettings.format))).flat().flat().flat().map(\n        fmt => encoderSettingFormatToFileExtension(fmt))\n    return [...new Set(exts)]\n}\n\nfunction encoderSettingFormatToFileExtension (fmt: EncoderSettings['format']): AudioFileExtension {\n    return `.${fmt}` as AudioFileExtension\n}\n", "import { SoundConfig, EventConfig, IEcasOptions, StateConfig } from \"@netent-tech/ecas-common\"\nimport { LoadrConfig } from \"./LoadrConfig\"\n\n/** Takes partial options and creates defaults for everything that is not defined. */\nexport class EcasOptions implements IEcasOptions {\n    soundConfig: SoundConfig\n    eventConfig: EventConfig\n    stateConfig: StateConfig\n    loadrConfig: LoadrConfig\n\n    constructor (options: IEcasOptions = { soundConfig: new SoundConfig(), loadrConfig: { packageToUse: \"desktop\" } }) {\n        this.soundConfig = new SoundConfig(options.soundConfig)\n        this.eventConfig = options.eventConfig || []\n        this.stateConfig = options.stateConfig || { genesis: { activatesOn: [], deactivatesOn: [], events: {}, children: {}, } }\n        this.loadrConfig = new LoadrConfig(this.soundConfig.settings.formatPresets, options.loadrConfig as Partial<LoadrConfig> & {soundData?: Map<string, number>})\n    }\n}\n\nexport function createEcasOptions(options?: IEcasOptions) {\n    return new EcasOptions(options)\n}\n", "import { noop } from \"@netent-tech/ecas-utils\"\nimport { IPlaySoundArgs, isMusicalPosition } from \"@netent-tech/ecas-common\"\nimport { Utils } from \"../utils\"\n\nexport class PlaySoundArgs implements Required<IPlaySoundArgs> {\n    volume = 1\n    pitch = 0\n    pan = 0\n    /** in seconds */\n    startTime = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    /** in seconds */\n    duration = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    /** in seconds */\n    startPos = 0 //DefaultParameterType<number> | MusicalPosition = 0\n    loop = false\n    args = []\n    onended = noop\n    onplay = noop\n    /** in milliseconds */\n    fadeIn = 0\n    /** in milliseconds */\n    fadeOut = 0\n    reverse = false\n\n    constructor(options: IPlaySoundArgs) {\n        Object.assign(this, options)\n\n        // if these are random arrays we get select a random number from the array\n        this.volume = Utils.randomizeValues(options.volume) ?? 1\n        this.pitch = Utils.randomizeValues(this.pitch) ?? 0\n        this.pan = Utils.randomizeValues(this.pan) ?? 0\n\n        // bar.beat.tick strings is handled in sequencer, so only default numeric time based values..\n        if (!isMusicalPosition(this.startTime)) {\n            this.startTime = Utils.defaultNumber(this.startTime) / 1000\n        }\n        if (!isMusicalPosition(this.duration)) {\n            this.duration = Utils.defaultNumber(this.duration) / 1000\n        }\n        if (!isMusicalPosition(this.startPos)) {\n            this.startPos = Utils.defaultNumber(this.startPos) / 1000\n        }\n    }\n}\n", "import { isNumber } from '@netent-tech/ecas-utils'\nimport { IStopSoundArgs } from \"@netent-tech/ecas-common\"\n\nexport class StopSoundArgs implements Omit<Required<IStopSoundArgs>, \"onEnded\"> {\n    /** in seconds, millisec in ISoptSoundArgs  */\n    delay = 0\n    fadeOut = 1\n    onEnded?: string\n\n    constructor(options: IStopSoundArgs = {}) {\n        if (isNumber(options.fadeOut)) {\n            this.fadeOut = options.fadeOut\n        }\n        if (isNumber(options.delay)) {\n            this.delay = options.delay / 1000\n        }\n        this.fadeOut = Math.max(this.fadeOut, 1)\n        this.onEnded = options.onEnded\n    }\n\n}\n", "export class AnalyserConfig {\n    mode: string\n    minDb: number\n    maxDb: number\n    fftSize: number\n    smoothingTimeConstant: number\n\n    /**\n     * Configure analyzer.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode for more information on parameters.\n     *\n     * @param {string} mode \"frequency\" for capturing frequency domain data, and \"time\" for time domain data.\n     * @param {number} minDb Minimum power value in scaling range when in frequency mode. Value greater than maxDb throws INDEX_SIZE_ERR.\n     * @param {number} maxDb Maximum power value in scaling range when in frequency mode.\n     * @param {number} fftSize Size of the FFT when in frequency mode.\n     * @param {number} smoothingTimeConstant Smooth values over time. Must be in the range 0 to 1.\n     */\n    constructor(mode = \"time\", minDb = -100, maxDb = -30, fftSize = 2048, smoothingTimeConstant = 0.8) {\n        this.mode = mode\n        this.minDb = minDb\n        this.maxDb = maxDb\n        this.fftSize = fftSize\n        this.smoothingTimeConstant = smoothingTimeConstant\n    }\n}\n", "import { noop } from \"@netent-tech/ecas-utils\"\n\ninterface IOverInfo {\n    over: boolean,\n    lastOver: number\n}\n\ninterface IVolumeMeterCallbackData {\n    volume: {\n        left: number,\n        right: number\n    },\n    clipping: {\n        left: boolean,\n        right: boolean\n    }\n}\n\nexport class VolumeMeter {\n    private _callback: (data: IVolumeMeterCallbackData) => void\n    private _volumes: number[] = []\n    private _overInfos: IOverInfo[] = []\n    private _averaging = 0.95\n    // It is custom in audio software to show signals as over when exceeding 1, also when working with busses summed using floating point samples.\n    // However, note that in floating point a value above 1 does not mean a clipped signal, except if the signal reaches the DAC without further scaling (going through another bus like master, or in the OS).\n    private _overLevel = 0.71\n    private _overLag = 750\n    private _processor: ScriptProcessorNode | null\n\n    /**\n     * Create a volume meter.\n     *\n     * @param {number} smoothingTimeConstant Time in seconds for the value to fall back.\n     * @param {Function} callback\n     */\n    constructor(smoothingTimeConstant = 0.6, callback: (data: any) => void = noop) {\n        this._callback = callback\n        this._averaging = smoothingTimeConstant\n        this._init()\n    }\n\n    create(ctx: AudioContext) {\n        this._processor = ctx.createScriptProcessor(512)\n        this._processor.onaudioprocess = this._volumeAudioProcess.bind(this)\n        this._processor.connect(ctx.destination)\n        return this._processor\n    }\n\n    destroy() {\n        if (this._processor !== null) {\n            this._processor.disconnect()\n            this._processor.onaudioprocess = null\n            this._processor = null\n        }\n        this._volumes = []\n        this._overInfos = []\n    }\n\n    private _init() {\n        this._volumes = [0, 0]\n        this._overInfos = [{over: false, lastOver: 0}, {over: false, lastOver: 0}]\n    }\n\n    private _volumeAudioProcess(event: AudioProcessingEvent) {\n        const lastL = this._volumes[0]\n        const lastR = this._volumes[1]\n        this._volumes[0] = 0\n        this._volumes[1] = 0\n        const processChannel = (input: AudioBuffer, index: number) => {\n            const buffer: Float32Array = input.getChannelData(index)\n            const bufferLength = buffer.length\n            if ((this._overInfos[index].lastOver + this._overLag) < window.performance.now()) {\n                this._overInfos[index].over = false\n            }\n            const squaredSum = buffer.reduce((a, b) => a + b * b)\n            const frameVal = Math.sqrt(squaredSum / bufferLength)\n            if (frameVal >= this._overLevel) {\n                this._overInfos[index].over = true\n                this._overInfos[index].lastOver = window.performance.now()\n            }\n            this._volumes[index] = (this._averaging > 0) ? Math.max(frameVal, this._volumes[index] * this._averaging) : frameVal\n        }\n        processChannel(event.inputBuffer, 0)\n        processChannel(event.inputBuffer, 1)\n        const currL = this._volumes[0]\n        const currR = this._volumes[1]\n        if ((lastL !== currL || lastR !== currR) && currL >= 0 && currR >= 0) {\n            this._callback({\n                volume: {left: currL, right: currR},\n                clipping: {left: this._overInfos[0].over, right: this._overInfos[1].over},\n            })\n        }\n    }\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { defineProperty, hasOwnProperty } from \"@netent-tech/ecas-utils\"\n\ntype LegacyAudioParam = Omit<AudioParam, \"cancelAndHoldAtTime\" | \"automationRate\">\n\ntype LegacyAudioParamVar = {\n    new (): LegacyAudioParam\n    prototype: LegacyAudioParam\n}\n\n\nexport function audioParamPolyfill(global: {\n    AudioParam?: LegacyAudioParamVar,\n}) {\n    const paramPrototype = global.AudioParam.prototype\n    if (!hasOwnProperty(paramPrototype, 'cancelAndHoldAtTime') && hasOwnProperty(paramPrototype, \"cancelScheduledValues\")) {\n        logger().debug(\"[polyfill]: (AudioParam) installing cancelAndHoldAtTime\")\n        defineProperty(paramPrototype, \"cancelAndHoldAtTime\", {value: paramPrototype.cancelScheduledValues})\n    }\n\n    /** This doesnt actually make the rate anything but won't give you error when trying to set the rate */\n    if (!hasOwnProperty(paramPrototype, 'automationRate')) {\n        logger().debug(\"[polyfill]: (AudioParam) installing automationRate\")\n        defineProperty(paramPrototype, \"automationRate\", {value: \"a-rate\"}) // \"a-rate\" | \"k-rate\"\n    }\n}\n", "import { ignoreUnused } from \"@netent-tech/ecas-utils\"\nimport { defineProperty, hasOwnProperty } from '@netent-tech/ecas-utils'\n\nexport function stereoPannerNodePolyfill(global = window) {\n    const prototype = global.AudioContext.prototype\n    class StereoPannerNodeMockup {\n        _input: GainNode\n        _output: GainNode\n        context: BaseAudioContext\n        pan: AudioParam\n        channelCount = 2\n        channelCountMode: ChannelCountMode = \"clamped-max\"\n        channelInterpretation: ChannelInterpretation = \"speakers\"\n        numberOfInputs = 1\n        numberOfOutputs = 1\n        addEventListener = () => void 0\n        dispatchEvent = () => void 0\n        removeEventListener = () => void 0\n        constructor(context: AudioContext, options: StereoPannerOptions = { pan: 0 }) {\n            this.context = context\n            this._input = this.context.createGain()\n            this._output = this.context.createGain()\n            let panValue = options.pan\n            const splitter = this.context.createChannelSplitter(2)\n            const gainL1 = this.context.createGain()\n            const gainL2 = this.context.createGain()\n            const gainR1 = this.context.createGain()\n            const gainR2 = this.context.createGain()\n            const mergerL = this.context.createChannelMerger(2)\n            const mergerR = this.context.createChannelMerger(2)\n            const merger = this.context.createChannelMerger(2)\n            this._input.connect(splitter)\n            splitter.connect(gainL1, 0)\n            splitter.connect(gainL2, 0)\n            splitter.connect(gainR1, 1)\n            splitter.connect(gainR2, 1)\n            gainL1.connect(mergerL, 0, 0)\n            gainR2.connect(mergerL, 0, 0)\n            gainR1.connect(mergerR, 0, 1)\n            gainL2.connect(mergerR, 0, 1)\n            mergerL.connect(merger, 0, 0)\n            mergerR.connect(merger, 0, 1)\n            merger.connect(this._output)\n            this.pan = {\n                get value() {\n                    return panValue\n                },\n                set value(value) {\n                    gainL1.gain.value = 1 - Math.max(value, 0)\n                    gainR2.gain.value = -Math.min(value, 0)\n                    gainR1.gain.value = 1 + Math.min(value, 0)\n                    gainL2.gain.value = Math.max(value, 0)\n                    panValue = value\n                },\n                get automationRate () {\n                    return \"a-rate\" as const\n                },\n                get defaultValue() {\n                    return 0\n                },\n                get maxValue() {\n                    return 1\n                },\n                get minValue() {\n                    return 0\n                },\n                cancelAndHoldAtTime: (cancelTime: number) => {\n                    ignoreUnused(cancelTime)\n                    return this.pan\n                },\n                cancelScheduledValues: (cancelTime: number) => {\n                    ignoreUnused(cancelTime)\n                    return this.pan\n                },\n                exponentialRampToValueAtTime: (value: number, endTime: number) => {\n                    ignoreUnused(endTime)\n                    this.pan.value = value\n                    return this.pan\n                },\n                linearRampToValueAtTime: (value: number, endTime: number) => {\n                    ignoreUnused(endTime)\n                    this.pan.value = value\n                    return this.pan\n                },\n                setTargetAtTime: (target: number, startTime: number, timeConstant: number) => {\n                    ignoreUnused(startTime, timeConstant)\n                    this.pan.value = target\n                    return this.pan\n                },\n                setValueAtTime: (target: number, startTime: number) => {\n                    ignoreUnused(startTime)\n                    this.pan.value = target\n                    return this.pan\n                },\n                setValueCurveAtTime: (values: number[] | Float32Array, startTime: number, duration: number) => {\n                    ignoreUnused(startTime, duration)\n                    this.pan.value = Number(values[0])\n                    return this.pan\n                },\n            }\n            this.pan.value = panValue\n        }\n        isStereoPannerNode = true\n\n        connect(...args: any): any {\n            return this._output.connect.apply(this._output, args)\n        }\n        disconnect(...args: any): any {\n            return this._output.disconnect.apply(this._output, args)\n        }\n        toString() {\n            return \"StereoPannerNode\" as const\n        }\n\n    }\n\n    function createStereoPannerNode(ctx: AudioContext, options?: StereoPannerOptions) {\n        return new StereoPannerNodeMockup(ctx, options)\n    }\n\n    defineProperty(prototype, \"createStereoPanner\", {\n        value: function (this: AudioContext, options?: StereoPannerOptions) {\n            return createStereoPannerNode(this, options)\n        },\n        // enumerable: false, writable: false, configurable: true\n    })\n\n    const _connect = global.AudioNode.prototype.connect as Connect\n\n    defineProperty(global.AudioNode.prototype, \"connect\", {value: function (destination: AudioNode | AudioParam, output?: number, input?: number) {\n        function isStereoPannerNode (thing: object): thing is StereoPannerNodeMockup {\n            return hasOwnProperty(thing, \"isStereoPannerNode\") && thing.isStereoPannerNode === true\n        }\n        if (isStereoPannerNode(destination)) {\n            destination = destination._input\n        }\n        return _connect.call(this, destination, output || 0, input || 0)\n    }})\n\n}\ntype Connect = ((destination: AudioNode | AudioParam, output?: number, input?: number) => AudioNode | void)\n", "import { defineProperty, hasOwnProperty } from \"@netent-tech/ecas-utils\"\n/** Converted to typescript by joel */\n\n/* Copyright 2013 Chris Wilson\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\n\n/*\nThis monkeypatch library is intended to be included in projects that are\nwritten to the proper AudioContext spec (instead of webkitAudioContext),\nand that use the new naming and proper bits of the Web Audio API (e.g.\nusing BufferSourceNode.start() instead of BufferSourceNode.noteOn()), but may\nhave to run on systems that only support the deprecated bits.\nThis library should be harmless to include if the browser supports\nunprefixed \"AudioContext\", and/or if it supports the new names.\nThe patches this library handles:\nif window.AudioContext is unsupported, it will be aliased to webkitAudioContext().\nif AudioBufferSourceNode.start() is unimplemented, it will be routed to noteOn() or\nnoteGrainOn(), depending on parameters.\nThe following aliases only take effect if the new names are not already in place:\nAudioBufferSourceNode.stop() is aliased to noteOff()\nAudioContext.createGain() is aliased to createGainNode()\nAudioContext.createDelay() is aliased to createDelayNode()\nAudioContext.createScriptProcessor() is aliased to createJavaScriptNode()\nAudioContext.createPeriodicWave() is aliased to createWaveTable()\nOscillatorNode.start() is aliased to noteOn()\nOscillatorNode.stop() is aliased to noteOff()\nOscillatorNode.setPeriodicWave() is aliased to setWaveTable()\nAudioParam.setTargetAtTime() is aliased to setTargetValueAtTime()\nThis library does NOT patch the enumerated type changes, as it is\nrecommended in the specification that implementations support both integer\nand string types for AudioPannerNode.panningModel, AudioPannerNode.distanceModel\nBiquadFilterNode.type and OscillatorNode.type.\n*/\ntype WebkitAudioContext = Omit<AudioContext, \"createGain\" | \"createDelay\" | \"createScriptProcessor\" | \"createPeriodicWave\"> & {\n    createGainNode: typeof AudioContext.prototype.createGain,\n    createDelayNode: typeof AudioContext.prototype.createDelay,\n    createJavaScriptNode: typeof AudioContext.prototype.createScriptProcessor,\n    createWaveTable: typeof AudioContext.prototype.createPeriodicWave\n}\n\ntype WebkitAudioContextVar = {\n    new (contextOptions?: AudioContextOptions): WebkitAudioContext;\n    prototype: WebkitAudioContext\n}\n\nexport function webkitAudioContextPolyfill(global: {\n    webkitAudioContext?: WebkitAudioContextVar,\n    AudioContext?: typeof AudioContext,\n}) {\n    if (!global.webkitAudioContext) {\n        throw Error(\"[polyfill]: cannot install webkitAudioContext polyfill since webkitAudioContext does not exist on global.\")\n    }\n    function fixSetTarget(param?: AudioParam & { setTargetValueAtTime?: AudioParam['setTargetAtTime'] }) {\n        if (!param) {\n            return\n        }\n        if (!param.setTargetAtTime) {\n            defineProperty(param, \"setTargetAtTime\", { value: param.setTargetValueAtTime })\n        }\n    }\n\n    const prototype = global.webkitAudioContext.prototype\n\n    if (!hasOwnProperty(prototype, 'createScriptProcessor')) {\n        defineProperty(prototype, \"createScriptProcessor\", { value: prototype.createJavaScriptNode } as const)\n    }\n    if (!hasOwnProperty(prototype, 'createPeriodicWave')) {\n        defineProperty(prototype, \"createPeriodicWave\", { value: prototype.createWaveTable } as const)\n    }\n    if (!hasOwnProperty(prototype, 'createGain')) {\n        defineProperty(prototype, \"createGain\", { value: function(this: typeof prototype) {\n            const node = this.createGainNode()\n            fixSetTarget(node.gain)\n            return node\n        }})\n    }\n\n    if (!hasOwnProperty(prototype, 'createDelay')) {\n        defineProperty(prototype, \"createDelay\", {\n            value: function(this: typeof prototype, maxDelayTime?: number) {\n                const node = this.createDelayNode(maxDelayTime)\n                fixSetTarget(node.delayTime)\n                return node\n            }\n        })\n    }\n\n    defineProperty(prototype, \"internal_createBufferSource\", { value: prototype.createBufferSource })\n    prototype.createBufferSource = function() {\n        const node = this.internal_createBufferSource() as AudioBufferSourceNode & {\n            noteGrainOn: AudioBufferSourceNode['start']\n            noteOn: AudioBufferSourceNode['start']\n            noteOff: AudioBufferSourceNode['stop']\n        }\n        if (!node.start) {\n            node.start = function(when?, offset?, duration?) {\n                if (offset || duration)\n                    this.noteGrainOn(when || 0, offset, duration)\n                else\n                    this.noteOn(when || 0)\n            }\n        }\n        else {\n            defineProperty(node, \"internal_start\", {value: node.start})\n            node.start = function(when?, offset?, duration?) {\n                node.internal_start(when || 0, offset || 0, duration)\n            }\n        }\n        if (!node.stop) {\n            node.stop = function(when?) {\n                this.noteOff(when || 0 )\n            }\n        }\n        else {\n            defineProperty(node, \"internal_stop\", {value: node.stop})\n            node.stop = function(when?) {\n                node.internal_stop(when || 0)\n            }\n        }\n        fixSetTarget(node.playbackRate)\n        return node\n    }\n\n    defineProperty(prototype, \"internal_createDynamicsCompressor\", {value: prototype.createDynamicsCompressor})\n    prototype.createDynamicsCompressor = function() {\n        const node = this.internal_createDynamicsCompressor()\n        fixSetTarget(node.threshold)\n        fixSetTarget(node.knee)\n        fixSetTarget(node.ratio)\n        fixSetTarget(node.reduction as unknown as AudioParam) // not sure if this should be done ^^\n        fixSetTarget(node.attack)\n        fixSetTarget(node.release)\n        return node\n    }\n\n    defineProperty(prototype, \"internal_createBiquadFilter\", {value: prototype.createBiquadFilter})\n    prototype.createBiquadFilter = function() {\n        const node = this.internal_createBiquadFilter()\n        fixSetTarget(node.frequency)\n        fixSetTarget(node.detune)\n        fixSetTarget(node.Q)\n        fixSetTarget(node.gain)\n        return node\n    }\n\n    if (hasOwnProperty(prototype, 'createOscillator' )) {\n        defineProperty(prototype, \"internal_createOscillator\", {value: prototype.createOscillator})\n        prototype.createOscillator = function() {\n            const node = this.internal_createOscillator() as OscillatorNode & {\n                noteOn: OscillatorNode['start']\n                noteOff: OscillatorNode['stop']\n                setWaveTable: OscillatorNode['setPeriodicWave']\n            }\n            if (!node.start) {\n                node.start = function (when?) {\n                    this.noteOn(when || 0)\n                }\n            }\n            else {\n                defineProperty(node, \"internal_start\", {value: node.start})\n                node.start = function (when?) {\n                    node.internal_start(when || 0)\n                }\n            }\n            if (!node.stop) {\n                node.stop = function (when?) {\n                    this.noteOff(when || 0)\n                }\n            }\n            else {\n                defineProperty(node, \"internal_stop\", {value: node.stop})\n                node.stop = function(when?) {\n                    node.internal_stop(when || 0)\n                }\n            }\n            if (!node.setPeriodicWave)\n                node.setPeriodicWave = node.setWaveTable\n            fixSetTarget(node.frequency)\n            fixSetTarget(node.detune)\n            return node\n        }\n    }\n\n    // decodeAudioData is a promise nowadays\n    defineProperty(prototype, \"internal_decodeAudioData\", {value: prototype.decodeAudioData})\n    prototype.decodeAudioData = function(audioData: ArrayBuffer, successCallback?: DecodeSuccessCallback, errorCallback?: DecodeErrorCallback ) {\n        return new Promise<AudioBuffer>((resolve, reject) => {\n            this.internal_decodeAudioData(\n                audioData,\n                (decodedData) => {\n                    successCallback && successCallback(decodedData)\n                    resolve(decodedData)\n                },\n                (error) => {\n                    errorCallback && errorCallback(error)\n                    reject(error)\n                }\n            )\n        })\n    }\n\n    defineProperty(global, \"AudioContext\", {value: global.webkitAudioContext})\n\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { defineProperty, trySync } from \"@netent-tech/ecas-utils\"\nimport { audioParamPolyfill } from \"./audio-param-polyfill\"\nimport { stereoPannerNodePolyfill } from \"./stereo-panner-node-polyfill\"\nimport { webkitAudioContextPolyfill } from \"./webkit-audio-context-polyfill\"\n\nexport interface IForcePolyfill {\n    AudioParam?: boolean\n    webkitAudioContext?: boolean\n    webkitOfflineAudioContext?: boolean\n    createStereoPanner?: boolean\n}\n\nfunction install(Force: IForcePolyfill, global = window) {\n\n    \n    const Has = {\n        AudioParam: 'AudioParam' in global,\n        AudioContext: 'AudioContext' in global,\n        OfflineAudioContext: 'OfflineAudioContext' in global,\n        webkitAudioContext: 'webkitAudioContext' in global,\n        webkitOfflineAudioContext: 'webkitOfflineAudioContext' in global,\n        createStereoPanner: (\n            'AudioContext' in global && \"createStereoPanner\" in global.AudioContext.prototype\n        ) || 'webkitAudioContext' in global && 'createStereoPanner' in (global as any)['webkitAudioContext']\n    } as const\n\n    const ShouldInstall: IForcePolyfill = {\n        AudioParam: Force.AudioParam || Has.AudioParam,\n        webkitAudioContext: Force.webkitAudioContext || Has.webkitAudioContext && !Has.AudioContext,\n        webkitOfflineAudioContext: Force.webkitOfflineAudioContext || Has.webkitOfflineAudioContext && !Has.OfflineAudioContext,\n        createStereoPanner: Force.createStereoPanner || !Has.createStereoPanner,\n    } as const\n\n    logger().debug(\"[polyfill]:\", Has)\n\n    const tryer = (cb: (global: typeof window) => void) => {\n        const [error, ] = trySync(cb)(global)\n        if (error) {\n            logger().error(error)\n        }\n        return !error\n    }\n\n    const DidInstall: IForcePolyfill = {\n        // needs to have at least legacy AudioParam for us to be able to install\n        AudioParam: ShouldInstall.AudioParam && tryer(() => {\n            logger().debug(\"[polyfill]: installing AudioParam\")\n            audioParamPolyfill(global)\n        }),\n        webkitAudioContext: ShouldInstall.webkitAudioContext && tryer(() => {\n            logger().debug(\"[polyfill]: installing webkitAudioContext\")\n            webkitAudioContextPolyfill(global)\n        }),\n        webkitOfflineAudioContext: ShouldInstall.webkitOfflineAudioContext && tryer(() => {\n            logger().debug(\"[polyfill]: installing webkitOfflineAudioContext\")\n            defineProperty(global, \"OfflineAudioContext\", {value: global['webkitOfflineAudioContext']})\n        }),\n        createStereoPanner: ShouldInstall.createStereoPanner && tryer(() => {\n            logger().debug(\"[polyfill]: installing createStereoPanner\")\n            stereoPannerNodePolyfill(global)\n        }),\n    }\n\n    return DidInstall\n}\nexport { install }\n\n", "import { IForcePolyfill, install } from \"./install\"\n\nexport function polyfill(force: IForcePolyfill = {}) {\n    return install(force)\n}\n", "import { ISoundContext } from \"@netent-tech/ecas-common\"\nimport {isNumber} from '@netent-tech/ecas-utils'\n\nexport class AudioScheduler {\n    private _timeProvider: () => number\n    private _interval: number\n    private _intervalId: number\n    private _scheduled: IScheduled[] = []\n\n    constructor(timeProvider: () => number, interval = 0.03) {\n        this._timeProvider = timeProvider\n        this._interval = interval\n        this._intervalId = window.setInterval(this._update.bind(this), interval * 1000)\n    }\n\n    get intervalId() {\n        return this._intervalId\n    }\n\n    public scheduleSound(soundContext: ISoundContext, callback?: (id: string, context: ISoundContext) => void) {\n        this._scheduled.push({context: soundContext, callback})\n        this._update()\n    }\n\n    public cancelScheduledSound(soundContext: ISoundContext) {\n        this._scheduled = this._scheduled\n            .filter((scheduled) => !(scheduled.context.id === soundContext.id && scheduled.context.parentId === soundContext.parentId))\n    }\n\n    /** event loop, if the time until the event is less than the interval, the callback is executed */\n    private _update() {\n        const now = this._timeProvider()\n        this._scheduled = this._scheduled.filter((scheduled: IScheduled) => {\n            const ctx = scheduled.context\n            ctx.startTimeSeconds = isNumber(ctx.startTimeSeconds) ? ctx.startTimeSeconds : 0\n            const timeUntilEvent = ctx.startTimeSeconds - now\n            if (timeUntilEvent <= this._interval) {\n                scheduled.callback(ctx.id, ctx)\n                return false\n            }\n            return true\n        })\n    }\n}\n\ninterface IScheduled {\n    context: ISoundContext;\n    callback: (id: string, context: ISoundContext) => void;\n}\n", "import { ITempoConfig } from \"@netent-tech/ecas-common\"\n\nexport function calculateSecondsPerBeat(tempoConfig: ITempoConfig): number {\n    return 60 / (tempoConfig.tempo / ((1 / tempoConfig.timeSignature.unit) * 4))\n}\n", "import { logger } from \"@netent-tech/ecas-logger\"\nimport { clone, exists, isFunction, isNumber, isNumeric, isString, isUndefined, noop, Writeable } from \"@netent-tech/ecas-utils\"\nimport { AssetHandler } from \"../asset-handler\"\nimport { DEFAULT_CROSSFADE_MILLISECONDS, TIMEOUT_CALLERS, TIME_LOOKAHEAD_SECONDS } from \"../constants\"\nimport { EnvelopePreset, IPlayPatternArgs, IPlayPoolArgs, IPoolMap, ISequenceEvent, ISoundContext, ISoundsConfig, IStringMap, ITempoConfig, ITimeSignature, MusicalPositionOrNumber, Pattern, Pool, PoolItem, Sound } from \"@netent-tech/ecas-common\"\nimport { createPlayEnvelopeArgs, EnvelopeContext, isPlayEnvelopeArgs, PlayEnvelopeArgs } from \"../envelopes\"\nimport { EventHandler } from \"../event-handler\"\nimport { Mixer } from \"../mixer\"\nimport { EcasOptions } from \"../options-creator\"\nimport { PlaySoundArgs } from \"../options-creator/PlaySoundArgs\"\nimport { StopSoundArgs } from \"../options-creator/StopSoundArgs\"\nimport { AudioScheduler } from \"../scheduling/AudioScheduler\"\nimport { createTimeoutCallerForPlayEnvelope, joinTimeoutCallers } from \"../scheduling/timeouts\"\nimport { Timer } from \"../scheduling/Timer\"\nimport { Utils } from \"../utils\"\nimport { createTimeSignatureFromString } from \"../utils/beats\"\nimport { calculateSecondsPerBeat as milliSecondsPerBeatFromTempoConfig } from \"./tempo\"\n\nexport class Sequencer {\n    #audioScheduler: AudioScheduler\n    #patternItemsCompleted: IStringMap<number>\n    #eventQueue: ISequenceEvent[]\n    #poolQueue: IStringMap<PoolItem[]>\n    #poolPointer: IStringMap<number>\n    #poolCounter: IStringMap<IPoolMap>\n    #playingSoundsPerGroup: IStringMap<ISoundContext[]>\n    /** A map with <Sound['id'], currently playing instances of that sound> */\n    #currentlyPlayingSoundInstancesWithThisSoundId: IStringMap<ISoundContext[]>\n    #playingSoundsPerPool: IStringMap<string[]>\n    #playingPoolItems: IStringMap<PoolItem[]>\n    #playingPatternItems: IStringMap<Pattern[]>\n    #playingPools: IStringMap<number>\n    #pausedPools: IStringMap<boolean>\n    #pausedPatterns: IStringMap<boolean>\n    #playingPatternArgs: IStringMap<IPlayPatternArgs>\n    #playingPoolArgs: IStringMap<IPlayPoolArgs>\n    #scheduledSoundContexts: IStringMap<ISoundContext>\n    #triggerLimitPerGroup: IStringMap<number>\n    #triggerLimitPerSoundSeconds: IStringMap<number>\n    //#scheduledGrouplimitFadesSeconds: IStringMap<number>\n\n    #timeOutIdCounter = new Map<string, number>()\n\n    #options: EcasOptions\n    #mixer: Mixer\n    #eventHandler: EventHandler\n    #assetHandler: AssetHandler\n\n    #tempoConfig: ITempoConfig = {timeSignature: {meter: 4, unit: 4}, triggerQuantize: 1}\n\n    /**\n     * @param {ECASContext} context Context object with configuration.\n     * @param {Function} initCallback Callback invoked when setup of mixer is complete of fails.\n     */\n    constructor (\n        options: EcasOptions,\n        mixer: Mixer,\n        eventHandler: EventHandler,\n        assetHandler: AssetHandler,\n    ) {\n        this.#mixer = mixer\n        this.#eventHandler = eventHandler\n        this.#assetHandler = assetHandler\n\n        this.#patternItemsCompleted = {}\n        this.#eventQueue = []\n        this.#playingSoundsPerGroup = {}\n        this.#currentlyPlayingSoundInstancesWithThisSoundId = {}\n        this.#playingSoundsPerPool = {}\n        this.#playingPoolItems = {}\n        this.#playingPatternItems = {}\n        this.#playingPools = {}\n        this.#pausedPools = {}\n        this.#pausedPatterns = {}\n        this.#playingPatternArgs = {}\n        this.#playingPoolArgs = {}\n        this.#triggerLimitPerGroup = {}\n        this.#scheduledSoundContexts = {}\n        this.#triggerLimitPerSoundSeconds = {}\n        //this.#scheduledGrouplimitFadesSeconds = {}\n\n        this.#options = options\n        this.#tempoConfig = {\n            triggerQuantize: options.soundConfig.settings.triggerQuantize,\n            timeSignature: {\n                meter: 4,\n                unit: 4\n            }\n        }\n        this.#audioScheduler = new AudioScheduler(this.#mixer.now.bind(this.#mixer), TIME_LOOKAHEAD_SECONDS)\n        this.#setupPools(this.#options.soundConfig.pools)\n        setInterval(this.#onUpdate.bind(this), TIME_LOOKAHEAD_SECONDS)\n    }\n\n    setTempo(newTempo: number) {\n        this.#tempoConfig.tempo = newTempo\n    }\n\n    setTimeSignature(newTimeSignature: ITimeSignature) {\n        this.#tempoConfig.timeSignature = newTimeSignature\n    }\n\n    setTriggerQuantize(newTriggerQuantize: number) {\n        this.#tempoConfig.triggerQuantize = newTriggerQuantize\n    }\n\n    /**\n     * Used to trigger a sound.\n     *\n     * @param {string} id Id of sound to trigger.\n     * @param {IPlaySoundArgs} playSoundArgs Arguments to pass when playing sound.\n     * @param {string} parentId Id of parent playing sound (pattern or pool).\n     * @param {boolean} isTimeRelative If true, startTime is not including current time.\n     * @param {boolean} isScheduled If true, treat as scheduled looped sound (will loop even if args.loop is false)\n     */\n    playSound(id: string, playSoundArgs: PlaySoundArgs, parentId = id, isTimeRelative = true, isScheduled = false) {\n        logger().debug(\n            '[ecas] play sound',\n            'id:', id,\n            'args:', playSoundArgs,\n            'parent:', parentId,\n            'relativeTime:', isTimeRelative,\n            'isScheduled:', isScheduled\n        )\n\n        const nowSeconds = this.#mixer.now()\n\n        // duration and startime is in seconds here\n        const { volume, pan, loop, pitch, reverse, duration: durationArgSeconds, startPos, startTime: startTimeSeconds, args } = playSoundArgs\n\n        const newStartTimeSeconds = isTimeRelative\n            ? startTimeSeconds + nowSeconds\n            : startTimeSeconds\n\n        const delaySeconds = Math.max(newStartTimeSeconds - nowSeconds, 0)\n        const shouldPlayLater = delaySeconds >= TIME_LOOKAHEAD_SECONDS\n\n        // Perhaps we run this method schedule this method proper at a later time if should play later.\n        if (shouldPlayLater) {\n            if (!this.#timeOutIdCounter.has(id)) {\n                this.#timeOutIdCounter.set(id, 0)\n            }\n            this.#timeOutIdCounter.set(id, this.#timeOutIdCounter.get(id) + 1)\n\n            Timer.setTimeout(\n                () => {\n                    playSoundArgs.startTime = newStartTimeSeconds\n                    const isTimeRelativeFalse = false as const\n                    this.playSound(id, playSoundArgs, parentId, isTimeRelativeFalse)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS, // we checked that delaySeconds >= TIME_LOOKAHEAD_SECONDS so will not be negative\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    this.#timeOutIdCounter.get(id).toString()\n                )\n            )\n            return\n        }\n\n        const sound = this.#assetHandler.soundHandler.getSound(id)\n        const groupId = sound.group\n        const type = sound.type\n        const bussId = this.#assetHandler.getGroup(groupId).bus\n        const playbackRate = Utils.pitchToPlaybackRate(pitch)\n        const soundFileDuration = this.#assetHandler.soundHandler.getDurationSeconds(id)\n        const soundFiledurationAdjustedForPlaybackRateSeconds = (soundFileDuration - startPos) / playbackRate\n        const stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound = joinTimeoutCallers(\n            id,\n            \"\",\n            TIMEOUT_CALLERS.STOP\n        )\n        let finalDurationSeconds = soundFiledurationAdjustedForPlaybackRateSeconds\n\n        if (durationArgSeconds > 0) {\n            finalDurationSeconds = durationArgSeconds\n        }\n\n        if(Timer.hasTimeout(stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound)) Timer.clearTimeout(stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound)\n\n        // first we clear timeout and stop sound, then we stop sound again?\n        this.#clearTimeoutAndStopSound(id, parentId)\n\n        // determine if same sound triggers more than group limit vallue defined.\n        // if same sound triggers and exceeds the groupLimit, then stop that sound and play again.\n        // Determine if same sound is playing in the background and hasnt been stopped.\n        // If so, stop previous sound and play again\n        const soundContext: ISoundContext = {\n            id,\n            bussId,\n            volume,\n            pan,\n            isPaused: false,\n            isLoop: loop,\n            type,\n            startTimeSeconds: newStartTimeSeconds,\n            durationSeconds: finalDurationSeconds,\n            startPos,\n            currentTime: 0,\n            parentId,\n            group: this.#assetHandler.getGroup(groupId),\n            onEnded: () => this.#callOnEnded(playSoundArgs.onended),\n            onSourceNodeEnded: () => {\n                const groupSoundItems = this.#playingSoundsPerGroup[groupId]\n                const index = groupSoundItems.map(item => item.id).indexOf(id)\n                    \n                groupSoundItems.splice(index, 1)\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id].shift()\n            },\n            delaySeconds,\n            pitch,\n            playbackRate,\n            reverse,\n            args: args,\n            fadeIn: playSoundArgs.fadeIn,\n            fadeOut: playSoundArgs.fadeOut,\n            isScheduled: isScheduled,\n        }\n\n        this.#handleTriggerLimits(sound, id)\n        this.#mixer.connectSound(null, id, soundContext)\n        this.#scheduledSoundContexts[id + parentId] = soundContext\n\n        this.#audioScheduler.scheduleSound(\n            soundContext,\n            () => {\n                const onplay = [playSoundArgs.onplay]\n                const shouldFadeIn = playSoundArgs.fadeIn > 0\n\n                if (shouldFadeIn) {\n                    const context = new EnvelopeContext({\n                        curveType: \"s-curve\",\n                        startTime: nowSeconds,\n                        isAFadeIn: true,\n                        param: \"volume\",\n                        type: \"sound\",\n                        envelopePoints: [\n                            { pos: 0, val: 0 },\n                            { pos: playSoundArgs.fadeIn, val: playSoundArgs.volume }\n                        ]\n                    })\n                    const fadeinCallback = () => {\n                        this.#mixer.playEnvelope(id, context)\n                    }\n\n                    onplay.push(fadeinCallback)\n                }\n\n                const shouldStop = finalDurationSeconds < soundFiledurationAdjustedForPlaybackRateSeconds && !loop\n\n                if (shouldStop) {\n                    const stopCallback = () => {\n                        const isDefaultStop = true as const\n                        this.stopSound(\n                            id,\n                            new StopSoundArgs({\n                                delay: finalDurationSeconds * 1000 - playSoundArgs.fadeOut,\n                                fadeOut: playSoundArgs.fadeOut\n                            }),\n                            parentId,\n                            isDefaultStop,\n                        )\n                    }\n\n                    // add a fadeout to be triggered with delay, after sound has started playing\n                    onplay.push(stopCallback)\n                }\n\n                this.#playScheduledContext(\n                    sound,\n                    soundContext,\n                    nowSeconds,\n                    onplay,\n                )\n            }\n        )\n    }\n\n    #clearTimeoutAndStopSound (id: string, parentId: string) {\n        const overlappingTimeoutCallers = [\n            joinTimeoutCallers(id, parentId, TIMEOUT_CALLERS.STOP),\n            joinTimeoutCallers(id, TIMEOUT_CALLERS.VOLUME, parentId, TIMEOUT_CALLERS.STOP),\n        ]\n\n        for (const caller of overlappingTimeoutCallers) {\n            if (Timer.hasTimeout(caller)) {\n                Timer.clearTimeout(caller)\n                this.stopSound(\n                    id,\n                    new StopSoundArgs(),\n                    parentId\n                )\n            }\n        }\n    }\n\n    #handleTriggerLimits (sound: Sound, id: string) {\n        const groupId = sound.group\n        const group = this.#assetHandler.getGroup(groupId)\n\n        if (group.limit > 0 && this.#playingSoundsPerGroup[groupId]) {\n            const groupSoundItems = this.#playingSoundsPerGroup[groupId]\n            const playingSoundInstances = this.#currentlyPlayingSoundInstancesWithThisSoundId[id]\n            const isCrossedLimit = groupSoundItems.length >= group.limit\n\n            if (isCrossedLimit) {\n                const first: ISoundContext = groupSoundItems[0]\n\n                if (first.soundSource.source) {\n                    groupSoundItems.shift()\n                    playingSoundInstances.shift()\n                    Timer.clearTimeout(createTimeoutCallerForPlayEnvelope({targetId: id, param: \"volume\", parentId: id, willStopSoundOnEnded: true}))\n\n                    if (first.isFadingOut) return\n\n                    else {\n                        (first.soundSource.source as AudioBufferSourceNode).onended = noop;\n                        (first.soundSource.source as AudioBufferSourceNode).stop()\n                        return\n                    }\n                }\n            }\n\n            //Does it ever reach this? Should it?\n            else if (\n                this.#currentlyPlayingSoundInstancesWithThisSoundId &&\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] &&\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id].length >= group.limit\n            ) {\n                const first = playingSoundInstances[0]\n\n                groupSoundItems.shift()\n                playingSoundInstances.shift();\n\n                (first.soundSource.source as AudioBufferSourceNode).onended = noop;\n                (first.soundSource.source as AudioBufferSourceNode).stop()\n            }\n        }\n    }\n\n    /**\n     * Adds the connected sound context to schedule list\n     *\n     * @param {ISound} sound Sound that was connected through the mixer.\n     * @param {ISoundContext} soundContext The context that the sound was connected and scheduled.\n     * @param {IConnection} connection The resulting connection reported by the mixer.\n     * @returns void\n     */\n    #playScheduledContext(sound: Sound, soundContext: ISoundContext, whenSeconds: number, onplay = [noop]) {\n        this.#scheduledSoundContexts[soundContext.id + soundContext.parentId] = null\n\n        const id = soundContext.id\n        const group = soundContext.group\n        const groupId = group.id\n        const delaySeconds = Utils.defaultNumber(soundContext.delaySeconds)\n\n        if (group.triggerLimit) {\n            const lastGroupTriggerLimitPos = this.#triggerLimitPerGroup[groupId] ? this.#triggerLimitPerGroup[groupId] : 0\n\n            const triggerLimitElapsedSeconds = this.#mixer.now() - lastGroupTriggerLimitPos\n            const triggerLimitRemainingSeconds = group.triggerLimit / 1000 - triggerLimitElapsedSeconds\n\n            if (triggerLimitElapsedSeconds < 0 || triggerLimitRemainingSeconds > 0) {\n                logger().debug(\n                    \"[ecas] group triggerLimit reached\",\n                    \"triggerLimitElapsed\", triggerLimitElapsedSeconds,\n                    \"triggerLimitRemain\", triggerLimitRemainingSeconds\n                )\n                return\n            }\n\n            this.#triggerLimitPerGroup[groupId] = whenSeconds + delaySeconds\n        }\n\n        if (sound.triggerLimit) {\n            const lastSoundTriggerLimitPos = this.#triggerLimitPerSoundSeconds[id] ? this.#triggerLimitPerSoundSeconds[id] : 0\n            const triggerLimitElapsedSeconds = whenSeconds - lastSoundTriggerLimitPos\n            const triggerLimitRemainingSeconds = sound.triggerLimit / 1000 - triggerLimitElapsedSeconds\n\n            if (triggerLimitElapsedSeconds < 0 || triggerLimitRemainingSeconds > 0) {\n                logger().debug('[ecas] sound triggerLimit reached')\n                return\n            }\n\n            this.#triggerLimitPerSoundSeconds[id] = whenSeconds + delaySeconds\n        }\n\n        if (group.limit && group.limit > 0) {\n            if (this.#currentlyPlayingSoundInstancesWithThisSoundId[id] == null) {\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] = []\n            }\n\n            if (this.#playingSoundsPerGroup[groupId] == null) {\n                this.#playingSoundsPerGroup[groupId] = []\n            }\n\n            this.#currentlyPlayingSoundInstancesWithThisSoundId[id].push(soundContext)\n            this.#playingSoundsPerGroup[groupId].push(soundContext)\n        }\n\n        if (isUndefined(group.crossfade)) {\n            group.crossfade = DEFAULT_CROSSFADE_MILLISECONDS\n        }\n\n        /* const isNumberOfSimultaneouslyPlayingSoundsInGroupOverLimit =\n            this.#playingSoundsPerGroup[groupId]\n            && this.#playingSoundsPerGroup[groupId].length > group.limit\n\n        if (isNumberOfSimultaneouslyPlayingSoundsInGroupOverLimit) {\n            this.#crossfadeSoundsInGroup(soundContext)\n            return\n        } */\n\n        // schedulePlaySound(soundContext, id, soundContext.startTimeSeconds / 1000, this.#mixer)\n        Timer.setTimeout(\n            () => {\n                this.#mixer.playSound(id, soundContext)\n                for (const cb of onplay) {\n                    cb() // used for example for fadein / fadeout envelopes\n                }\n            },\n            // note: previously was ```(startTime - mixer.now()) / 1000```\n            // but why divide mixer.now() with 1000 when mixer.now gives result in seconds?\n            soundContext.startTimeSeconds - this.#mixer.now(),\n            TIMEOUT_CALLERS.MIXER_PLAY_SOUND\n        )\n    }\n\n    /* #crossfadeSoundsInGroup(soundContext: ISoundContext) {\n        const group = soundContext.group\n        const groupId = group.id\n        const targetVolume = getTargetVolume(soundContext.volume)\n\n        function getTargetVolume(vol: ValueOrRandom) {\n            if (isArray(vol)) {\n                return Utils.randomizeValues(soundContext.volume)\n            }\n            // vol cannot become a string here but ValueOrRandom type think it might but it's not possible\n            return vol as number\n        }\n\n        const firstIn = this.#playingSoundsPerGroup[groupId].shift()\n\n        if (firstIn.id !== soundContext.id) {\n            scheduleMixerPlaySound(soundContext, soundContext.id, soundContext.startTimeSeconds, this.#mixer)\n\n            const nowSeconds = this.#mixer.now()\n            const scheduledFadesSeconds = this.#scheduledGrouplimitFadesSeconds[groupId] || nowSeconds\n            const remainingTimeSeconds = scheduledFadesSeconds - nowSeconds\n\n            this.#scheduledGrouplimitFadesSeconds[groupId] = nowSeconds + (group.crossfade / 1000)\n\n            if (remainingTimeSeconds > 0) {\n                Timer.setTimeout(\n                    () => playCrossFadeEnvelopes(),\n                    remainingTimeSeconds + 5, // I think this number might be for safety as to not remove the the caller to early but idk\n                    joinTimeoutCallers(\n                        firstIn.id,\n                        firstIn.parentId\n                    )\n                )\n                return\n            }\n\n            const playCrossFadeEnvelopes = (fadeTime: number = DEFAULT_CROSSFADE_MILLISECONDS) => {\n                // we fade in the new sound, I think\n                const fadeInEnvelopePoints: IEnvelopePoint[] = []\n                fadeInEnvelopePoints.push({pos: 0, val: 0})\n                fadeInEnvelopePoints.push({pos: fadeTime, val: targetVolume})\n                this.#mixer.playEnvelope(\n                    firstIn.id,\n                    new EnvelopeContext({\n                        parentId: firstIn.parentId,\n                        param: \"volume\",\n                        envelopePoints: [\n                            {pos: 0, val: \"current\"},\n                            {pos: fadeTime, val: 0}\n                        ],\n                        type: \"sound\"\n                    })\n                )\n\n                // we fade out the old sound, I think\n                this.#mixer.playEnvelope(\n                    soundContext.id,\n                    new EnvelopeContext({\n                        parentId: soundContext.parentId,\n                        param: \"volume\",\n                        envelopePoints: fadeInEnvelopePoints,\n                        type: \"sound\"\n                    })\n                )\n\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[firstIn.id] = []\n            }\n\n            const crossFadeNow = () => {\n                playCrossFadeEnvelopes(group.crossfade)\n                // stop the sound after the fadeout has happened\n                Timer.setTimeout(\n                    () => {\n                        this.stopSound(\n                            firstIn.id,\n                            new StopSoundArgs(),\n                            firstIn.parentId\n                        )\n                        this.#currentlyPlayingSoundInstancesWithThisSoundId[firstIn.id] = []\n                    },\n                    group.crossfade / 1000,\n                    joinTimeoutCallers(\n                        firstIn.id,\n                        firstIn.parentId,\n                        TIMEOUT_CALLERS.SOUND_STOP,\n                        TIMEOUT_CALLERS.CROSSFADE\n                    )\n                )\n            }\n\n            crossFadeNow()\n        }\n    } */\n\n    /**\n     * Used to trigger a Pool.\n     *\n     * @param {string} id Id of Pool to trigger.\n     * @param {IPlayPoolArgs} args Argument to use when playing pool.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    playPool(id: string, args: IPlayPoolArgs = {}, parentId = id): void {\n        const now = this.#mixer.now()\n        const startTime = Utils.defaultNumber(args.startTime, 0, this.#tempoConfig, now)\n        // default poolIndex is set to null if we dont set startItem\n        const poolIndex = args.startItem\n\n        if (this.#playingPools[id + parentId] === undefined) {\n            this.#playingPools[id + parentId] = 0\n        }\n\n        this.#playingPools[id + parentId]++\n\n        if (startTime > 0) {\n            Timer.setTimeout(\n                () => {\n                    args.startTime = 0\n                    this.playPool(id, args, parentId)\n                },\n                startTime,\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.POOL_PLAY,\n                    Number(this.#playingPools[id + parentId]).toString()\n                )\n            )\n\n            return\n        }\n\n        this.#poolCounter[id + parentId] = Utils.defaultValue(this.#poolCounter[id + parentId], {counter: 0, poolItems: []})\n\n        if (isNumber(poolIndex) && !this.setPoolIndex(id, poolIndex)) {\n            return\n        }\n\n        const item = this.#getItemFromPool(id, args.reset)\n\n        if (!item) {\n            logger().warn(\"[ecas] unable to play pool '\" + id + \"'.\")\n            return\n        }\n\n        item.type = Utils.defaultValue(item.type, \"sound\")\n\n        //This object sucks, fix\n        //Made it to avoid passing too many arguemnts to this._playSoundInPool\n        const commonPoolParams = {\n            startPos: Utils.defaultNumber(args.startPos, 0, this.#tempoConfig, 0),\n            argsDur: Utils.defaultNumber(args.duration, 0, this.#tempoConfig, 0),\n            itemDuration: isNumeric(item.duration) ? item.duration / 1000 : Utils.defaultNumber(item.duration, 0, this.#tempoConfig, 0),\n            itemDelay: isNumeric(item.delay) ? item.delay / 1000 : Utils.defaultNumber(item.delay, 0, this.#tempoConfig, now),\n            itemStartPos: isNumeric(item.startPos) ? item.startPos / 1000 : Utils.defaultNumber(item.startPos, 0, this.#tempoConfig, 0),\n            itemVolume: Utils.sumVolume(item.volume, Utils.defaultNumber(args.volume, 1)),\n            itemPan: Utils.sumPan(item.pan, args.pan),\n            itemPitch: Utils.sumPitch(item.pitch, args.pitch)\n        }\n\n        let duration = Math.min(commonPoolParams.argsDur || Number.MAX_VALUE, commonPoolParams.itemDuration || Number.MAX_VALUE)\n        duration = duration === Number.MAX_VALUE ? 0 : duration\n        duration += startTime\n\n        commonPoolParams.itemDelay = Utils.sumPos(commonPoolParams.itemDelay, startTime)\n        commonPoolParams.itemStartPos = Utils.sumPos(commonPoolParams.itemStartPos, commonPoolParams.startPos)\n        commonPoolParams.itemDuration = duration ? Math.min(duration, commonPoolParams.itemDuration) : commonPoolParams.itemDuration\n\n        if (duration) {\n            const timeoutId = id + parentId + TIMEOUT_CALLERS.POOL_STOP\n\n            Timer.setTimeout(\n                () => this.stopPool(id),\n                duration,\n                timeoutId\n            )\n        }\n\n        switch(item.type) {\n            case \"sound\":\n                this.#playSoundInPool(id, parentId, commonPoolParams, item, args)\n                break\n\n            case \"pool\": {\n                const playPoolArgs: IPlayPoolArgs = {\n                    volume: commonPoolParams.itemVolume,\n                    pan: commonPoolParams.itemPan,\n                    loop: item.loop || args.loop,\n                    startTime: commonPoolParams.itemDelay,\n                    startPos: commonPoolParams.itemStartPos,\n                    pitch: commonPoolParams.itemPitch,\n                    onEnded: () => this.#patternPoolOnEnded(args, item, id, parentId),\n                    duration: commonPoolParams.itemDuration,\n                }\n\n                this.playPool(item.target, playPoolArgs, id)\n                break\n            }\n            case \"pattern\": {\n                const playPatternArgs: IPlayPatternArgs = {\n                    startTime: commonPoolParams.itemDelay,\n                    startPos: commonPoolParams.itemStartPos,\n                    onEnded: () => this.#patternPoolOnEnded(args, item, id, parentId),\n                    duration: commonPoolParams.itemDuration,\n                }\n\n                this.playPattern(item.target, playPatternArgs, id)\n                break\n            }\n            default:\n                break\n        }\n\n        // TODO: Should we not accept envelopes here?\n        this.#playingPoolItems[id + parentId] = Utils.defaultValue(this.#playingPoolItems[id + parentId], [])\n        this.#playingPoolItems[id + parentId].push(item)\n        this.#playingPoolArgs[id + parentId] = args\n    }\n\n    #patternPoolOnEnded (args: IPlayPoolArgs, item: PoolItem, id: string, parentId: string) {\n        if (args.onItemEnded) {\n            this.#callOnEnded(args.onItemEnded)\n        }\n\n        this.#poolEndedCb(item.target, id, parentId)\n    }\n\n    #playSoundInPool (id: string, parentId: string, commonParams: any, item: PoolItem, playPoolArgs: IPlayPoolArgs = {}) {\n        const pool = this.#assetHandler.getPool(id)\n        const itemVolume = Utils.sumVolume(item.volume, Utils.defaultNumber(playPoolArgs.volume, 1))\n        const itemPan = Utils.sumPan(item.pan, playPoolArgs.pan)\n        const itemPitch = Utils.sumPitch(item.pitch, playPoolArgs.pitch)\n\n        const playSoundArgs = new PlaySoundArgs({\n            volume: itemVolume,\n            pan: itemPan,\n            loop: item.loop || playPoolArgs.loop,\n            pitch: itemPitch,\n            onended: () => {\n                if (this.#poolCounter[id + parentId]) {\n                    this.#poolCounter[id + parentId].counter--\n\n                    if (this.#poolCounter[id + parentId].counter === 0) {\n                        this.#poolCounter[id + parentId].poolItems.forEach((val) => {\n                            if (val.onEnded) {\n                                this.#callOnEnded(val.onEnded)\n                            }\n                        })\n                        this.#poolCounter[id + parentId].poolItems = []\n                    }\n                }\n                Timer.clearTimeout(item.target + \"_\" + id)\n\n                if (playPoolArgs.onItemEnded) {\n                    this.#callOnEnded(playPoolArgs.onItemEnded)\n                }\n\n                this.#poolEndedCb(item.target, id, parentId)\n            },\n            startTime: commonParams.itemDelay,\n            startPos: commonParams.itemStartPos,\n            duration: commonParams.itemDuration,\n        })\n\n        let poolItems = this.#playingSoundsPerPool[id]\n\n        if (!poolItems) {\n            poolItems = []\n        }\n\n        const overLimit = poolItems.length >= pool.limit\n\n        if (overLimit) {\n            const firstIn = poolItems.shift()\n            this.stopSound(firstIn, null, id)\n        }\n\n        poolItems.push(item.target)\n        this.#poolCounter[id + parentId].counter++\n        this.#poolCounter[id + parentId].poolItems.push(playPoolArgs)\n\n        this.playSound(item.target, playSoundArgs, id)\n        this.#playingSoundsPerPool[id] = poolItems\n    }\n\n    #poolEndedCb = (target: string, id: string, parentId: string) => {\n        if (this.#playingPoolItems[id + parentId]) {\n            this.#playingPoolItems[id + parentId] = this.#playingPoolItems[id + parentId].filter((val) => val.target !== target)\n        }\n\n        this.#playingPools[id + parentId]--\n    }\n\n    /**\n     * Reset the sound pool index to 0.\n     *\n     * @param id Id of a Pool to play.\n     */\n    resetPool(id: string) {\n        if (!this.#assetHandler.hasPool(id)) {\n            logger().warn(\"[ecas] unable to reset pool with id '\" + id + \"'.\")\n            return\n        }\n        this.#poolPointer[id] = 0\n    }\n\n\n\n    /**\n     * Play an envelope.\n     *\n     * @param {string} target Path to bus or effect using ids concatenated with \".\" For example \"bus1\", \"bus1.effect1\", \"bus1.aux1\".\n     * @param {IPlayEnvelopeArgs} playEnvelopeArgs Arguments to use when playing envelope.\n     * @param {string} parentId Id of pattern which triggered envelope. Omit if directly triggered.\n     */\n    playEnvelope(target: string, playEnvelopeArgs: PlayEnvelopeArgs, parentId?: string): void {\n        const nowSeconds = this.#mixer.now()\n        const scheduledTimeSeconds = Utils.defaultNumber(playEnvelopeArgs.startTime, 0, this.#tempoConfig, nowSeconds)\n        const isDelayed = scheduledTimeSeconds > (nowSeconds + TIME_LOOKAHEAD_SECONDS)\n\n        const playLater = () => {\n            const timeoutId = joinTimeoutCallers(\n                parentId,\n                TIMEOUT_CALLERS.ENVELOPE_SCHEDULED,\n                target\n            )\n            Timer.setTimeout(\n                () => {\n                    this.playEnvelope(target, playEnvelopeArgs, parentId)\n                },\n                scheduledTimeSeconds - (nowSeconds + TIME_LOOKAHEAD_SECONDS),\n                timeoutId\n            )\n        }\n\n        if (isDelayed) {\n            playLater()\n            return\n        }\n\n        const envelopeContext = new EnvelopeContext({\n            startTime: scheduledTimeSeconds,\n            param: playEnvelopeArgs.param,\n            curveType: playEnvelopeArgs.curveType,\n            type: playEnvelopeArgs.type,\n            onEnded: playEnvelopeArgs.onEnded,\n            onplay: playEnvelopeArgs.onplay,\n            willStopSoundOnEnded: playEnvelopeArgs.willStopSoundOnEnded,\n            envelopePoints: playEnvelopeArgs.envelopePoints as Writeable<typeof playEnvelopeArgs.envelopePoints>,\n            parentId: parentId,\n        })\n\n        if (playEnvelopeArgs.type === \"sound\") {\n            this.#mixer.playEnvelope(target, envelopeContext)\n        }\n        // Fixme: implement playEnvelope for inserts / effects\n    }\n\n    /**\n     * Stop a sound.\n     *\n     * @param {string} id Id of sound to stop.\n     * @param {IStopSoundArgs} stopSoundArgs Arguments to pass when playing sound.\n     * @param {string} parentId Id of parent pattern or pool. Omit if directly triggered.\n     */\n    stopSound(id: string, stopSoundArgs: StopSoundArgs, parentId?: string, isDefaultStop?: boolean): void {\n        logger().debug(\"[ecas] stopping sound: \", id)\n        this.#assetHandler.soundHandler.getSound(id)\n\n        if(stopSoundArgs.delay) {\n            const playing = this.#playingSoundsPerGroup[this.#assetHandler.soundHandler.getSound(id).group]\n            playing?.forEach((sound: ISoundContext) => {\n                sound.isStoppingSoon = true\n            })\n        }\n\n        else if(stopSoundArgs.fadeOut) {\n            const playing = this.#playingSoundsPerGroup[this.#assetHandler.soundHandler.getSound(id).group]\n            playing?.forEach((sound: ISoundContext) => {\n                sound.isFadingOut = true\n            })\n        }\n\n        const delaySeconds =  Utils.defaultNumber(stopSoundArgs.delay, 0, this.#tempoConfig, this.#mixer.now())\n        const whenSeconds = this.#mixer.now() + delaySeconds\n\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                const caller = joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    i.toString()\n                )\n                Timer.clearTimeout(caller)\n\n                // dont understand how it could exist since we just cleared it\n                if (Timer.hasTimeout(caller) && !delaySeconds) {\n                    Timer.resume(caller)\n                }\n            }\n\n            this.#timeOutIdCounter.set(id, 0)\n        }\n\n        if (delaySeconds > 0) {\n            this.#stopSoundWithFadeOrRenameTimeout(delaySeconds, stopSoundArgs, id, parentId, isDefaultStop, whenSeconds)\n        }\n\n        else {\n            this.#cancelOrStopSound(stopSoundArgs, id, parentId, whenSeconds)\n        }\n\n        this.#purgePlayingSound(id, parentId)\n    }\n\n    #stopSoundWithFadeOut (stopSoundArgs: StopSoundArgs, id: string, parentId: string, whenSeconds: number) {\n        const envelopeArgs = createPlayEnvelopeArgs({\n            type: \"sound\",\n            param: \"volume\",\n            startTime: 0,\n            envelopePoints: [\n                {pos: 0, val: \"current\"},\n                {pos: stopSoundArgs.fadeOut, val: 0}\n            ],\n            curveType: \"logarithmic\",\n            onEnded: () => {\n                const sound = this.#assetHandler.soundHandler.getSound(id)\n\n                this.#mixer.stopSound(\n                    id,\n                    parentId,\n                    whenSeconds + stopSoundArgs.fadeOut / 1000,\n                    stopSoundArgs.onEnded\n                )\n\n                this.#currentlyPlayingSoundInstancesWithThisSoundId[id] = []\n                this.#playingSoundsPerGroup[sound.group] = this.#playingSoundsPerGroup[sound.group].filter(item => item.id !== sound.id)\n            },\n            willStopSoundOnEnded: true\n        })\n\n        this.playEnvelope(id, envelopeArgs, parentId)\n    }\n\n    #stopSoundWithFadeOrRenameTimeout (delaySeconds: number, stopSoundArgs: StopSoundArgs, id: string, parentId: string, isDefaultStop: boolean, whenSeconds: number) {\n        const timeoutId = joinTimeoutCallers(\n            id,\n            parentId,\n            TIMEOUT_CALLERS.STOP\n        )\n\n        const timeoutDelaySeconds = delaySeconds - TIME_LOOKAHEAD_SECONDS\n\n        let caller = joinTimeoutCallers(\n            id,\n            parentId,\n            TIMEOUT_CALLERS.DEFAULT_STOP\n        )\n\n        if (!isDefaultStop) {\n            if (Timer.hasTimeout(caller)) {\n                Timer.clearTimeout(caller)\n            }\n            else {\n                caller = timeoutId\n            }\n        }\n\n        Timer.setTimeout(\n            () => this.#stopSoundWithFadeOut(\n                stopSoundArgs,\n                id,\n                parentId,\n                whenSeconds\n            ),\n            timeoutDelaySeconds,\n            caller\n        )\n    }\n\n    #cancelOrStopSound(args: StopSoundArgs, id: string, parentId: string, whenSeconds: number) {\n        const ctx = this.#scheduledSoundContexts[id + parentId]\n        \n        if (exists(ctx)) {\n            this.#audioScheduler.cancelScheduledSound(ctx)\n            return\n        }\n        this.#stopSoundWithFadeOut(args, id, parentId, whenSeconds)\n    }\n\n    /**\n     * Stop a Pool.\n     *\n     * @param {string} id Id of Pool to stop.\n     * @param {MusicalPositionOrNumber} delay If number, ms to wait until stopping,\n     * if string \"bar.beat.tick\" for quantized trigger. Use \"0.0.0\" to trigger on next quantize event.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    stopPool(id: string, delay: MusicalPositionOrNumber = 0, parentId: string = id): void {\n        const nowSeconds = this.#mixer.now()\n        const pool = this.#playingPoolItems[id + parentId]\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds - elapsed\n                    this.stopPool(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.POOL_STOP\n                )\n            )\n            return\n        }\n\n        delete this.#poolCounter[id + parentId]\n        \n        if (pool === undefined) {\n            return\n        }\n        if (delaySeconds) {\n            Timer.setTimeout(\n                () => this._stopAndDeletePoolItems(\n                    pool,\n                    id,\n                    parentId\n                ),\n                delaySeconds\n            )\n            return\n        }\n\n        this._stopAndDeletePoolItems(pool, id, parentId)\n    }\n\n    //Fix description\n    private _stopAndDeletePoolItems (pool: Array<PoolItem>, id: string, parentId: string): void {\n        for (const poolItem of pool) {\n            if (poolItem.type === \"sound\" || !poolItem.type) {\n                this.stopSound(\n                    poolItem.target,\n                    new StopSoundArgs(),\n                    id\n                )\n            }\n            else if (poolItem.type === \"pool\") {\n                this.stopPool(poolItem.target, 0, id)\n            }\n            else if (poolItem.type === \"pattern\") {\n                this.stopPattern(poolItem.target, 0, id)\n            }\n        }\n\n        delete this.#playingPoolItems[id + parentId]\n        delete this.#playingPoolArgs[id + parentId]\n        const playing = this.#playingPools[id + parentId]\n\n        const caller = joinTimeoutCallers(id, TIMEOUT_CALLERS.POOL_PLAY)\n\n        for (let i = 0; i < playing; i++) {\n            Timer.clearTimeout(joinTimeoutCallers(caller, i.toString()))\n        }\n\n        this.#playingPools[id + parentId] = 0\n        Timer.clearTimeout(caller)\n    }\n\n    /**\n     * Pause a sound.\n     *\n     * @param {string} id Id of the sound to pause.\n     * @param {MusicalPositionOrNumber} delaySeconds Delay before pausing. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of envelope parent, for example pattern id. Optional.\n     */\n    pauseSound(id: string, delaySeconds: MusicalPositionOrNumber, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        delaySeconds = Utils.defaultNumber(delaySeconds, 0, this.#tempoConfig, nowSeconds)\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                Timer.pause(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SOUND_START,\n                        i.toString()\n                    )\n                )\n            }\n            this.#timeOutIdCounter.set(id, 0)\n        }\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds as number - elapsed\n                    this.pauseSound(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(id, TIMEOUT_CALLERS.SOUND_PAUSE)\n            )\n            return\n        }\n\n        this.#eventQueue = this.#eventQueue.filter((item) => {\n            return item.id !== id && item.parentId !== parentId\n        })\n\n        if (delaySeconds) {\n            Timer.setTimeout(() => {\n                this.#mixer.pauseSound(id, parentId)\n            }, delaySeconds, id)\n        }\n\n        else {\n            this.#mixer.pauseSound(id, parentId)\n        }\n    }\n\n    /**\n     * Pause a pool.\n     *\n     * @param {string} id Id of the pool to pause.\n     * @param {MusicalPositionOrNumber} delaySeconds Delay before pausing pool. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    pausePool(id: string, delaySeconds?: MusicalPositionOrNumber, parentId?: string): void {\n        parentId = parentId || id\n\n        const pool = this.#playingPoolItems[id + parentId]\n\n        if (!pool) {\n            logger().warn(\"[ecas] unable to pause pool:\", id)\n            return\n        }\n\n        const nowSeconds = this.#mixer.now()\n\n        delaySeconds = Utils.defaultNumber(delaySeconds, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - nowSeconds\n                    const remain = delaySeconds as number - elapsed\n                    this.pausePool(id, remain, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                id + TIMEOUT_CALLERS.POOL_PAUSE\n            )\n            return\n        }\n\n        const pause = (item: PoolItem) => {\n            switch (item.type) {\n                case \"pattern\":\n                    this.pausePattern(item.target, 0, parentId)\n                    break\n                case \"pool\":\n                    this.pausePool(item.target, 0, parentId)\n                    break\n                case \"sound\":\n                    this.pauseSound(item.target, 0, id)\n                    break\n                default:\n                    logger().warn(\"[ecas] Sequencer.pausePool; item.type not set\")\n                    break\n            }\n        }\n\n        const playing = this.#playingPools[id + parentId]\n\n        for (let i = 0; i < playing; i++) {\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.POOL_PLAY,\n                    i.toString()\n                )\n            )\n        }\n\n        if (delaySeconds) {\n            Timer.setTimeout(\n                () => {\n                    pool.forEach(pause)\n                    this.#pausedPools[id + parentId] = true\n                },\n                delaySeconds\n            )\n        }\n\n        else {\n            pool.forEach(pause)\n            this.#pausedPools[id + parentId] = true\n        }\n    }\n\n    /**\n     * Resume a paused sound.\n     *\n     * @param {string} id Id of the sound to resume.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming sound. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of sound parent, for example pool or pattern id. Optional.\n     */\n    resumeSound(id: string, delay: MusicalPositionOrNumber, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remainingSeconds = delaySeconds - elapsedSeconds\n                    this.resumeSound(id, remainingSeconds, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_RESUME\n                )\n            )\n            return\n        }\n\n        const sameSoundTimeCounter = this.#timeOutIdCounter.get(id)\n\n        if (sameSoundTimeCounter) {\n            for (let i = 1; i <= sameSoundTimeCounter; i++) {\n                const caller = joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SOUND_START,\n                    i.toString()\n                )\n                if (Timer.hasTimeout(caller) && !delaySeconds) {\n                    Timer.resume(caller)\n                }\n            }\n            this.#timeOutIdCounter[id] = 0\n        }\n\n        if (delaySeconds > 0) {\n            Timer.setTimeout(\n                () => this.#mixer.resumeSound(id, parentId),\n                delaySeconds\n            )\n            return\n        }\n\n        this.#mixer.resumeSound(id, parentId)\n    }\n\n    /**\n     * Resume a paused pool.\n     *\n     * @param {string} id Id of the pool to resume.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming pool. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    resumePool(id: string, delay: MusicalPositionOrNumber = 0, parentId = id): void {\n        const nowSeconds = this.#mixer.now()\n        const delaySeconds = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delaySeconds >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remainingSeconds = delaySeconds - elapsedSeconds\n                    this.resumePool(id, remainingSeconds, parentId)\n                },\n                delaySeconds - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(id, TIMEOUT_CALLERS.POOL_RESUME)\n            )\n            return\n        }\n\n        const pool = Utils.filterUnique(this.#playingPoolItems[id + parentId], [\"target\", \"type\"])\n\n        if (delaySeconds > 0) {\n            Timer.setTimeout(\n                () => this.#resumePausedPoolItems(pool, id, parentId),\n                delaySeconds\n            )\n            return\n        }\n\n        this.#resumePausedPoolItems(pool, id, parentId)\n    }\n\n    #resumePausedPoolItems (pool: Array<PoolItem>, id: string, parentId: string) {\n        if (this.#pausedPools[id + parentId]) {\n            pool.forEach((item: PoolItem) => {\n                switch (item.type) {\n                    case \"pattern\":\n                        this.resumePattern(item.target, 0, id)\n                        break\n                    case \"pool\":\n                        this.resumePool(item.target, 0 , id)\n                        break\n                    case \"sound\":\n                        this.resumeSound(item.target, 0, id)\n                        break\n                    default:\n                        logger().warn(\"[ecas] Sequencer._resumePausePoolItems; item.type not set\")\n                        break\n                }\n            })\n            delete this.#pausedPools[id + parentId]\n            const playing = this.#playingPools[id + parentId]\n            for (let i = 0; i < playing; i++) {\n                Timer.resume(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.POOL_PLAY,\n                        i.toString()\n                    )\n                )\n            }\n            return\n        }\n        this.stopPool(id)\n        this.playPool(id, this.#playingPoolArgs[id + parentId])\n    }\n\n\n    /**\n     * Play a pattern.\n     * @param {string} id Id of pattern to play.\n     * @param {IPlayPatternArgs} playPatternArgs Arguments to pass when playing pattern.\n     * @param {string} parentId Id of parent pool or pattern.\n     * @param {boolean} isRelative If true, startTime is not including current time.\n     */\n    playPattern(id: string, playPatternArgs: IPlayPatternArgs = {}, parentId?: string, isRelative = true): void {\n        parentId = parentId || id\n        playPatternArgs = Utils.defaultValue(playPatternArgs, {})\n\n        const nowSeconds = this.#mixer.now()\n        const tempoConfig = clone(this.#tempoConfig)\n        const pattern = this.#options.soundConfig.patterns.filter((val) => val.id === id)[0]\n\n        this.#patternItemsCompleted[id + parentId] = 0\n\n        if (!pattern) {\n            logger().warn(\"[ecas] unable to play pattern with id '\" + id + \"'.\")\n            return null\n        }\n\n        tempoConfig.tempo = pattern.tempo || tempoConfig.tempo\n        if (isUndefined(tempoConfig.triggerQuantize)) {\n            tempoConfig.triggerQuantize = 1\n        }\n        tempoConfig.timeSignature = createTimeSignatureFromString(pattern.timeSignature) || tempoConfig.timeSignature\n\n        const secondsPerBeat = milliSecondsPerBeatFromTempoConfig(tempoConfig)\n        let startTimeSeconds = Utils.defaultNumber(playPatternArgs.startTime, 0, tempoConfig, nowSeconds)\n\n        if (isRelative) {\n            startTimeSeconds += nowSeconds\n        }\n\n        const patternDelay = startTimeSeconds - nowSeconds\n        const latencyTimeSeconds = nowSeconds + TIME_LOOKAHEAD_SECONDS\n\n        if (startTimeSeconds >= latencyTimeSeconds) {\n            Timer.setTimeout(\n                () => {\n                    playPatternArgs.startTime = startTimeSeconds\n                    this.playPattern(id, playPatternArgs, parentId, false)\n                },\n                startTimeSeconds - latencyTimeSeconds,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n\n            return\n        }\n\n        const startPosSeconds = Utils.defaultNumber(playPatternArgs.startPos, 0, tempoConfig, 0) / 1000\n        const durationSeconds = Math.max(\n            Utils.defaultNumber(playPatternArgs.duration, 0, tempoConfig, 0) / 1000,\n            0\n        )\n\n        const numItems = pattern.pattern.length\n        const quantizeValue = tempoConfig.triggerQuantize * (tempoConfig.triggerQuantize >= 1 ? tempoConfig.timeSignature.meter : 1)\n        const quantizeSize = secondsPerBeat * quantizeValue\n\n        let endTimeSeconds = nowSeconds\n\n        pattern.pattern.sort((val) => val.sound ? -1 : 1)\n        const sorted = pattern.pattern\n\n        const cb = () => {\n            let completed = this.#patternItemsCompleted[id + parentId]\n\n            if (!completed) {\n                completed = 0\n            }\n\n            completed++\n            this.#patternItemsCompleted[id + parentId] = completed\n\n            if (completed === numItems) {\n                if (playPatternArgs.onEnded) {\n                    this.#callOnEnded(playPatternArgs.onEnded)\n                }\n            }\n        }\n\n        let maxItemDuration = 0\n        let maxLoopDurationSeconds = 0\n        let isLoop = false\n        let shouldSchedule = true\n\n        for (const item of sorted) {\n            item.parentId = parentId\n\n            this.#playingPatternItems[id + parentId] = Utils.defaultValue(this.#playingPatternItems[id + parentId], [])\n            this.#playingPatternItems[id + parentId].push(item)\n\n            const confStartPosSeconds = isNumeric(item.startPos) ? item.startPos / 1000 : item.startPos\n            const confDurationSeconds = isNumeric(item.duration) ? item.duration / 1000 : item.duration\n            const confDelaySeconds = isNumeric(item.delay) ? item.delay / 1000 : item.delay\n\n            const soundDurationSeconds = this.#assetHandler.soundHandler.getDurationSeconds(item.sound)\n            let itemDuration = Utils.defaultNumber(confDurationSeconds, 0, tempoConfig, 0)\n\n            let actualItemDuration = itemDuration\n            if (actualItemDuration === 0 && item.sound) {\n                actualItemDuration = soundDurationSeconds\n            }\n\n            const quantizeSteps = Math.round(Math.max(actualItemDuration / quantizeSize, 1))\n            const loopDurationSeconds = item.loop && pattern.sync ? quantizeSteps * quantizeSize : soundDurationSeconds\n\n            maxLoopDurationSeconds = Math.max(maxLoopDurationSeconds, item.loop && pattern.sync ? loopDurationSeconds : 0)\n\n            let itemStartPos = Utils.sumPos(Utils.defaultNumber(confStartPosSeconds, 0, tempoConfig, 0), startPosSeconds)\n\n            if (itemStartPos === loopDurationSeconds) {\n                itemStartPos = 0\n            }\n\n            if (itemStartPos >= soundDurationSeconds && loopDurationSeconds && item.loop) {\n                itemStartPos = itemStartPos % loopDurationSeconds\n            }\n\n            const itemDelay = Utils.sumPos(Utils.defaultNumber(confDelaySeconds, 0, tempoConfig, nowSeconds), patternDelay)\n\n            itemDuration = Math.max(itemDuration, 0)\n            actualItemDuration = item.loop && !pattern.sync ? itemDuration : actualItemDuration + itemDelay - itemStartPos\n            maxItemDuration = Math.max(maxItemDuration, actualItemDuration)\n\n            if (item.sound) {\n                if (item.loop) {\n                    isLoop = true\n                }\n\n                else {\n                    shouldSchedule = false\n                }\n\n                if (pattern.sync) {\n                    const playSoundArgs = new PlaySoundArgs({\n                        startTime: itemDelay + nowSeconds,\n                        volume: item.volume,\n                        pan: item.pan,\n                        loop: false,\n                        startPos: itemStartPos,\n                        duration: itemDuration,\n                        pitch: item.pitch,\n                        args: item.args,\n                        onended: actualItemDuration === Number.MAX_VALUE || item.loop ? null : cb,\n                    })\n\n                    this.#scheduleItem(item, id, playSoundArgs, loopDurationSeconds)\n                }\n\n                else {\n                    const playSoundArgs = new PlaySoundArgs({\n                        startTime: itemDelay + nowSeconds,\n                        volume: item.volume,\n                        pan: item.pan,\n                        loop: item.loop,\n                        startPos: itemStartPos,\n                        duration: itemDuration,\n                        pitch: item.pitch,\n                        args: item.args,\n                        onended: actualItemDuration === Number.MAX_VALUE || item.loop ? null : cb,\n                    })\n\n                    if (playSoundArgs.startTime <= nowSeconds) {\n                        this.playSound(item.sound, playSoundArgs, id, false)\n                    }\n                    else {\n                        this.#scheduleItem(item, id, playSoundArgs)\n                    }\n                }\n            }\n            else {\n                if (item.envelope) {\n                    const envelope = item.envelope as EnvelopePreset\n\n                    const envelopeArgs: PlayEnvelopeArgs = createPlayEnvelopeArgs({\n                        startTime: itemDelay + nowSeconds,\n                        param: envelope.param,\n                        envelopePoints: envelope.data,\n                        onEnded: cb,\n                    })\n\n                    envelopeArgs.type = item.soundId ? \"sound\" : \"bus\"\n\n                    const envTarget = item.bussId || item.soundId\n\n                    if (envTarget) {\n                        if (envelopeArgs.startTime <= nowSeconds) {\n                            const target = item.bussId || item.soundId\n\n                            this.playEnvelope(target, envelopeArgs)\n                        }\n                        else {\n                            this.#scheduleItem(item, id, envelopeArgs)\n                        }\n                    }\n\n                    else {\n                        let isCallbackAdded = false\n\n                        pattern.pattern.forEach((val) => {\n                            if (val.sound) {\n                                const envArgs = clone(envelopeArgs)\n                                envArgs.onEnded = !isCallbackAdded ? cb : null\n                                envArgs.type = \"sound\"\n                                item.soundId = val.sound\n                                this.#scheduleItem(item, id, envArgs)\n                                isCallbackAdded = true\n                            }\n                        })\n                    }\n                }\n\n                else if (item.pattern) {\n                    const patternArgs = {startTime: itemDelay, onEnded: cb, startPos: itemStartPos, duration: itemDuration}\n                    this.#scheduleItem(item, id, patternArgs)\n                }\n\n                else if (item.pool) {\n                    const poolDurationSeconds = Utils.defaultNumber(item.duration) / 1000\n                    const { volume, pan, loop } = item\n                    const poolArgs = { volume, pan, loop, startTime: itemDelay, duration: poolDurationSeconds, startPos: itemStartPos, onEnded: cb }\n\n                    this.#scheduleItem(item, id, poolArgs)\n                }\n            }\n        }\n\n        let actualDuration = Math.min(\n            maxItemDuration > 0 ?  maxItemDuration : Number.MAX_VALUE,\n            durationSeconds ? durationSeconds : Number.MAX_VALUE,\n        )\n\n        if (!shouldSchedule && isLoop) {\n            actualDuration = durationSeconds > 0 ? durationSeconds : 0\n        }\n\n        if ((isLoop && durationSeconds > maxItemDuration)) {\n            actualDuration = durationSeconds\n        }\n\n        if (maxLoopDurationSeconds === 0 || durationSeconds > 0) {\n            endTimeSeconds += actualDuration + patternDelay\n\n            this.#assetHandler.setPatternContext(id + parentId, { pattern, endTime: endTimeSeconds, onEnded: playPatternArgs.onEnded })\n            this.#playingPatternArgs[id + parentId] = playPatternArgs\n\n            if (actualDuration > 0 && actualDuration !== Number.MAX_VALUE) {\n\n                Timer.setTimeout(\n                    () => this.stopPattern(id, 0, parentId),\n                    actualDuration + patternDelay,\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED,\n                        parentId,\n                        TIMEOUT_CALLERS.PATTERN\n                    )\n                )\n            }\n        }\n    }\n\n    /**\n     * Pause a pattern.\n     * @param {string} id Id of pattern to pause.\n     * @param {MusicalPositionOrNumber} delay Delay before pausing pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of pattern parent, for example pool id. Optional.\n     */\n    pausePattern(id: string, delay: MusicalPositionOrNumber = 0, parentId: string = null): void {\n        parentId = parentId || id\n        const now = this.#mixer.now()\n        delay = Utils.defaultNumber(delay, 0, this.#tempoConfig, now)\n        if (delay >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - now\n                    const remainingSeconds = delay as number - elapsedSeconds\n                    this.pausePattern(id, remainingSeconds, parentId)\n                },\n                delay - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PAUSE\n                )\n            )\n            return\n        }\n        const pause = () => {\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n            if (!this.#playingPatternItems[id + parentId]) {\n                logger().warn(\"[ecas] unable to pause pattern with id '\" + id + \"' and parentId '\" + parentId + \"'.\")\n                return null\n            }\n            Timer.pause(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN\n                )\n            )\n            Timer.pauseMatching(\n                new RegExp(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED_REGEX\n                    )\n                )\n            )\n            this.#playingPatternItems[id + parentId].forEach((item) => {\n                if (item.sound) {\n                    this.pauseSound(item.sound, 0, id)\n                }\n                else if (item.pattern) {\n                    this.pausePattern(item.pattern, 0, id)\n                }\n                else if (item.pool) {\n                    this.pausePool(item.pool, 0 , id)\n                }\n                else if (item.envelope) {\n                    // Pausing of envelopes not currently possible in WebAudio API\n                    // The genius responsible for the spec obviously think that fire and forget animation of parameters\n                    // is good enough, and that it is inconceivable that anyone would ever have the need to inspect the current\n                    // value of an animated parameter, or stopping an animation in progress.\n                    // This might be doable eventually when AudioParam.cancelAndHoldAtTime() is supported in browsers.\n                }\n            })\n            this.#pausedPatterns[id + parentId] = true\n        }\n        delay = Utils.randomizeValues(delay)\n        if (delay) {\n            Timer.setTimeout(\n                pause,\n                delay,\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN_PAUSE\n                )\n            )\n        }\n        else {\n            pause()\n        }\n    }\n\n    /**\n     * Resume a paused pattern.\n     * @param {string} id Id of pattern to pause.\n     * @param {MusicalPositionOrNumber} delay Delay before resuming pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    resumePattern(id: string, delay: MusicalPositionOrNumber = 0, parentId = id): void {\n        const now = this.#mixer.now()\n        const delayValue = Utils.defaultNumber(delay, 0, this.#tempoConfig, now)\n\n        if (delayValue >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsed = this.#mixer.now() - now\n                    const remain = delayValue as number - elapsed\n                    this.resumePattern(id, remain, parentId)\n                },\n                delayValue - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_RESUME\n                )\n            )\n            return\n        }\n        const failMsg = \"[ecas] unable to resume pattern with id '\" + id + \"'.\"\n        if (this.#pausedPatterns[id + parentId]) {\n            const patternContext = this.#assetHandler.getPatternContext(id + parentId)\n            if (!patternContext || !patternContext.pattern || !this.#playingPatternItems[id + parentId]) {\n                logger().warn(failMsg)\n                return null\n            }\n            Timer.resume(\n                joinTimeoutCallers(\n                    id,\n                    parentId,\n                    TIMEOUT_CALLERS.PATTERN\n                )\n            )\n            Timer.resume(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_PLAY\n                )\n            )\n            Timer.resumeMatching(\n                new RegExp(\n                    joinTimeoutCallers(\n                        id,\n                        TIMEOUT_CALLERS.SCHEDULED_REGEX\n                    )\n                )\n            )\n            this.#playingPatternItems[id + parentId].forEach((item) => {\n                if (item.sound) {\n                    this.resumeSound(item.sound, delayValue, id)\n                }\n                else if (item.pool) {\n                    this.resumePool(item.pool, delayValue, id)\n                }\n                else if (item.pattern) {\n                    this.resumePattern(item.pattern, delayValue, id)\n                }\n            })\n            delete this.#pausedPatterns[id + parentId]\n            return\n        }\n        else if (this.#assetHandler.getPatternContext(id + parentId)) {\n            const args = this.#playingPatternArgs[id + parentId]\n            this.stopPattern(id)\n            args.startTime = delayValue\n            this.playPattern(id, args)\n            return\n        }\n        logger().warn(failMsg)\n\n    }\n\n    /**\n     * Stop a pattern.\n     * @param {string} id Id of pattern to stop.\n     * @param {MusicalPositionOrNumber} delay Delay before stopping pattern. String with \"bar.beat.tick\",\n     * or int with ms. Use \"0.0.0\" to trigger on next quantize event. Optional.\n     * @param {string} parentId Id of parent pool or pattern.\n     */\n    stopPattern(id: string, delay: MusicalPositionOrNumber = 0, parentId?: string): void {\n        parentId = parentId || id\n\n        const nowSeconds = this.#mixer.now()\n        delay = Utils.defaultNumber(delay, 0, this.#tempoConfig, nowSeconds)\n\n        if (delay >= TIME_LOOKAHEAD_SECONDS) {\n            Timer.setTimeout(\n                () => {\n                    const elapsedSeconds = this.#mixer.now() - nowSeconds\n                    const remain = delay as number - elapsedSeconds\n                    this.stopPattern(id, remain, parentId)\n                },\n                delay - TIME_LOOKAHEAD_SECONDS,\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.PATTERN_STOP\n                )\n            )\n\n            return\n        }\n\n        const patternContext = this.#assetHandler.getPatternContext(id + parentId)\n        const playingItems = this.#playingPatternItems[id + parentId]\n\n        if (!playingItems) {\n            logger().warn(\"[ecas] unable to stop pattern with id '\" + id + \"' and parentId '\" + parentId + \"'.\")\n            return null\n        }\n\n        Timer.clearTimeout(\n            joinTimeoutCallers(\n                id,\n                parentId,\n                TIMEOUT_CALLERS.PATTERN\n            )\n        )\n        Timer.clearTimeout(\n            joinTimeoutCallers(\n                id,\n                TIMEOUT_CALLERS.PATTERN_PLAY\n            )\n        )\n        Timer.clearMatching(\n            new RegExp(\n                joinTimeoutCallers(\n                    id,\n                    TIMEOUT_CALLERS.SCHEDULED_REGEX\n                )\n            )\n        )\n\n        playingItems.forEach((item) => {\n            let itemId: string\n\n            if (item.sound) {\n                itemId = item.sound\n                this.stopSound(item.sound, new StopSoundArgs({delay}), id)\n            }\n\n            else if (item.pattern) {\n                itemId = item.pattern\n                this.stopPattern(item.pattern, delay, id)\n            }\n\n            else if (item.pool) {\n                itemId = item.pool\n                this.stopPool(item.pool, delay, id)\n            }\n\n            this.#eventQueue = this.#eventQueue.filter((itm) => itm.parentId !== id && itm.id !== itemId)\n        })\n\n        const onEnded = patternContext ? patternContext.onEnded : null\n\n        if (onEnded) {\n            this.#callOnEnded(onEnded)\n        }\n\n        this.#assetHandler.setPatternContext(id + parentId, null)\n        delete this.#playingPatternItems[id + parentId]\n        delete this.#playingPatternArgs[id + parentId]\n    }\n\n    /**\n     * Stop all sounds.\n     */\n    stopAll(options: {onEnded?: string} = {}) {\n        this.#mixer.stopAll(options)\n    }\n\n    /**\n     * Set the pool Index\n     *\n     * @param {string} id Id of the pool\n     * @param {number} index pool item's position\n     * @return {boolean} true or false\n     */\n    setPoolIndex(id: string, index: number): boolean {\n        // convert position number to array index\n        const arrayIndex = index - 1\n        const len = this.#poolQueue[id].length\n        if (index > len || index < 1) {\n            logger().warn(`[ecas] sound item outbound exception with pool id '${id}'`)\n            return false\n        }\n        this.#poolPointer[id] = arrayIndex\n        return true\n    }\n\n    #callOnEnded(val: string | (() => void)) {\n        if (isFunction(val)) {\n            val()\n            return\n        }\n\n        if (isString(val)) {\n            this.#eventHandler.triggerOnEndedEvent(val)\n            return\n        }\n\n        logger().debug(\"[ecas] invalid parameter type specified in onEnded.\")\n    }\n\n    #purgePlayingSound(id: string, parentId: string) {\n        logger().debug(\"[ecas] purge sound\", id, parentId)\n        const sound = this.#assetHandler.soundHandler.getSound(id)\n        const playing = this.#playingSoundsPerGroup[sound.group]\n\n        if (playing) {\n            const filteredPlaying = playing.filter((val: ISoundContext) => !(val.id === id && val.parentId === parentId))\n            this.#playingSoundsPerGroup[sound.group] = filteredPlaying\n\n            const pool = this.#playingSoundsPerPool[parentId]\n\n            if (pool) {\n                this.#playingSoundsPerPool[parentId].pop()\n            }\n        }\n    }\n\n    /**\n     * Get the sound name from the sound pool based on priority configuration\n     *\n     * @param {string} id passing POOL id\n     * @return {IPoolItem} Pool item\n     */\n    #getItemFromPool(id: string, reset: boolean): ISoundsConfig['pools'][number]['items'][number] {\n        if (!this.#assetHandler.hasPool(id)) {\n            logger().warn(\"[ecas] unable to play pool with id '\" + id + \"'.\")\n            return null\n        }\n        const len = this.#poolQueue[id].length\n        const type = this.#assetHandler.getPool(id).type\n        if (reset || this.#poolPointer[id] >= len) {\n            this.#poolPointer[id] = 0\n            // if the random pool ends the Q, then reshuffle it\n            if (type === \"random\") {\n                this.#poolQueue[id] = Utils.randomShuffle(this.#poolQueue[id])\n            }\n        }\n        const item: PoolItem = this.#poolQueue[id][this.#poolPointer[id]]\n        this.#poolPointer[id]++\n        item.pan = item.pan || 0\n        return item\n    }\n\n    /**\n     * Get sounds from config and set them up\n     *\n     * @param {IPool[]} pools List of IPool objects to setup\n     * @private\n     */\n    #setupPools(pools: Pool[]): void {\n        this.#poolQueue = {}\n        this.#poolPointer = {}\n        this.#poolCounter = {}\n\n        for (const pool of pools) {\n            const tempArr: PoolItem[] = []\n            pool.items.forEach((item, index) => {\n                if (pool.priority) {\n                    const priority = pool.priority[index]\n                    for (let i = 0; i < priority; i++) {\n                        tempArr.push(item)\n                    }\n                }\n                else {\n                    tempArr.push(item)\n                }\n            })\n\n            this.#poolQueue[pool.id] = (pool.type === \"random\") ? Utils.randomShuffle(tempArr) : tempArr\n            this.#poolPointer[pool.id] = 0\n        }\n    }\n\n    /**\n     * Schedule pattern item with delay so it can be cancelled/paused.\n     *\n     * @param {IPatternItem} item Pattern item to schedule.\n     * @param {string} parentId Id of pattern item belongs to.\n     * @param {number} index Index of item, used if multiple items with the same parentId.\n     * @param {IPlaySoundArgs|IPlayPoolArgs|IPlayPatternArgs|IPlayEnvelopeArgs} args Arguments\n     * to use when invoking the aappropriate method for the item type.\n     * @param {number} loopLength If specified, item will loop at specified length.\n     * @private\n     */\n    #scheduleItem(\n        item: Pattern,\n        parentId: string,\n        args: PlaySoundArgs | IPlayPoolArgs | IPlayPatternArgs | PlayEnvelopeArgs,\n        loopLength = 0\n    ) {\n        let id = null\n        let eventMethod = null\n        const now = this.#mixer.now()\n        parentId = parentId ? parentId : item.parentId\n        if (item.sound) {\n            id = item.sound\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playSound(id, args as PlaySoundArgs, parentId, false, loopLength > 0)\n            }\n        }\n        else if (item.pattern) {\n            id = item.pattern\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playPattern(id, args as IPlayPatternArgs, item.parentId)\n            }\n        }\n        else if (item.pool) {\n            id = item.pool\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playPool(id, args as IPlayPoolArgs, item.parentId)\n            }\n        }\n        else if (item.envelope && isPlayEnvelopeArgs(args)) {\n            id = item.envelope\n            const envTarget = item.bussId || item.soundId\n            eventMethod = (sTime: number) => {\n                args.startTime = sTime\n                this.playEnvelope(envTarget, args, parentId)\n            }\n        }\n        else {\n            logger().warn(\"[ecas] attempting to schedule unknown pattern item type. Item: \", item)\n            return\n        }\n        const startTime = Utils.defaultNumber(args.startTime, 0, this.#tempoConfig, now)\n        if (startTime === 0) {\n            eventMethod(startTime)\n        }\n        else {\n            const event: ISequenceEvent = {\n                eventMethod,\n                loopLength,\n                startTime,\n                id,\n                parentId,\n            }\n            this.#eventQueue.push(event)\n        }\n    }\n\n    #onUpdate() {\n        const currentTime = this.#mixer.now()\n        const calls = []\n        this.#eventQueue = this.#eventQueue.filter((item) => {\n            const isLooped = item.loopLength > 0\n            const eventHorizon = currentTime + TIME_LOOKAHEAD_SECONDS\n            if (item.startTime <= eventHorizon) {\n                calls.push({method: item.eventMethod, startTime: item.startTime})\n                if (isLooped) {\n                    item.startTime += item.loopLength\n                }\n                return isLooped\n            }\n            return true\n        })\n        calls.forEach((conf) => conf.method(conf.startTime))\n    }\n}\n", "import { AutomatableParameters, Automator, CurveCreator } from \"@netent-tech/ecas-automator\"\nimport { isSearchParamUsed, loadFromName, loadUsingSearchParam, logger, setLogger, type EcasLogger, type LoggerName } from \"@netent-tech/ecas-logger\"\nimport { isArray, isNonEmptyArray, isNumeric, isString, isTrue, noop } from '@netent-tech/ecas-utils'\nimport { logEcasVersion } from \"@netent-tech/ecas-version-display\"\nimport { AssetHandler } from \"./asset-handler\"\nimport { MASTER_BUS_ID, OUTPUT_BUS_ID, TIME_LOOKAHEAD_SECONDS } from \"./constants\"\nimport { ApplyEnvelopeOptions, BusConfig, CancelEnvelopeOptions, IAnalyseBusArgs, IApplyEnvelopeOptions, IBusApplyEnvelopeOptions, IBusApplyEnvelopeToInsertOptions, IBusIdArg, IEcasOptions, IPausePatternArgs, IPausePoolArgs, IPauseSoundArgs, IPlayEnvelopeArgs, IPlayPatternArgs, IPlayPoolArgs, IPlaySoundArgs, IResumePatternArgs, IResumePoolArgs, IResumeSoundArgs, isMusicalPosition, IStopPatternArgs, IStopPoolArgs, IStopSoundArgs, IStringMap, PreloadOnprogressType, Sound, TimeSignature } from \"@netent-tech/ecas-common\"\nimport { createPlayEnvelopeArgs, EnvelopeHandler } from \"./envelopes\"\nimport { EcasEvents, EventHandler } from \"./event-handler\"\nimport { Mixer } from \"./mixer\"\nimport { Bus } from \"./mixer/buses/Bus\"\nimport { AlgorithmicReverbInsert, AlgorithmicReverbInsertOptions, BiquadFilterInsert, BiquadFilterInsertOptions, ConvolverReverbInsert, ConvolverReverbInsertOptions, DelayInsert, DelayInsertOptions, DynamicsCompressorInsert, DynamicsCompressorInsertOptions, InsertClass, InsertClassAutomator, InsertOptions, InsertTypenames, is, PingPongDelayInsert, PingPongInsertOptions } from \"@netent-tech/ecas-inserts\"\nimport { createEcasOptions, EcasOptions } from \"./options-creator\"\nimport { IEcasApi } from \"./ecas-common\"\nimport { PlaySoundArgs } from \"./options-creator/PlaySoundArgs\"\nimport { StopSoundArgs } from \"./options-creator/StopSoundArgs\"\nimport { AnalyserConfig } from \"./other/AnalyserConfig\"\nimport { VolumeMeter } from \"./other/VolumeMeter\"\nimport { polyfill } from \"./polyfills\"\nimport { Timer } from \"./scheduling/Timer\"\nimport { Sequencer } from \"./sequencer/Sequencer\"\nimport { createTimeSignatureFromString, Utils } from \"./utils\"\n\nconst MATCH_EVERYTHING = /.*/\n\n/** Resolves when the time provided has passed using the AudioContext time\n * If the time is in the past, it will resolve immediately\n */\nfunction whenPromise(context: Readonly<Pick<AudioContext, 'createConstantSource'>>, when?: Readonly<number>) {\n    return new Promise<void>(resolve => {\n        const source = context.createConstantSource()\n        source.onended = () => resolve()\n        source.start(0)\n        source.stop(when)\n    })\n}\n\n/**\n * ECAS Works as a facade to make the methods in the ecas api accesible to games,\n * and to the eventHandler so it can interpret the eventConfig created by the sound designer\n * and trigger the public methods by applying the arguments supplied.\n **/\nexport class ECAS implements IEcasApi {\n    eventHandler: EventHandler\n    assetHandler: AssetHandler\n    ready: Promise<void> // resolves when all sounds that are set to be preloaded have been so\n\n    #mixer: Mixer\n    #audioContext: AudioContext\n    #envelopeHandler: EnvelopeHandler\n    #sequencer: Sequencer\n    #busMeters: IStringMap<VolumeMeter>\n    #options: EcasOptions\n\n    isMuted = false\n\n    constructor (config: IEcasOptions, audioContext?: AudioContext) {\n        logEcasVersion(logger().log)\n        this.#options = createEcasOptions(config)\n        const { soundConfig, eventConfig, stateConfig, loadrConfig } = this.#options\n        logger().debug('[ecas] config:', config)\n        logger().debug('[ecas] options:', this.#options)\n        logger().info('[ecas] file extension:', loadrConfig.fileExtToUse)\n\n        this.#audioContext = audioContext ?? new AudioContext()\n        // emit events whenever the AudioContext state changes\n        this.audioContext.addEventListener('statechange',  () => {\n            type PossibleStates = AudioContextState | 'interrupted'\n            const state = this.audioContext.state as PossibleStates\n            switch(state) {\n                case('running'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Running)\n                    break\n                case('closed'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Closed)\n                    break\n                case('suspended'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Suspended)\n                    break\n                // happens for example when iphone user locks screen\n                case('interrupted'):\n                    this.eventHandler.triggerAudioEvent(EcasEvents.Context.Interrupted)\n                    break\n                default:\n                    logger().error('[ecas] AudioContext statechange event triggered with unknown state:', state)\n                    break\n            }\n        })\n\n        this.eventHandler = new EventHandler(eventConfig, stateConfig, loadrConfig, this)\n        this.assetHandler = new AssetHandler({\n            ecasOptions: this.#options,\n            audioContext: this.#audioContext,\n            eventHandler: this.eventHandler\n        })\n        this.#envelopeHandler = new EnvelopeHandler()\n        this.#mixer = new Mixer(\n            this.#audioContext,\n            this.#options,\n            this.eventHandler,\n            this.assetHandler,\n            this.#envelopeHandler\n        )\n        Timer.dateProvider = () => this.#mixer.now.bind(this.#mixer)\n\n        this.#sequencer = new Sequencer(\n            this.#options,\n            this.#mixer,\n            this.eventHandler,\n            this.assetHandler,\n        )\n\n        this.setTempo(soundConfig.settings.tempo)\n        this.setTriggerQuantize(soundConfig.settings.triggerQuantize)\n        this.setTimeSignature(soundConfig.settings.timeSignature)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Ready)\n\n        this.shouldPauseOnInvisible = loadrConfig.pauseOnInvisible\n        this.shouldMuteOnInvisible = loadrConfig.muteOnInvisible\n        this.shouldResumeOnVisible = loadrConfig.resumeOnVisible\n    }\n\n    set shouldMuteOnInvisible(shouldMute: boolean) {\n        // if ecas is already muted before becoming invisible, we should not unmute it when the tab is visible again\n        let shouldBeUnmutedWhenVisible = !this.isMuted\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            if (state === \"hidden\") {\n                shouldBeUnmutedWhenVisible = !this.isMuted\n                this.mute()\n            }\n            else if (state === \"visible\" && shouldBeUnmutedWhenVisible) {\n                this.unmute()\n            }\n        }\n        if (shouldMute) {\n            addEventListener('visibilitychange', listener)\n        }\n        else {\n            removeEventListener('visibilitychange', listener)\n        }\n    }\n\n    // ECAS-1167: https://jira.evolution.com/browse/ECAS-1167\n    // this is here to fix ios playing sound when another tab is focused\n    set shouldPauseOnInvisible(shouldPause: boolean) {\n        let timeout: number | null = null\n\n        const isVisibilityPaused = {\n            is: false,\n            get: () => isVisibilityPaused.is,\n            set: (value: boolean) => {\n                isVisibilityPaused.is = value\n            }\n        }\n\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            logger().debug(\"[ecas] visibility\", state)\n\n            if (state === \"hidden\") {\n                isVisibilityPaused.set(true)\n                // not using the timer here because the timer is usually paused when going invisible\n                timeout = window.setTimeout(\n                    () => {\n                        // we check again here if it should indeed be paused\n                        // in case it changed during the timeout\n                        // maybe the user opened the tab again within a short time period\n                        if(isVisibilityPaused.get()) {\n                            this.pause().catch(logger().error)\n                        }\n                    },\n                    1000 // 500ms for fadeout, 500ms for leeway\n                )\n            }\n            else if (state === \"visible\") {\n                isVisibilityPaused.set(false)\n                window.clearTimeout(timeout)\n                timeout = null\n            }\n        }\n        shouldPause\n            ? addEventListener('visibilitychange', listener)\n            : removeEventListener('visibilitychange', listener)\n    }\n\n    set shouldResumeOnVisible(shouldResume: boolean) {\n        const listener = (event: Event) => {\n            const state = event.target['visibilityState']\n            if (state === \"visible\") {\n                const resume = async () => {\n                    const isResumed = await this.resume().catch(() => false)\n                    if (!isResumed) {\n                        logger().debug(\"[ecas] failed to resume audio context using resume on visible\")\n                    }\n\n                }\n                resume().catch(logger().error)\n            }\n        }\n        shouldResume\n            ? addEventListener('visibilitychange', listener)\n            : removeEventListener('visibilitychange', listener)\n    }\n\n    get options() {\n        return this.#options\n    }\n\n    /**\n     * It's really important that audio context has been allowed to start\n     * before we initialize ecas\n     * so better to use this async static method that makes sure the audioContext has been started\n     * instead of the normal constructor\n     **/\n    static async create (ecasConfig: IEcasOptions) {\n        isSearchParamUsed() ?  loadUsingSearchParam() : loadFromName(ecasConfig.loadrConfig.logger)\n\n        logger().debug(\"[ecas] create\", ecasConfig)\n        polyfill(ecasConfig.loadrConfig.forcePolyfills)\n\n        const audioContext = new AudioContext()\n\n        return new Promise<ECAS>((resolve) => {\n            if (audioContext?.state === \"running\") {\n                resolve(new ECAS(ecasConfig, audioContext))\n                return\n            }\n            logger().log(\"[ecas] waiting for user interaction so we can start audio context...\")\n            const oninteraction = () => {\n                const audioContext = new AudioContext()\n                resolve(new ECAS(ecasConfig, audioContext))\n                removeEventListener('click', oninteraction)\n                removeEventListener(\"keypress\", oninteraction)\n                removeEventListener(\"touchstart\", oninteraction)\n            }\n\n            window.addEventListener(\"click\", oninteraction, {once: true})\n            window.addEventListener(\"keypress\", oninteraction, {once: true})\n            window.addEventListener(\"touchstart\", oninteraction, {once: true})\n        })\n    }\n\n    /**\n     * Use to set logger as either \"console\" or \"timestamp\". Defaults to \"none\"\n     * @param name \"none\" | \"console\" | \"timestamp\"\n     */\n    setLogger(name: LoggerName): void {\n        loadFromName(name)\n    }\n\n    /**\n     * Use to provide a custom logger\n     *\n     * A custom logger can look loke this:\n     * @example\n     * ```\n     * const logger = new class {\n     *   format = (...args: any[]) => [`Custom-logger:`, ...args]\n     *\n     *   debug = (...args: any[]) => console.debug(...this.format(...args))\n     *   log = (...args: any[]) => console.log(...this.format(...args))\n     *   info = (...args: any[]) => console.log(...this.format(...args))\n     *   warn = (...args: any[]) => console.warn(...this.format(...args))\n     *   error = (...args: any[]) => console.error(...this.format(...args))\n     *   table = (...args: any[]) => console.table(...this.format(...args))\n     *   trace = (...args: any[]) => console.trace(...this.format(...args))\n     * }()\n     * ```\n     */\n    setCustomLogger (logger: EcasLogger ): void {\n        setLogger(logger)\n    }\n\n    get soundHandler () {\n        return this.#mixer.assetHandler.soundHandler\n    }\n\n    #preloadOnprogressDefault = (sucess: boolean, count: number, numberOfSoundsToPreload: number) => {\n        logger().debug(\"[ecas] preload onprogress\", {sucess, count, numberOfSoundsToPreload})\n    }\n\n    async preload(onprogress: PreloadOnprogressType = this.#preloadOnprogressDefault) {\n        logger().debug(\"[ecas] preload\")\n        const shouldPreload =\n            isTrue(this.#options.loadrConfig.preload)\n            || isNonEmptyArray(this.#options.loadrConfig.preload)\n\n        if (!shouldPreload) {\n            return\n        }\n\n        const soundsToPreload = isArray(this.#options.loadrConfig.preload)\n            ? this.#options.loadrConfig.preload\n            : this.assetHandler.soundHandler.getAllSoundIds()\n\n        const numberOfSoundsToPreload = soundsToPreload.length\n\n        this.eventHandler.on(EcasEvents.Preload.Progress, onprogress)\n\n        let count = 0\n        const listener = () => {\n            count += 1\n            const success = true\n            this.eventHandler.triggerAudioEvent(\n                EcasEvents.Preload.Progress,\n                success,\n                count,\n                numberOfSoundsToPreload\n            )\n        }\n\n        this.eventHandler.on(\n            EcasEvents.Sound.LoadDone,\n            listener\n        )\n        this.eventHandler.triggerAudioEvent(EcasEvents.Preload.Start)\n\n        logger().debug(\"[ecas] preloading these sounds:\", soundsToPreload)\n        await this.assetHandler.soundHandler.load(soundsToPreload)\n\n        this.eventHandler.triggerAudioEvent(EcasEvents.Preload.Done)\n        this.eventHandler.off(\n            EcasEvents.Sound.LoadDone,\n            listener\n        )\n    }\n\n    get audioContext () {\n        return this.#audioContext\n    }\n\n    /** pauses the audio context and the timeouts set with Timer.setTimeout */\n    async pause() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Pause)\n        await this.pauseContext().catch(logger().error)\n        // pause all timeouts set with Timer.setTimeout\n        this.eventHandler.triggerAudioEvent(EcasEvents.Timer.Pause)\n        Timer.pauseMatching(MATCH_EVERYTHING)\n    }\n\n    /** returns true if context was resumed, false if there was an error */\n    async resume() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Resume)\n        return this.resumeContext().then(() => {\n            // resume all timeouts set with Timer.setTimeout after the context has been resumed\n            this.eventHandler.triggerAudioEvent(EcasEvents.Timer.Resume)\n            Timer.resumeMatching(MATCH_EVERYTHING)\n            return true\n        }).catch(() => false)\n    }\n\n    async pauseContext () {\n        logger().debug('[ecas] pause - before:', this.#audioContext.state)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Context.Pause)\n        if (this.#audioContext.state === \"running\") {\n            await this.#audioContext.suspend().catch(logger().error)\n            logger().debug('[ecas] pause - after:', this.#audioContext.state)\n        }\n    }\n\n    async resumeContext () {\n        logger().debug('[ecas] resume - before:', this.#audioContext.state)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Context.Resume)\n        if (this.#audioContext.state === \"running\") {\n            logger().debug('[ecas] audio context is already running')\n            return true\n        }\n        if (this.#audioContext.state === \"closed\") {\n            logger().warn(\"[ecas] audio context is closed, cannot resume.\")\n            return false\n        }\n        const promise = new Promise<AudioContextState>((resolve) => {\n            const listener = () => this.#audioContext.resume()\n            const remover = () => {\n                removeEventListener(\"onclick\", listener)\n                removeEventListener(\"keypress\", listener)\n                removeEventListener(\"touchstart\", listener)\n                resolve(this.#audioContext.state)\n            }\n            window.addEventListener(\"onclick\", listener)\n            window.addEventListener(\"keypress\", listener)\n            window.addEventListener(\"touchstart\", listener)\n            listener()\n                .then(remover)\n                .catch((reason) => {\n                    logger().warn(\"[ecas] failed to resume audio context\", reason)\n                    resolve(this.#audioContext.state)\n                })\n        })\n        const state = await promise.catch(logger().error)\n        logger().debug('[ecas] resume - after:', state)\n        return state === \"running\"\n    }\n\n    setMasterVolume(gain: number) {\n        logger().debug('[ecas] setMasterVolume', gain)\n        if (!this.isMuted) {\n            this.busSetGain({busId: MASTER_BUS_ID, gain})\n            return\n        }\n        logger().debug(\"[ecas] tried to set gain while muted.\")\n    }\n\n    getMasterVolume() {\n        return this.#mixer.buses.get(MASTER_BUS_ID).gain.value\n    }\n\n    get mixer (): Readonly<Mixer> {\n        return this.#mixer\n    }\n\n    muteUnmute() {\n        this.isMuted\n            ? this.unmute()\n            : this.mute()\n    }\n\n    unmute() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Unmute)\n        if (!this.isMuted) {\n            return\n        }\n        this.isMuted = false\n\n        this.busApplyEnvelope({\n            busId: OUTPUT_BUS_ID,\n            paramId: \"gain\",\n            points: [\n                {pos: 0, val: \"current\"},\n                {pos: 500, val: 1}\n            ]\n        })\n    }\n\n    mute() {\n        this.eventHandler.triggerAudioEvent(EcasEvents.Mute)\n        if (this.isMuted) {\n            return\n        }\n\n        this.busApplyEnvelope({\n            busId: OUTPUT_BUS_ID,\n            paramId: \"gain\",\n            points: [\n                {pos: 0, val: \"current\"},\n                {pos: 500, val: 0}\n            ]\n        })\n        this.isMuted = true\n    }\n\n    getAudioContext() {\n        return this.#audioContext\n    }\n\n    /**\n     * Convenience function to get target target time from now from a provided duration\n     * @returns current time + your duration + lookahead\n     */\n    #chrono(durationSeconds = 0) {\n        return this.#audioContext.currentTime\n            + TIME_LOOKAHEAD_SECONDS\n            + Math.max(durationSeconds, 0)\n    }\n\n    /**\n     * Get current global playback position.\n     * @return {number} Current position since engine started in seconds.\n     */\n    now(): number {\n        return this.#mixer.now()\n    }\n\n    /**\n     * Gets a list of all of the currently playing sounds.\n     */\n    getActiveSounds(): string[] {\n        return this.#mixer.getActiveSounds()\n    }\n\n    /* * * * * * * * * * * * *  MainApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Trigger an audio event by forwarding the event to the adapter.\n     * @param event The event string.\n     * @param args An arbitrary array of arguments.\n     */\n    async triggerGameEvent(event: string, ...args: unknown[]) {\n        this.eventHandler.triggerGameEvent(event, ...args)\n    }\n\n    async dispose() {\n        logger().debug('[ecas] dispose')\n        this.stopAll()\n        if (this.#busMeters) {\n            Object.keys(this.#busMeters).forEach(this.busRemoveAnalyser)\n        }\n        this.#mixer.dispose()\n        this.eventHandler.dispose()\n        this.assetHandler.dispose()\n        this.#envelopeHandler.dispose()\n        await this.pauseContext()\n        await this.#audioContext.close()\n        // Todo: implement dispose for sequencer\n        this.eventHandler = null\n        this.assetHandler = null\n        this.#mixer = null\n        this.isMuted = true\n        this.#options = null\n    }\n\n\n    /* * * * * * * * * * * * *  TempoApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Set global tempo.\n     * Note that there is no timestretching or pitching of sounds, so use this with caution!\n     * Instead configure patterns with sounds in specific tempo, and set tempo property of pattern.\n     * Simply modifying this value on an existing sound will mean that looping will become off.\n     *\n     * If you have a pattern with delayed synced items (i.e. delay specified using \"bar.beat.tick\")\n     * and is only triggering individual hits, you could modify this value to speed up or slow the sequence.\n     *\n     * @param {number} tempo\n     */\n    setTempo(tempo: number) {\n        logger().debug('[ecas] setTempo', tempo)\n        this.#sequencer.setTempo(tempo)\n    }\n\n    /**\n     * Update trigger quantize setting.\n     *\n     * @param {number|string} input Trigger quantize value to use. Should be 8,4,2 0r 1 whole bars,\n     * or franction of whole note - 0.5, 0.25, 0.125, 0.0625 (alternatively 1/2, 1/4, 1/8, 1/16)\n     */\n    setTriggerQuantize(input: number | string) {\n        logger().debug('[ecas] setTriggerQuantize', input)\n        this.#sequencer.setTriggerQuantize(Utils.defaultNumber(input))\n    }\n\n    /**\n     * Update time signature setting.\n     *\n     * @param {string} timeSignature Meter to use, string such as '4/4', '3/4' or '6/8'.\n     */\n    setTimeSignature(timeSignature: TimeSignature) {\n        logger().debug('[ecas] setTimeSignature', timeSignature)\n        this.#sequencer.setTimeSignature(\n            createTimeSignatureFromString(timeSignature) || { meter: 4, unit: 4 }\n        )\n    }\n\n    /* * * * * * * * * * * * *  AssetLoadingApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    async loadAllSounds() {\n        logger().debug(\"[ecas] loadAllSounds\")\n        await this.assetHandler.soundHandler.loadAll()\n    }\n\n    async loadTheseSounds(ids: Sound['id'][]) {\n        logger().debug(\"[ecas] loadTheseSounds\", ids)\n        await this.assetHandler.soundHandler.load(ids)\n    }\n\n    async loadTheseEvents(ids: string[]) {\n        logger().debug(\"[ecas] loadTheseEvents\", ids)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Events.LoadStart)\n        await this.assetHandler.loadAssetsRelatedToEvents(ids)\n        this.eventHandler.triggerAudioEvent(EcasEvents.Events.LoadDone)\n    }\n\n\n    /* * * * * * * * * * * * *  EnvelopeApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play envelope immediately\n     *\n     * @param {string} id Id of bus or sound to modulate. Use 'type' property\n     * in IPlayEnvelopeArgs to define type of target, e.g. \"bus\" or \"sound\".\n     * @param {IPlayEnvelopeArgs} args Play envelope configuration object\n     */\n    playEnvelope(id: BusConfig['id'] | Sound['id'], args: IPlayEnvelopeArgs = {}) {\n        logger().debug('[ecas] playEnvelope', id)\n        const initializedArgs = createPlayEnvelopeArgs(args)\n        this.#sequencer.playEnvelope(id, initializedArgs, id)\n    }\n\n    applyEnvelope<T extends readonly string[]>({automator, paramId, curve, points, delay}: {automator: Automator<T>} & IApplyEnvelopeOptions<T>) {\n        const when = this.audioContext.currentTime + (delay || 0)\n        /**\n         * note: getting current won't wait for delay supplied,\n         * to do that we would have to wait to calculate the points and curves until just before scheduling them\n         * which is not great for performance and accurate timing.\n         **/\n        const getRealValues = ({val}: {val: \"current\" | \"default\" | number}) => {\n            if(val === \"default\") {\n                return automator.getDefault(paramId)\n            }\n            if(val === \"current\") {\n                return automator.current(paramId)\n            }\n            return val\n        }\n        const values = points.map(getRealValues)\n        const positions = points.map(({pos}) => pos)\n        const [valueCurve, duration] = CurveCreator[curve || \"linear\"]([values, positions])\n        automator.automate({paramId, valueCurve, when, duration})\n        return whenPromise(this.#audioContext, when)\n    }\n\n    /** Will cancel all scheduled values for the provided parameter */\n    cancelEnvelope<T extends readonly string[]>({automator, paramId, delay}: {automator: Automator<T>, paramId: T[number], delay?: number}) {\n        const when = this.audioContext.currentTime + (delay || 0)\n        automator.cancel({paramId, when})\n        return whenPromise(this.#audioContext, when)\n    }\n\n\n    /* * * * * * * * * * * * *  PatternApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play pattern immediately\n     *\n     * @param {string} id Id of pattern to play.\n     * @param {IPlayPatternArgs} args Play pattern configuration object\n     */\n    playPattern(id: string, args?: IPlayPatternArgs) {\n        logger().debug('[ecas] playPattern', id)\n        args = Utils.defaultValue(args, {})\n\n        args.onEnded = Utils.defaultValue(args.onEnded, noop)\n\n        if (args.startTime && !isMusicalPosition(args.startTime)) {\n            args.startTime = Utils.defaultNumber(args.startTime) / 1000\n        }\n\n        if (args.duration && !isMusicalPosition(args.duration)) {\n            args.duration = Utils.defaultNumber(args.duration) / 1000\n        }\n\n        if (args.startPos && !isMusicalPosition(args.startPos)) {\n            args.startPos = Utils.defaultNumber(args.startPos) / 1000\n        }\n\n        const pattern = this.#options.soundConfig.patterns.reduce((acc, curr) => (curr.id === id ? curr : acc))\n\n        if (pattern.timeSignature) {\n            this.setTimeSignature(pattern.timeSignature)\n        }\n\n        if (pattern.tempo) {\n            this.setTempo(pattern.tempo)\n        }\n\n        this.#sequencer.playPattern(id, args)\n    }\n\n    /**\n     * Pause pattern.\n     *\n     * @param {string} id Id of pattern to pause\n     * @param {IPausePatternArgs} args Pause pattern configuration object. Optional.\n     */\n    pausePattern(id: string, args?: IPausePatternArgs) {\n        logger().debug('[ecas] pausePattern', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pausePattern(id, args.delay)\n    }\n\n    /**\n     * Resume paused pattern.\n     *\n     * @param {string} id Id of pattern to resume\n     * @param {IResumePatternArgs} args Resume pattern configuration object. Optional.\n     */\n    resumePattern(id: string, args?: IResumePatternArgs) {\n        logger().debug('[ecas] resumePattern', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumePattern(id, args.delay, id)\n    }\n\n\n    /**\n     * Stop pattern.\n     *\n     * @param {string} id Id of pattern to stop.\n     * @param {IStopPatternArgs} args Stop pattern configuration object. Optional.\n     */\n    stopPattern(id: string, args: IStopPatternArgs = {}) {\n        logger().debug('[ecas] stopPattern')\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.stopPattern(id, args.delay)\n    }\n\n    /* * * * * * * * * * * * *  PoolApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play Pool immediately.\n     *\n     * @param {string} id Id of Pool to play\n     * @param {IPlayPoolArgs} args Play pool configuration object\n     */\n    playPool(id: string, args?: IPlayPoolArgs) {\n        logger().debug('[ecas] playPool;', id)\n        args = Utils.defaultValue(args, {})\n\n        args.volume = Utils.defaultNumber(args.volume, 1)\n        args.pan = Utils.defaultNumber(args.pan)\n        args.loop = Utils.defaultValue(args.loop, false)\n        args.pitch = Utils.defaultNumber(args.pitch)\n        args.startItem = Utils.defaultNumber(args.startItem, null)\n        args.onEnded = Utils.defaultValue(args.onEnded, null)\n        args.onItemEnded = Utils.defaultValue<string | (() => void)>(args.onItemEnded, noop)\n\n        if (args.startTime && !isMusicalPosition(args.startTime)) {\n            args.startTime = Utils.defaultNumber(args.startTime) / 1000\n        }\n\n        if (args.duration && !isMusicalPosition(args.duration)) {\n            args.duration = Utils.defaultNumber(args.duration) / 1000\n        }\n\n        if (args.startPos && !isMusicalPosition(args.startPos)) {\n            args.startPos = Utils.defaultNumber(args.startPos) / 1000\n        }\n\n        this.#sequencer.playPool(id, args)\n    }\n\n    /**\n     * Reset pool to index 0.\n     *\n     * @param {string} id Id of Pool to play.\n     */\n    resetPool(id: string) {\n        logger().debug('[ecas] resetPool', id)\n        this.#sequencer.resetPool(id)\n    }\n    /**\n     * Pause Pool.\n     *\n     * @param {string} id Id of Pool to pause\n     * @param {IPausePoolArgs} args Pause pool configuration object\n     */\n    pausePool(id: string, args: IPausePoolArgs = {}) {\n        logger().debug('[ecas] pausePool', id)\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pausePool(id, args.delay)\n    }\n\n    /**\n     * Resume paused Pool.\n     *\n     * @param {string} id Id of pool to resume\n     * @param {IResumePoolArgs} args Resume pool configuration object\n     */\n    resumePool(id: string, args?: IResumePoolArgs) {\n        logger().debug('[ecas] resumePool', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumePool(id, args.delay)\n    }\n    /**\n     * Stop Pool.\n     *\n     * @param {string} id Id of sequence to stop.\n     * @param {IStopPoolArgs} args Stop pool configuration object. Optional.\n     */\n    stopPool(id: string, args: IStopPoolArgs = {}) {\n        logger().debug('[ecas] stopPool')\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.stopPool(id, args.delay)\n    }\n\n    /* * * * * * * * * * * * *  SoundApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Play sound immediately.\n     *\n     * @param {string} id Id of sound to play.\n     * @param {IPlaySoundArgs} args Play sound configuration object. Optional.\n     */\n    async playSound(id: Sound['id'], args: IPlaySoundArgs = {}) {\n        logger().debug('[ecas] playSound', id)\n\n        if (args.loop) {\n            if (args.duration) {\n                logger().warn(\"[ecas] playSound:\", id, \"duration argument will not work when loop is true\")\n            }\n            if (args.fadeOut) {\n                logger().warn(\"[ecas] playSound:\", id, \"fadeout argument will not work when loop is true\")\n            }\n        }\n\n        const sound = this.assetHandler.soundHandler.getSound(id)\n        const initializedArgs = new PlaySoundArgs(args)\n        const play = () => this.#sequencer.playSound(sound.id, initializedArgs)\n\n        // if we can load the sound synchronously, do it\n        const details = this.assetHandler.soundHandler.details.get(id)\n        if (details !== undefined && details.isLoaded) {\n            return play()\n        }\n\n        // otherwise, load the sound asynchronously and play it when it's ready\n        // can't play sound before buffer exists\n        // if buffer has already been loaded soundHandler will return already existing buffer\n        const loadPromise = this.assetHandler.soundHandler.load([id])\n        return loadPromise.then(play).catch(logger().error)\n    }\n\n\n    /**\n     * Stop sound.\n     *\n     * @param {string} id Id of sequence to stop.\n     * @param {IStopSoundArgs} args Stop sound configuration object. Optional.\n     */\n    stopSound(id: string, args: IStopSoundArgs = {}) {\n        logger().debug('[ecas] stopSound', id, {args})\n        const initializedArgs = new StopSoundArgs(args)\n        this.#sequencer.stopSound(id, initializedArgs)\n    }\n\n    /**\n     * Resume paused sound.\n     *\n     * @param {string} id Id of sound to resume\n     * @param {IResumeSoundArgs} args Resume sound configuration object\n     */\n    resumeSound(id: string, args?: IResumeSoundArgs) {\n        logger().debug('[ecas] resumeSound', id)\n        args = Utils.defaultValue(args, {})\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.resumeSound(id, args.delay)\n    }\n\n    /**\n     * Pause sound.\n     *\n     * @param {string} id Id of sound to pause\n     * @param {IPauseSoundArgs} args Pause sound configuration object\n     */\n    pauseSound(id: string, args: IPauseSoundArgs = {}) {\n        logger().debug('[ecas] pauseSound', id)\n        if (isNumeric(args.delay)) {\n            args.delay = Utils.defaultNumber(args.delay) / 1000\n        }\n        this.#sequencer.pauseSound(id, args.delay)\n    }\n\n    /**\n     * Stop all playing sounds.\n     */\n    stopAll(options: {onEnded?: string} = {}) {\n        logger().debug('[ecas] stopAll')\n        this.#sequencer.stopAll(options)\n    }\n\n    /* * * * * * * * * * * * *  BusApi * * * * * * * * * * * * * * * * * * * * * * * * * */\n\n    /**\n     * Should typically not need to be accessed publicly, but can be useful for testing\n     * purposes.\n     */\n    busGet({busId}: {busId: string}): Bus {\n        logger().debug('[ecas] busGet', busId)\n        return this.#mixer.buses.get(busId)\n    }\n\n    busSetGain({busId, gain}: {busId: string, gain: number}) {\n        this.#mixer\n            .buses.get(busId)\n            .automator.get(\"gain\")\n            .value = gain\n    }\n\n    busAddInsert<T extends InsertTypenames>({busId, typename, ...options}: IBusIdArg & {typename: T} & InsertOptions<T>) {\n        if (isString(busId)) busId = [busId]\n        return busId.map((busId: string) => this.#mixer\n            .buses.get(busId)\n            .inserts.create(typename, options)\n        )\n    }\n\n    /**\n     * All and any insert with this id will be removed from the insert graph\n     * So make sure you use unique id's when you create the inserts please thank you.\n     */\n    busRemoveInsert({busId, insertId}: IBusIdArg & {insertId: string}) {\n        if (isString(busId)) busId = [busId]\n        return busId.map((busId: string) => this.mixer.buses.get(busId).inserts.remove(insertId))\n    }\n\n    /**\n     * @param options\n     *  - busId:\n     *      target bus(es) that insert will live on\n     *  - id:\n     *      unique name of the filter\n     *  - Q:\n     *      filter steepness, 0.0001 to 1000\n     *  - frequency:\n     *      crossover frequency in hZ: 10, to nyquist\n     *  - gain:\n     *      in decibels\n     *  - detune:\n     *      basically the same as frequency...\n     */\n    busAddFilter(options: IBusIdArg & BiquadFilterInsertOptions) {\n        return this.busAddInsert({typename: BiquadFilterInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     *  - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     */\n    busAddCompressor(options: IBusIdArg & DynamicsCompressorInsertOptions) {\n        return this.busAddInsert({typename: DynamicsCompressorInsert.typename, ...options})\n    }\n\n    /**\n     * @param busId target bus that insert to be modified lives on\n     * @param options\n     */\n    busAddAlgorithmicReverb(options: IBusIdArg & AlgorithmicReverbInsertOptions) {\n        return this.busAddInsert({typename: AlgorithmicReverbInsert.typename, ...options})\n    }\n    /**\n    * @param options -\n    *  - busId:\n    *      target bus(es) that insert will live on\n    * - id:\n    *       the name of the insert\n    * - mix:\n    *       The amount of effect to be applied to the signal. Defaults to 1 (100%).\n    * - impulseResponse:\n    *       the id of the sound to use for impulse\n    * - mix:\n    *       wetness 0 - 1, default 1\n    * - normalize:\n    *       should the impulse response file be peak normalized\n    * - reverse:\n    *       should the impulse signal be reversed\n    */\n    busAddConvolverReverb(options: IBusIdArg & ConvolverReverbInsertOptions) {\n        return this.busAddInsert({typename: ConvolverReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     *  - busId:\n     *      target bus(es) that insert will live on\n     * - id: The name of the insert\n     * - maxDelayTime:\n     *     The maximum delay time for the node, in seconds. Defaults to 1.\n     * - delayTime:\n     *      The initial delay time for the node, in seconds. The default is 0.\n     * - feedback:\n     *      The amount of feedback, between 0, 1. Default 0.2\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     */\n    busAddDelay(options: IBusIdArg & DelayInsertOptions) {\n        return this.busAddInsert({typename: DelayInsert.typename, ...options})\n    }\n\n    busAddPingPongDelay(options: IBusIdArg & PingPongInsertOptions) {\n        return this.busAddInsert({typename: PingPongDelayInsert.typename, ...options})\n    }\n\n    busModifyInsert<T extends InsertTypenames>({busId, typename, duration, ...options}: IBusApplyEnvelopeOptions & {typename: T} & InsertClass<T>[\"getOptions\"]) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => {\n            const insert = this.#mixer.buses.get(busId).inserts.get(options.id)\n            if (is(insert, typename)) {\n                const endTime = this.#chrono(duration)\n                insert.modify(options, endTime, this.#audioContext.sampleRate)\n            }\n        }\n        return Promise.all(busId.map(applier))\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     *      min: 0, max: 1, default: 1 (100%)\n     * - time:\n     *      in seconds, min: 0.001, max: 10, default: 0.2\n     * - decay:\n     *      in seconds,min: 0.001, max: 10, default: 0.2\n     * - reverse:\n     *      is it a good idea to reverse time?\n     * - duration: - the amount of time, in seconds, to reach target options\n     */\n    busModifyAlgorithmicReverb(options: IBusApplyEnvelopeOptions & AlgorithmicReverbInsertOptions) {\n        return this.busModifyInsert({typename: AlgorithmicReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the insert\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     * - impulseResponse:\n     *      the id of the sound to use for impulse\n     * - mix:\n     *      wetness 0 - 1, default 1\n     * - normalize:\n     *      should the impulse response file be peak normalized\n     * - reverse:\n     *      should the impulse signal be reversed\n     * - duration - the amount of time, in seconds, to reach target options\n     */\n    busModifyConvolverReverb(options: IBusApplyEnvelopeOptions & ConvolverReverbInsertOptions) {\n        return this.busModifyInsert({typename: ConvolverReverbInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      the name of the delay\n     * - maxDelayTime:\n     *     The maximum delay time for the node, in seconds. Defaults to 1.\n     * - delayTime:\n     *      The initial delay time for the node, in seconds. The default is 0.\n     * - feedback:\n     *      The amount of feedback, between 0, 1. Default 0.2\n     * - mix:\n     *      The amount of effect to be applied to the signal. Defaults to 1 (100%).\n     * - duration - the amount of time, in seconds, to reach target options\n     */\n    busModifyDelay(options: IBusApplyEnvelopeOptions & DelayInsertOptions) {\n        return this.busModifyInsert({typename: DelayInsert.typename, ...options})\n    }\n\n    /**\n     * @param options -\n     * - busId:\n     *      target bus(es) that insert will live on\n     *  - id: name of your insert\n     *  - Q:\n     *      filter steepness, 0.0001 to 1000\n     *  - frequency:\n     *      crossover frequency in hZ: 10, to nyquist\n     *  - gain:\n     *      in decibels\n     *  - detune:\n     *      basically the same as frequency...\n     * - duration\n     */\n    busModifyFilter(options: IBusApplyEnvelopeOptions & BiquadFilterInsertOptions) {\n        return this.busModifyInsert({typename: BiquadFilterInsert.typename, ...options})\n    }\n\n    /**\n     * @param options\n     * - busId:\n     *      target bus(es) that insert will live on\n     * - id:\n     *      id use the same id as when you did addFilterToBus\n     * - threshold:\n     *      the decibel value above which the compression will start taking effect.\n     * - knee:\n     *      a decibel value representing the range above the threshold where the curve smoothly transitions to the compressed portion.\n     * - ratio:\n     *      representing the amount of change, in dB, needed in the input for a 1 dB change in the output.\n     * - reduction:\n     *      A float representing the amount of gain reduction currently applied by the compressor to the signal.\n     * - attack:\n     *      representing the amount of time, in seconds, required to reduce the gain by 10 dB.\n     * - release:\n     *      representing the amount of time, in seconds, required to increase the gain by 10 dB.\n     * - duration\n     */\n    busModifyCompressor (options: IBusApplyEnvelopeOptions & DynamicsCompressorInsertOptions) {\n        return this.busModifyInsert({typename: DynamicsCompressorInsert.typename, ...options})\n    }\n\n    /**\n     * Analyse bus.\n     *\n     * @param {IAnalyseBusArgs} args Analyse bus configuration object. Optional.\n     */\n    busAnalyse(args: IAnalyseBusArgs = {}) {\n        args.callback = Utils.defaultValue(args.callback, noop)\n        args.bus = Utils.defaultValue(args.bus, \"master\")\n        args.config = Utils.defaultValue(args.config, new AnalyserConfig())\n\n        // TODO: Temporarily we just set up a VU meter here, useful in e2e tests.\n        // Post MVP the analyzer spec will be defined, and API as well as features will change\n        const smoothingTime = args.config ? args.config.smoothingTimeConstant : 0.95\n        if (!this.#busMeters) {\n            this.#busMeters = {}\n        }\n        const meter: VolumeMeter = new VolumeMeter(smoothingTime, (data) => {\n            args.callback(args.bus, data)\n        })\n        this.#busMeters[args.bus] = meter\n        const analyser = meter.create(this.#audioContext)\n        this.#mixer.buses.get(args.bus).output.connect(analyser)\n    }\n\n\n    /**\n     * Remove an analyser from a bus. If not removed analyser will keep running, eating precious CPU cycles.\n     *\n     * @param {string} busId ID of bus to remove analyser from.\n     */\n    busRemoveAnalyser(busId: string) {\n        busId = Utils.defaultValue(busId, MASTER_BUS_ID)\n        this.#busMeters[busId].destroy()\n    }\n\n    busApplyEnvelope({busId, ...options}: IBusIdArg & ApplyEnvelopeOptions<Bus>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.applyEnvelope({automator: this.mixer.buses.get(busId).automator, ...options})\n        return Promise.all(busId.map(applier))\n    }\n\n    busCancelEnvelope({busId, ...options}: IBusIdArg & CancelEnvelopeOptions<Bus>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.cancelEnvelope({automator: this.mixer.buses.get(busId).automator, ...options})\n        return Promise.all(busId.map(applier))\n    }\n\n    busCancelEnvelopeOnInsert({busId, insertId, ...options}: IBusApplyEnvelopeToInsertOptions & CancelEnvelopeOptions<Bus>): Promise<void[]> {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => this.cancelEnvelope({\n            automator: this.mixer\n                .buses.get(busId)\n                .inserts.get(insertId)\n                .automator as any,\n            ...options\n        })\n        return Promise.all(busId.map(applier))\n    }\n\n\n    /** Chose to put all args in object for these functions becasuse argument list was becoming long, not sure how we should do with the api methods with less arguments\n     * Also these aren't strictly necessary since you can use busApplyEnvelopeToInsert and all you need to do extra is specify typename for the insert\n     */\n    // busApplyEnvelopeToCompressor(options: {busId: string, insertId: string} & ApplyEnvelopeOptions<DynamicsCompressorInsert>) {\n    busApplyEnvelopeToCompressor(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<DynamicsCompressorInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: DynamicsCompressorInsert.typename})\n    }\n\n    busApplyEnvelopeToAlgorithmicReverb(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<AlgorithmicReverbInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: AlgorithmicReverbInsert.typename})\n    }\n\n    busApplyEnvelopeToFilter(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<BiquadFilterInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: BiquadFilterInsert.typename})\n    }\n\n    busApplyEnvelopeToDelay(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<DelayInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: DelayInsert.typename})\n    }\n\n    busApplyEnvelopeToPingPongDelay(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<PingPongDelayInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: PingPongDelayInsert.typename})\n    }\n\n    busApplyEnvelopeToConvolverReverb(options: IBusApplyEnvelopeToInsertOptions & ApplyEnvelopeOptions<ConvolverReverbInsert>) {\n        return this.busApplyEnvelopeToInsert({...options, typename: ConvolverReverbInsert.typename})\n    }\n\n    /** We need the typename strictly for making sure we're not trying to configure the wrong type of insert */\n    busApplyEnvelopeToInsert<T extends InsertTypenames>({busId, insertId, typename, ...options}: IBusApplyEnvelopeToInsertOptions & {typename: T} & IApplyEnvelopeOptions<AutomatableParameters<InsertClass<T>>>) {\n        if (isString(busId)) busId = [busId]\n        const applier = (busId: string) => {\n            const insert = this.#mixer.buses.get(busId).inserts.get(insertId)\n            if (is(insert, typename)) {\n                // we assume that the automator has the correct type since we have checked that the insert is the specified type.\n                const automator = insert.automator as InsertClassAutomator<T>\n                return this.applyEnvelope({automator, ...options})\n            }\n            return Promise.reject(`no insert with id: ${insertId} found on bus: ${busId}`)\n        }\n        return Promise.all(busId.map(applier)) //forEach? do we use the returned values anywhere?\n    }\n    /** BusApi End */\n}\n", "/** @example\n * ```ts\n * ['game-start']\n * ['set-volume', 0.5]\n * ['play', 'sound-id']\n * ```\n */\ntype Events = Array<[Readonly<string>, ...readonly unknown[]]>\n\n/** use to store events to be triggered once AudioContext has been started / resumed */\nexport class EventQueue {\n  /** Store the events */\n  #events: Events = []\n\n  /** Add an event to the queue: `queue.add('a', 0).add('b', 1)` */\n  add (event: Readonly<string>, ...args: readonly unknown[]): this {\n    this.#events.push([event, ...args])\n    return this\n  }\n\n  /** Get the event at the specified index */\n  at (index: number): Readonly<Events[number]> | undefined {\n    return this.#events.at(index)\n  }\n\n  /** Get events and remove them from the queue.\n   * ```\n   * console.log(queue.length()) // 3\n   * for (const event of queue.drain()) {\n   *    console.log(event)\n   * }\n   * console.log(queue.length()) // 0\n   * ```\n   */\n  * drain (): Generator<Readonly<Events[number]>> {\n    let event = this.#events.shift()\n    while (event !== undefined) {\n      yield event\n      event = this.#events.shift()\n    }\n  }\n\n  length (): number {\n    return this.#events.length\n  }\n}\n", "import type { IEcasOptions } from '@netent-tech/ecas-common'\nimport { ECAS } from '@netent-tech/ecas-engine'\nimport { EventQueue } from './event-queue'\n\ntype Event = Readonly<[Readonly<string>, ...readonly unknown[]]>\n\nclass EcasProviderError extends Error {\n  constructor (message: string) {\n    super(message)\n    this.name = 'EcasProviderError'\n  }\n}\n\nexport const EcasProviderErrors = {\n  /** Thrown when trying to access recas before ready */\n  NOT_READY: new EcasProviderError('ecas is not ready')\n} as const\n\n/**\n * Can be used as a tiny API for ecas engine\n * Load and trigger events\n * Implementation of the audio behaviour in response to the events\n * should be done via the ecasOptions\n *\n * @example ```ts\n * import { EcasProvider } from '@netent-tech/ecas-provider'\n * import ecasConfig from './ecas-config.ts'\n * const audio = new EcasProvider()\n *   .withOptions(ecasConfig)\n *   .load()\n *   .trigger('game-event-that-should-be-run-whenever-audioContext-is-ready')\n *   .trigger('game-start-music)\n *   .trigger('set-volume', 0.5)\n *\n * audio.ready.then(displayVolumeSlider)\n * ```\n */\nexport class EcasProvider {\n  /**\n   * Get the instance of the audio engine itself\n   *\n   * @example```\n   * import { EcasProvider } from '@netent-tech/ecas-provider'\n   * const audio = new EcasProvider().load()\n   * await audio.ready\n   * setMuteButtonState(provider.ecas!.isMuted())\n   * setVolumeSliderPosition(provider.ecas!.getMasterVolume())\n   * ```\n   *\n   */\n  ecas: Readonly<ECAS> | undefined\n\n  /** Used for mocking in tests */\n  creator: typeof ECAS.create = ECAS.create\n\n  /** Stores events that are triggered before ecas has been initialized, drains when ecas is loaded (audioContext resolved). */\n  readonly queue: Readonly<EventQueue> = new EventQueue()\n\n  /** Store a reference to the options provided  */\n  options: Readonly<IEcasOptions> = { loadrConfig: {} }\n\n  /** Store a reference to the error handler provided */\n  onerror: (e: Error) => void = () => {}\n\n  /** Promise that resolves when ecas has been initialized */\n  ready: Readonly<Promise<Readonly<ECAS>>> =\n    new Promise<Readonly<ECAS>>(resolve => {\n      const id = setInterval(() => {\n        if (this.ecas !== undefined) {\n          clearInterval(id)\n          resolve(this.ecas)\n        }\n      }, 64)\n    })\n\n  /**\n   * @example ```ts\n   * import { EcasProvider } from '@netent-tech/ecas-provider'\n   * import ecasConfig from './ecas-config.ts'\n   * const audio = new EcasProvider()\n   *  .withOptions(ecasConfig)\n   * ```\n   *\n   * @defaultValue `{loadrConfig: {}}`\n   *\n   */\n  withOptions (options: Readonly<IEcasOptions>): this {\n    this.options = options\n    return this\n  }\n\n  /** Load ecas engine\n   * without this, `trigger` and `fire` will do nothing and `ready` will never resolve\n   */\n  load (): Readonly<this> {\n    this.creator(this.options).then(ecas => {\n      this.ecas = ecas\n      for (const event of this.queue.drain()) {\n        this.fire(...event)\n      }\n    }).catch(this.onerror)\n    return this\n  }\n\n  /**\n   * Use this to trigger game events that might be run before ecas has finished loading\n   * @example ```ts\n   * EcasProviderSingleton\n   *   .trigger('game-start')\n   *   .trigger('set-volume', 0.5)\n   * ```\n   * */\n  trigger (...event: Readonly<Event>): Readonly<this> {\n    this.ecas === undefined\n      ? this.maybeQueue(event)\n      : this.fire(...event)\n    return this\n  }\n\n  /**\n   * Use this if you want event to be run only if ecas is ready\n   * The recommended way is to use `trigger` instead\n   * together with a list of events that should always be triggered once ecas is done loading via\n   * like so: `ecasOptions.loadrConfig.ue` = `['game-start']`\n   * But if you know what you are doing, you can use this.\n   */\n  fire (...event: Readonly<Event>): Readonly<this> {\n    try {\n      this.ecas?.triggerGameEvent(...event).catch(this.onerror)\n    } catch (e) {\n      this.onerror(e as Error)\n    }\n    return this\n  }\n\n  /**\n   * Get ecas as required, will throw if ready has not resolved.\n   * otherwise exactly the same as EcasProvider.ecas\n   */\n  get requiredEcas (): Readonly<ECAS> {\n    if (this.ecas === undefined) {\n      throw EcasProviderErrors.NOT_READY\n    }\n    return this.ecas\n  }\n\n  async dispose (): Promise<void> {\n    const promise = this.ecas?.dispose().then(() => {\n      this.ecas = undefined\n    }).catch(this.onerror)\n    if (promise !== undefined) {\n      await promise\n      this.ecas = undefined\n    }\n  }\n\n  withOnerror (handler: (error: Error) => void): this {\n    this.onerror = handler\n    return this\n  }\n\n  withCreator (creator: typeof ECAS.create): this {\n    this.creator = creator\n    return this\n  }\n\n  /** depending on how the `queue` in `loadrConfig` is set up in the options we might want to queue this event **/\n  private readonly maybeQueue = (event: Readonly<Event>): void => {\n    function shouldQueue (name: Readonly<string>, queue: Readonly<IEcasOptions['loadrConfig']['queue']>): boolean {\n      return queue !== undefined && (queue === true || queue.includes(name))\n    }\n    if (shouldQueue(event[0], this.options.loadrConfig.queue)) {\n      this.queue.add(...event)\n    }\n  }\n}\n\n/**\n * @example ```\n * // audio.ts - if you have the ecas config locally\n * import { EcasProviderSingleton as Audio } from '@netent-tech/ecas-provider';\n * import ecasOptions from './ecas-config'\n * Audio.withOptions(ecasOptions).load()\n * export { Audio }\n *\n * // audio.ts - if you're fetching the ecas config from a server\n * import { EcasProviderSingleton as Audio } from '@netent-tech/ecas-provider';\n * (async (): Promise<void> => {\n *   const response = await fetch('url-to-ecas-config.json')\n *   const ecasOptions = await response.json()\n *   Audio.withOptions(ecasOptions).load()\n * })().catch(() => {})\n * export { Audio }\n *\n * // game.ts\n * Audio.trigger('splash-screen')\n * Audio.trigger('volume-set', 0.5)\n * Audio.trigger('spin')\n * ```\n **/\nexport const EcasProviderSingleton = new EcasProvider()\n", "import { EcasProviderSingleton as audio } from '@netent-tech/ecas-provider';\nimport { type IEcasOptions } from '@netent-tech/ecas-engine'\n(async (): Promise<void> => {\n  const searchParams = new URLSearchParams(window.location.search)\n  // make sure we can host the sounds locally without needing to run push and wait for github action\n  // by editing the url to include the ecas-load-path query param\n  const loadPath = searchParams.get('ecas-load-path') ?? 'https://jadujoel.github.io/template-sounds/'\n  const response = await fetch(`${loadPath}/config.json`)\n  const ecasOptions: IEcasOptions = await response.json()\n  ecasOptions.soundConfig!.settings!.loadPath = loadPath\n  audio.withOptions(ecasOptions).load()\n})().catch(console.log)\nexport { audio }\n", "import { EcasEvents } from \"@netent-tech/ecas-engine\"\nimport { audio } from \"./audio\"\n\nconst triggers = [\n  'start',\n  'spin',\n  'inactive',\n  'active',\n  'mute',\n  'unmute',\n  'stop',\n  'reverb_on',\n  'reverb_off'\n] as const\n\nclass Game {\n  load() {\n    // Make ecas respond to game triggers\n    triggers.forEach(trigger => add(trigger))\n\n    // Make game respond to ecas events.\n    audio.ready.then(ecas => {\n      ecas.eventHandler.on(EcasEvents.Sound.Ended, (name: string) => {\n        console.log('[game]: SOUND ENDED: ' + name)\n      })\n    })\n  }\n}\n\nfunction add(name: string, ...params: unknown[]) {\n  const listener = () => { audio.trigger(name, ...params) }\n  document.getElementById(name)?.addEventListener('click', listener)\n}\nexport const game = new Game()\n", "import { game } from './game'\ngame.load()\n"],
  "mappings": "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",
  "names": ["_map", "_a", "_b", "_a", "_b", "_map", "noop", "instance", "logger", "getLogger", "hasOwnProperty", "obj", "prop", "isDefined", "thing", "isUndefined", "isNotNull", "thing", "isNull", "exists", "isDefined", "isArray", "thing", "isNumber", "thing", "isFunction", "isString", "isNumeric", "isStringNumber", "noop", "_map", "_a", "_b", "_a", "_b", "_map", "_record", "_record", "fa", "ga", "t", "e", "n", "f", "AudioFileExtension", "typename", "_BusConfig", "busProps", "__publicField", "MASTER_BUS_ID", "BusConfig", "SoundEncoding", "props", "__publicField", "SoundEncoding_default", "TYPENAME", "Sound", "Be", "he", "Le", "_e", "Q", "e", "t", "i", "W", "o", "noop", "instance", "logger", "getLogger", "ce", "me", "n", "pe", "max", "input", "clamp", "min", "AssertionError", "__publicField", "Assert", "condition", "opt", "isString", "AssertIsDefined", "thing", "message", "isDefined", "AssertIsNotNull", "isNull", "AssertExists", "Exists", "isUndefined", "isNumber", "isNumeric", "isStringNumber", "_map", "_a", "_b", "getWetMixValue", "mix", "Fe", "getDryMixValue", "FILTER_TYPES", "xe", "we", "M", "U", "V", "r", "A", "$", "f", "R", "isFirefox", "userAgent", "StrictMapError", "StrictMap", "__privateAdd", "__privateGet", "key", "value", "callbackfn", "thisArg", "trySync", "func", "args", "err", "AutomatorError", "Automator", "automatableParameters", "j", "paramId", "valueCurve", "when", "duration", "d", "audioParam", "ie", "curveError", "He", "lastValue", "rampError", "timeoutIDs", "newTimeoutIds", "numValues", "durationPerValue", "id", "valueTime", "ms", "error", "defaultValue", "param", "TYPENAME", "AlgorithmicReverbInsert", "audioContext", "options", "S", "__spreadValues", "endTimeSeconds", "smoothingTimeSeconds", "D", "length", "impulse", "impulseL", "impulseR", "_BiquadFilterInsert", "context", "sampleRate", "MOST_POSITIVE_SINGLE_FLOAT_VALUE", "MOST_NEGATIVE_SINGLE_FLOAT_VALUE", "maxFrequency", "resolve", "ae", "BiquadFilterInsert", "ConvolverReverbInsert", "soundHandler", "shouldUpdateBuffer", "bufferPromise", "DelayInsert", "newId", "DynamicsCompressorInsert", "endTime", "PingPongDelayInsert", "ecasContext", "feedback", "time", "maxDelay", "EffectTypes", "v", "I", "T", "G", "b", "isMusicalPosition", "c", "regExp", "MASTER_BUS_ID", "TICKS_PER_BEAT", "barBeatTickToSeconds", "val", "tempoConfig", "now", "d", "parts", "bars", "beats", "ticks", "signatureDenom", "secPerUnit", "secPerBeat", "secPerBar", "secPerTick", "remainUntilQuantize", "barsTotalSeconds", "beatsTotalSeconds", "ticksTotalSeconds", "Utils", "detuneInCents", "d", "val", "Fe", "c", "parts", "v", "defaultValue", "tempoConfig", "now", "A", "k", "newVal", "Po", "barBeatTickToSeconds", "$", "values", "isValid", "rangeReg", "valueReg", "randomVal", "filterArr", "n", "range", "array", "arrayWithRandomNumbers", "volumeA", "volumeB", "a", "b", "panA", "panB", "pitchA", "pitchB", "posA", "posB", "props", "unique", "matches", "item", "key", "prop", "mix", "prefix", "time", "uniqueId", "match", "randomCharacter", "min", "max", "EcasEvents", "copyAudioBuffer", "options", "Oe", "copyAudioBufferDefault", "copyAudioBufferLegacy", "src", "trg", "i", "editedChannel", "originalChannel", "j", "createEmptyAudioBufferLike", "buffer", "audioContext", "reverseAudioBuffer", "bufferMutable", "channelNumber", "reversedData", "createReversedBuffer", "newBufferEmpty", "newBufferFilled", "_audioContext", "_details", "_buffers", "_reversedBuffers", "_sounds", "_eventHandler", "_createReversedBufferForSound", "createReversedBufferForSound_fn", "_audioContext", "_details", "_buffers", "_reversedBuffers", "_sounds", "_eventHandler", "_createReversedBufferForSound", "createReversedBufferForSound_fn", "id", "buffer", "reversed", "createReversedBuffer", "__privateGet", "_groups", "_pools", "_eventAssets", "_patternContexts", "_storeSoundsRelatedToEvents", "storeSoundsRelatedToEvents_fn", "_groups", "_pools", "_eventAssets", "_patternContexts", "_storeSoundsRelatedToEvents", "storeSoundsRelatedToEvents_fn", "ecasOptions", "events", "id", "actions", "__privateGet", "findSoundsUsedInActions", "soundsUsed", "action", "TIMEOUT_CALLERS", "typename", "EnvelopeContext", "config", "ze", "_contexts", "_contexts", "typename", "PlayEnvelopeArgs", "config", "ze", "A", "isPlayEnvelopeArgs", "thing", "createPlayEnvelopeArgs", "joinTimeoutCallers", "args", "createTimeoutCallerForPlayEnvelope", "arg", "caller", "TIMEOUT_CALLERS", "_Timer", "callback", "timeout", "start", "callbacks", "callerHandle", "id", "oldCaller", "newTimeout", "remaining", "__spreadProps", "__spreadValues", "now", "regex", "key", "match", "val", "Oe", "Timer", "Bu", "Ls", "Hu", "Vu", "ni", "t", "e", "n", "oi", "v", "noop", "instance", "logger", "getLogger", "ce", "me", "pe", "max", "input", "clamp", "min", "AssertionError", "__publicField", "Assert", "condition", "opt", "isString", "AssertIsDefined", "thing", "message", "isDefined", "AssertIsNotNull", "isNull", "AssertExists", "Exists", "isUndefined", "isNumber", "thing", "isString", "isNumeric", "isStringNumber", "_map", "_a", "_b", "getWetMixValue", "mix", "Fe", "getDryMixValue", "FILTER_TYPES", "xe", "we", "t", "e", "n", "M", "noop", "instance", "logger", "getLogger", "U", "V", "r", "A", "$", "f", "R", "isFirefox", "userAgent", "StrictMapError", "__publicField", "_map", "_a", "_b", "StrictMap", "__privateAdd", "__privateGet", "key", "value", "callbackfn", "thisArg", "trySync", "func", "args", "err", "AutomatorError", "Automator", "automatableParameters", "j", "paramId", "valueCurve", "when", "duration", "d", "audioParam", "ie", "curveError", "He", "lastValue", "rampError", "timeoutIDs", "newTimeoutIds", "numValues", "durationPerValue", "id", "i", "valueTime", "ms", "error", "defaultValue", "param", "TYPENAME", "AlgorithmicReverbInsert", "audioContext", "options", "S", "__spreadValues", "endTimeSeconds", "smoothingTimeSeconds", "D", "length", "impulse", "impulseL", "impulseR", "_BiquadFilterInsert", "context", "sampleRate", "MOST_POSITIVE_SINGLE_FLOAT_VALUE", "MOST_NEGATIVE_SINGLE_FLOAT_VALUE", "maxFrequency", "resolve", "ae", "BiquadFilterInsert", "ConvolverReverbInsert", "soundHandler", "shouldUpdateBuffer", "bufferPromise", "DelayInsert", "newId", "DynamicsCompressorInsert", "endTime", "PingPongDelayInsert", "ecasContext", "mix", "getDryMixValue", "getWetMixValue", "feedback", "time", "maxDelay", "_audioContext", "_soundHandler", "_id", "_inputNode", "_pannerNode", "_outputNode", "_audioContext", "_soundHandler", "_id", "_inputNode", "_pannerNode", "_outputNode", "_buses", "_busConnections", "_setupBuss", "_buses", "_busConnections", "_audioContext", "_soundHandler", "_setupBuss", "callOnEnded", "val", "eventHandler", "W", "c", "d", "_envelopeHandler", "_soundConnections", "_elementSoundSources", "_audioContext", "_soundContexts", "_options", "_eventHandler", "_assetHandler", "_onCompleteSound", "onCompleteSound_fn", "_stopSoundSource", "stopSoundSource_fn", "_disconnectNodes", "disconnectNodes_fn", "_getSoundContexts", "getSoundContexts_fn", "_envelopeHandler", "_soundConnections", "_elementSoundSources", "_audioContext", "_soundContexts", "_options", "_eventHandler", "_assetHandler", "_onCompleteSound", "onCompleteSound_fn", "id", "context", "when", "combinedId", "joinTimeoutCallers", "__privateMethod", "_stopSoundSource", "stopSoundSource_fn", "Timer", "TIMEOUT_CALLERS", "__privateGet", "ctx", "EcasEvents", "callOnEnded", "parentId", "soundSource", "bussId", "connections", "node", "isSoundSourceParams", "checkEffectAndDisconnect", "connection", "_disconnectNodes", "disconnectNodes_fn", "err", "d", "connectionNode", "effect", "_getSoundContexts", "getSoundContexts_fn", "contexts", "PlaySoundArgs", "options", "ze", "_a", "_b", "_c", "Utils", "Po", "StopSoundArgs", "A", "_audioScheduler", "_patternItemsCompleted", "_eventQueue", "_poolQueue", "_poolPointer", "_poolCounter", "_playingSoundsPerGroup", "_currentlyPlayingSoundInstancesWithThisSoundId", "_playingSoundsPerPool", "_playingPoolItems", "_playingPatternItems", "_playingPools", "_pausedPools", "_pausedPatterns", "_playingPatternArgs", "_playingPoolArgs", "_scheduledSoundContexts", "_triggerLimitPerGroup", "_triggerLimitPerSoundSeconds", "_timeOutIdCounter", "_options", "_mixer", "_eventHandler", "_assetHandler", "_tempoConfig", "_clearTimeoutAndStopSound", "clearTimeoutAndStopSound_fn", "_handleTriggerLimits", "handleTriggerLimits_fn", "_playScheduledContext", "playScheduledContext_fn", "_patternPoolOnEnded", "patternPoolOnEnded_fn", "_playSoundInPool", "playSoundInPool_fn", "_poolEndedCb", "_stopSoundWithFadeOut", "stopSoundWithFadeOut_fn", "_stopSoundWithFadeOrRenameTimeout", "stopSoundWithFadeOrRenameTimeout_fn", "_cancelOrStopSound", "cancelOrStopSound_fn", "_resumePausedPoolItems", "resumePausedPoolItems_fn", "_callOnEnded", "callOnEnded_fn", "_purgePlayingSound", "purgePlayingSound_fn", "_getItemFromPool", "getItemFromPool_fn", "_setupPools", "setupPools_fn", "_scheduleItem", "scheduleItem_fn", "_onUpdate", "onUpdate_fn", "_audioScheduler", "_patternItemsCompleted", "_eventQueue", "_poolQueue", "_poolPointer", "_poolCounter", "_playingSoundsPerGroup", "_currentlyPlayingSoundInstancesWithThisSoundId", "_playingSoundsPerPool", "_playingPoolItems", "_playingPatternItems", "_playingPools", "_pausedPools", "_pausedPatterns", "_playingPatternArgs", "_playingPoolArgs", "_scheduledSoundContexts", "_triggerLimitPerGroup", "_triggerLimitPerSoundSeconds", "_timeOutIdCounter", "_options", "_mixer", "_eventHandler", "_assetHandler", "_tempoConfig", "_clearTimeoutAndStopSound", "clearTimeoutAndStopSound_fn", "id", "parentId", "overlappingTimeoutCallers", "joinTimeoutCallers", "TIMEOUT_CALLERS", "caller", "Timer", "StopSoundArgs", "_handleTriggerLimits", "handleTriggerLimits_fn", "sound", "groupId", "group", "__privateGet", "groupSoundItems", "playingSoundInstances", "first", "createTimeoutCallerForPlayEnvelope", "ze", "_playScheduledContext", "playScheduledContext_fn", "soundContext", "whenSeconds", "onplay", "delaySeconds", "Utils", "lastGroupTriggerLimitPos", "triggerLimitElapsedSeconds", "triggerLimitRemainingSeconds", "d", "lastSoundTriggerLimitPos", "S", "cb", "_patternPoolOnEnded", "patternPoolOnEnded_fn", "args", "item", "__privateMethod", "_callOnEnded", "callOnEnded_fn", "_poolEndedCb", "_playSoundInPool", "playSoundInPool_fn", "commonParams", "playPoolArgs", "pool", "itemVolume", "itemPan", "itemPitch", "playSoundArgs", "PlaySoundArgs", "val", "poolItems", "firstIn", "_stopSoundWithFadeOut", "stopSoundWithFadeOut_fn", "stopSoundArgs", "envelopeArgs", "createPlayEnvelopeArgs", "_stopSoundWithFadeOrRenameTimeout", "stopSoundWithFadeOrRenameTimeout_fn", "isDefaultStop", "timeoutId", "timeoutDelaySeconds", "_cancelOrStopSound", "cancelOrStopSound_fn", "ctx", "Oe", "_resumePausedPoolItems", "resumePausedPoolItems_fn", "playing", "i", "W", "c", "_purgePlayingSound", "purgePlayingSound_fn", "filteredPlaying", "_getItemFromPool", "getItemFromPool_fn", "reset", "len", "type", "_setupPools", "setupPools_fn", "pools", "__privateSet", "tempArr", "index", "priority", "_scheduleItem", "scheduleItem_fn", "loopLength", "eventMethod", "now", "sTime", "isPlayEnvelopeArgs", "envTarget", "startTime", "event", "_onUpdate", "onUpdate_fn", "currentTime", "calls", "isLooped", "eventHorizon", "conf", "_mixer", "_audioContext", "_envelopeHandler", "_sequencer", "_busMeters", "_options", "_preloadOnprogressDefault", "_chrono", "chrono_fn", "_mixer", "_audioContext", "_envelopeHandler", "_sequencer", "_busMeters", "_options", "_preloadOnprogressDefault", "_chrono", "chrono_fn", "durationSeconds", "__privateGet", "noop", "instance", "logger", "getLogger", "U", "V", "t", "e", "r", "A", "$", "f", "R", "isFirefox", "userAgent", "StrictMapError", "__publicField", "_map", "_a", "_b", "StrictMap", "__privateAdd", "__privateGet", "key", "value", "callbackfn", "thisArg", "trySync", "func", "args", "err", "AutomatorError", "Automator", "automatableParameters", "j", "paramId", "valueCurve", "when", "duration", "d", "audioParam", "ie", "curveError", "He", "lastValue", "rampError", "timeoutIDs", "newTimeoutIds", "numValues", "durationPerValue", "id", "i", "valueTime", "ms", "error", "defaultValue", "param", "arraySum", "arr", "sum", "v", "logspace", "first", "last", "numSamples", "createSafeLogValue", "val", "firstLog10", "increment", "vector", "accumulated", "index", "linspace", "sigspace", "phaseStart", "phasen", "scale", "item", "createCurve", "values", "curveCreator", "totalNumSamples", "curve", "prevValue", "start", "ns", "slice", "getCurveCreator", "curveType", "createAutomationCurve", "opt", "positions", "getNumSamples", "pos", "CurveCreator", "points", "create", "qr", "Ii", "$r", "zr", "Ho", "n", "Wr", "Te", "setLogger", "loadFromName", "name", "getPredefinedLogger", "getConsoleLogger", "getTimestampLogger", "getNoopLogger", "loadUsingSearchParam", "getNameFromSearchParam", "searchParams", "getName", "isLoggerName", "isSearchParamUsed", "__spreadValues", "ea", "ta", "Ln", "na", "Ee", "oa", "unique", "array", "keys", "hasOwnProperty", "obj", "prop", "defineProperty", "o", "p", "attributes", "getOwnPropertyDescriptor", "getOwnPropertyNames", "clamp", "input", "min", "max", "AssertionError", "Assert", "condition", "isString", "AssertIsNumber", "thing", "message", "isNumber", "AssertIsDefined", "isDefined", "AssertIsNotNull", "isNull", "AssertExists", "AssertObjectNotEmpty", "isObjectEmpty", "Exists", "isUndefined", "isNotNull", "exists", "isObject", "isArray", "isTrue", "isArrayEmpty", "isArrayNonEmpty", "isNonEmptyArray", "isFunction", "isNumeric", "isStringNumber", "cloneDeep", "source", "descriptor", "clone", "enumValues", "ignoreUnused", "things", "joinUrl", "arg0", "rest", "tryAsync", "version", "navigatorExists", "hasFancyConsole", "hasNavigator", "createMessage", "fancy", "text", "dottedLone", "logEcasVersion", "_record", "Observable", "event", "listener", "callbacks", "callbacksFiltered", "callback", "GENESIS", "StateMachine", "audioStates", "loaderConfig", "full", "iter", "state", "parent", "sep", "children", "child_name", "childState", "we", "genesisState", "localStorageState", "localStorageName", "stateWithParent", "__spreadProps", "u", "parent_state", "I", "xe", "gameEvent", "child", "stateName", "activation", "eventName", "eventArguments", "act", "y", "eventNamesCorrespond", "everyEntry", "entry", "fa", "ga", "TranslationProps", "AudioFileExtension", "typename", "_BusConfig", "busProps", "MASTER_BUS_ID", "BusConfig", "BusConfig_default", "Group", "props", "Group_default", "EnvelopeData", "EnvelopePreset", "Pattern", "isEnvelopePreset", "PatternWrapper", "pattern", "Patterns_default", "PoolItem", "Pool", "Pool_default", "EncoderSettings", "EncoderPreset", "format", "FormatPreset", "preset", "Settings", "createDefaultFormatPresets", "Settings_default", "SoundEncoding", "SoundEncoding_default", "TYPENAME", "Sound", "Sound_default", "SoundConfig", "_c", "_d", "_e", "_f", "_g", "_h", "_i", "_j", "bus", "group", "sound", "pool", "Be", "he", "Le", "Q", "W", "ce", "me", "pe", "getWetMixValue", "mix", "Fe", "getDryMixValue", "FILTER_TYPES", "M", "AlgorithmicReverbInsert", "audioContext", "options", "S", "endTimeSeconds", "smoothingTimeSeconds", "D", "length", "impulse", "impulseL", "impulseR", "_BiquadFilterInsert", "context", "sampleRate", "MOST_POSITIVE_SINGLE_FLOAT_VALUE", "MOST_NEGATIVE_SINGLE_FLOAT_VALUE", "maxFrequency", "resolve", "ae", "BiquadFilterInsert", "ConvolverReverbInsert", "soundHandler", "shouldUpdateBuffer", "bufferPromise", "DelayInsert", "newId", "DynamicsCompressorInsert", "endTime", "PingPongDelayInsert", "ecasContext", "feedback", "time", "maxDelay", "EffectTypes", "T", "G", "b", "isMusicalPosition", "c", "regExp", "isTimeSignature", "BusHandlerError", "TICKS_PER_BEAT", "barBeatTickToSeconds", "tempoConfig", "now", "parts", "bars", "beats", "ticks", "signatureDenom", "secPerUnit", "secPerBeat", "secPerBar", "secPerTick", "remainUntilQuantize", "barsTotalSeconds", "beatsTotalSeconds", "ticksTotalSeconds", "createTimeSignatureFromString", "str", "wo", "meter", "unit", "Utils", "detuneInCents", "k", "newVal", "Po", "isValid", "rangeReg", "valueReg", "randomVal", "filterArr", "range", "arrayWithRandomNumbers", "volumeA", "volumeB", "a", "panA", "panB", "pitchA", "pitchB", "posA", "posB", "matches", "prefix", "uniqueId", "match", "randomCharacter", "topoSort", "edges", "EdgeNode", "nodes", "sorted", "visited", "edge", "fromEdge", "fromStr", "fromNode", "toEdge", "toEdgeStr", "visit", "idstr", "ancestorsIn", "node", "ancestors", "afterID", "isBasicTranslation", "wt", "isMinMaxTranslation", "isTranslation", "translateMinMax", "translation", "arg", "inMin", "outMin", "inRange", "outRange", "factor", "translateBasic", "translateObject", "translateTranslation", "gameArgs", "le", "translateActionArgs", "actionArgs", "result", "Re", "gameArgsCopy", "actionArg", "ri", "Oe", "EventHandler", "events", "states", "ecas", "audioEvent", "Ge", "promises", "actions", "P", "action", "translatedArgs", "unsafe", "ret", "walkThroughObject", "mappedEvent", "flat", "q", "audioEvents", "EcasEvents", "createBufferPromises", "params", "ids", "mutDetails", "eventHandler", "detail", "createAndStoreAudioBuffer", "mutBuffers", "buffer", "createAudioBuffer", "reject", "req", "createRequest", "arrayBuffer", "createBuffer", "reason", "ev", "url", "request", "editedBuffer", "createEditedBuffer", "copyAudioBuffer", "copyAudioBufferDefault", "copyAudioBufferLegacy", "src", "trg", "editedChannel", "originalChannel", "createEmptyAudioBufferLike", "reverseAudioBuffer", "bufferMutable", "channelNumber", "reversedData", "createReversedBuffer", "newBufferEmpty", "newBufferFilled", "SoundLoadError", "SoundFormatError", "_audioContext", "_details", "_buffers", "_reversedBuffers", "_sounds", "_eventHandler", "_createReversedBufferForSound", "createReversedBufferForSound_fn", "SoundHandler", "ecasOptions", "__privateSet", "fileExtToUse", "soundData", "packageToUse", "sounds", "directory", "__privateMethod", "bufferPromises", "reversed", "_groups", "_pools", "_eventAssets", "_patternContexts", "_storeSoundsRelatedToEvents", "storeSoundsRelatedToEvents_fn", "AssetHandler", "loadPromises", "relatedAssets", "Ae", "ctx", "findSoundsUsedInActions", "soundsUsed", "AudioFormats", "getPrefferedFileExtension", "available", "Ie", "je", "supported", "getBrowserSupportedAudioFormats", "isEdgeBrowser", "isSafari", "actuallySupportsWebm", "isSafariOnDesktop", "isSafariOnMobile", "isAvailable", "ext", "usable", "element", "canPlay", "type", "can", "CanPlay", "OUTPUT_BUS_ID", "TIMEOUT_CALLERS", "EnvelopeContext", "config", "ze", "createEnvelopeContext", "_contexts", "EnvelopeHandler", "PlayEnvelopeArgs", "isPlayEnvelopeArgs", "createPlayEnvelopeArgs", "num_samples", "first_log10", "Z", "value_prev", "createEnvelopePointsInOriginalState", "parentId", "acc", "curr", "joinTimeoutCallers", "createTimeoutCallerForPlayEnvelope", "caller", "_Timer", "timeout", "callerHandle", "oldCaller", "newTimeout", "remaining", "regex", "Timer", "getAudioBufferSourceNode", "bufferData", "soundContext", "playBufferSource", "startTimeSeconds", "idGen", "Bu", "Ls", "Hu", "Vu", "ni", "oi", "lastElement", "InsertHandlerError", "createInsert", "InsertHandler", "destination", "insert", "newInserts", "next", "prev", "L", "is", "createPanNode", "pan", "stereoPanner", "createGainNode", "gain", "gainNode", "playSilenceToNode", "silence", "_soundHandler", "_id", "_inputNode", "_pannerNode", "_outputNode", "Bus", "newGain", "clampedValue", "newPan", "_buses", "_busConnections", "_setupBuss", "BusHandler", "busConfigs", "busConfig", "masterBusConfig", "w", "outputBusConfig", "createSortedConnections", "soundId", "soundSource", "busId", "connections", "busNode", "buses", "busConnections", "createAudioParams", "createAudioParamArrayForBuss", "createAudioParamArrayForSound", "getBuss", "targetId", "createAudioParamArray", "getSoundConnections", "getSoundContexts", "audioParams", "getDefaultValueFromSoundConfig", "soundParams", "isSoundParam", "target", "targetType", "soundConfig", "soundParam", "getFirstValueInNDimensionalArray", "bus_", "callOnEnded", "_envelopeHandler", "_soundConnections", "_elementSoundSources", "_soundContexts", "_options", "_assetHandler", "_onCompleteSound", "onCompleteSound_fn", "_stopSoundSource", "stopSoundSource_fn", "_disconnectNodes", "disconnectNodes_fn", "_getSoundContexts", "getSoundContexts_fn", "Mixer", "assetHandler", "envelopeHandler", "contexts", "fullId", "elapsed", "startPositionSeconds", "delay", "confDuration", "soundDurationSeconds", "endPositionSeconds", "timeoutSeconds", "durationSeconds", "audioBuffer", "reverse", "sourceNode", "onEnded", "active", "bussId", "envelopeContext", "audioParamArray", "createRealValuesForEnvelopeAndCreateAndPlayAutomationCurveAndSetTimeout", "passedAudioParam", "originalAudioParamValue", "envelopeContexts", "ke", "firstEnvelope", "tid", "point", "totalDurationSeconds", "safety", "dst", "cb", "panValue", "panNode", "inputs", "inputIndex", "nodeId", "connection", "volume", "combinedId", "isSoundSourceParams", "checkEffectAndDisconnect", "connectionNode", "effect", "iOS14", "LoadrConfig", "formatPresets", "availableFileExtensions", "getAvailableFileExtensions", "exts", "formatPreset", "encoderPreset", "encoderSettings", "fmt", "encoderSettingFormatToFileExtension", "EcasOptions", "createEcasOptions", "PlaySoundArgs", "StopSoundArgs", "AnalyserConfig", "mode", "minDb", "maxDb", "fftSize", "smoothingTimeConstant", "VolumeMeter", "lastL", "lastR", "processChannel", "bufferLength", "squaredSum", "frameVal", "currL", "currR", "audioParamPolyfill", "global", "paramPrototype", "m", "stereoPannerNodePolyfill", "prototype", "StereoPannerNodeMockup", "splitter", "gainL1", "gainL2", "gainR1", "gainR2", "mergerL", "mergerR", "merger", "cancelTime", "Me", "startTime", "timeConstant", "createStereoPannerNode", "_connect", "output", "isStereoPannerNode", "webkitAudioContextPolyfill", "fixSetTarget", "maxDelayTime", "offset", "audioData", "successCallback", "errorCallback", "decodedData", "install", "Force", "Has", "ShouldInstall", "tryer", "polyfill", "force", "AudioScheduler", "timeProvider", "interval", "scheduled", "calculateSecondsPerBeat", "_audioScheduler", "_patternItemsCompleted", "_eventQueue", "_poolQueue", "_poolPointer", "_poolCounter", "_playingSoundsPerGroup", "_currentlyPlayingSoundInstancesWithThisSoundId", "_playingSoundsPerPool", "_playingPoolItems", "_playingPatternItems", "_playingPools", "_pausedPools", "_pausedPatterns", "_playingPatternArgs", "_playingPoolArgs", "_scheduledSoundContexts", "_triggerLimitPerGroup", "_triggerLimitPerSoundSeconds", "_timeOutIdCounter", "_mixer", "_tempoConfig", "_clearTimeoutAndStopSound", "clearTimeoutAndStopSound_fn", "_handleTriggerLimits", "handleTriggerLimits_fn", "_playScheduledContext", "playScheduledContext_fn", "_patternPoolOnEnded", "patternPoolOnEnded_fn", "_playSoundInPool", "playSoundInPool_fn", "_poolEndedCb", "_stopSoundWithFadeOut", "stopSoundWithFadeOut_fn", "_stopSoundWithFadeOrRenameTimeout", "stopSoundWithFadeOrRenameTimeout_fn", "_cancelOrStopSound", "cancelOrStopSound_fn", "_resumePausedPoolItems", "resumePausedPoolItems_fn", "_callOnEnded", "callOnEnded_fn", "_purgePlayingSound", "purgePlayingSound_fn", "_getItemFromPool", "getItemFromPool_fn", "_setupPools", "setupPools_fn", "_scheduleItem", "scheduleItem_fn", "_onUpdate", "onUpdate_fn", "Sequencer", "mixer", "newTempo", "newTimeSignature", "newTriggerQuantize", "playSoundArgs", "isTimeRelative", "isScheduled", "nowSeconds", "loop", "pitch", "durationArgSeconds", "startPos", "newStartTimeSeconds", "delaySeconds", "isTimeRelativeFalse", "groupId", "playbackRate", "soundFiledurationAdjustedForPlaybackRateSeconds", "stopSoundCallerToRemoveIfDelayedStopSoundHasBeenTriggeredOnSound", "finalDurationSeconds", "groupSoundItems", "onplay", "fadeinCallback", "stopCallback", "poolIndex", "commonPoolParams", "timeoutId", "playPoolArgs", "playPatternArgs", "playEnvelopeArgs", "scheduledTimeSeconds", "isDelayed", "playLater", "stopSoundArgs", "isDefaultStop", "playing", "whenSeconds", "sameSoundTimeCounter", "remain", "poolItem", "pause", "elapsedSeconds", "remainingSeconds", "isRelative", "secondsPerBeat", "patternDelay", "latencyTimeSeconds", "startPosSeconds", "numItems", "quantizeValue", "quantizeSize", "completed", "maxItemDuration", "maxLoopDurationSeconds", "isLoop", "shouldSchedule", "confStartPosSeconds", "confDurationSeconds", "confDelaySeconds", "itemDuration", "actualItemDuration", "quantizeSteps", "loopDurationSeconds", "itemStartPos", "itemDelay", "envelope", "envelopeArgs", "isCallbackAdded", "envArgs", "patternArgs", "poolDurationSeconds", "poolArgs", "actualDuration", "delayValue", "failMsg", "patternContext", "playingItems", "itemId", "itm", "arrayIndex", "len", "overlappingTimeoutCallers", "playingSoundInstances", "lastGroupTriggerLimitPos", "triggerLimitElapsedSeconds", "triggerLimitRemainingSeconds", "lastSoundTriggerLimitPos", "commonParams", "itemVolume", "itemPan", "itemPitch", "poolItems", "firstIn", "timeoutDelaySeconds", "filteredPlaying", "reset", "pools", "tempArr", "priority", "loopLength", "eventMethod", "sTime", "envTarget", "currentTime", "calls", "isLooped", "eventHorizon", "conf", "MATCH_EVERYTHING", "whenPromise", "_sequencer", "_busMeters", "_preloadOnprogressDefault", "_chrono", "chrono_fn", "_ECAS", "sucess", "count", "numberOfSoundsToPreload", "g", "eventConfig", "stateConfig", "loadrConfig", "shouldMute", "shouldBeUnmutedWhenVisible", "shouldPause", "isVisibilityPaused", "shouldResume", "ecasConfig", "N", "oninteraction", "onprogress", "soundsToPreload", "success", "remover", "tempo", "timeSignature", "initializedArgs", "automator", "getRealValues", "fe", "play", "details", "__objRest", "insertId", "applier", "Vt", "smoothingTime", "data", "analyser", "_k", "_l", "ECAS", "_events", "EventQueue", "EcasProviderError", "EcasProviderErrors", "EcasProvider", "gi", "shouldQueue", "queue", "promise", "handler", "creator", "EcasProviderSingleton", "_a", "loadPath", "ecasOptions", "Od", "triggers", "Game", "trigger", "add", "Od", "ecas", "x", "name", "params", "_a", "listener", "game", "game"]
}
